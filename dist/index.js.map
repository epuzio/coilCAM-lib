{"mappings":"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","sources":["<anon>","src/index.js","src/coilCAM/function-operators/1D-functions/index.js","src/coilCAM/function-operators/1D-functions/Sinusoidal.js","src/coilCAM/function-operators/function-helpers.js","src/coilCAM/function-operators/1D-functions/Linear.js","src/coilCAM/function-operators/1D-functions/Exponential.js","src/coilCAM/function-operators/1D-functions/Square.js","src/coilCAM/function-operators/1D-functions/Staircase.js","src/coilCAM/function-operators/2D-functions/index.js","src/coilCAM/function-operators/2D-functions/Sinusoidal2D.js","src/coilCAM/function-operators/2D-functions/Linear2D.js","src/coilCAM/function-operators/complex-functions/index.js","src/coilCAM/function-operators/complex-functions/Difference.js","node_modules/@flatten-js/core/dist/main.mjs","src/coilCAM/function-operators/complex-functions/Union.js"],"sourcesContent":["(() => {\n// Helper Functions\nfunction $4bcca76f36b7da04$var$setParams(paramType, value, nbPoints, mode) {\n    if (value == null) {\n        if (mode == \"multiplicative\" && paramType == \"values\") return new Array(nbPoints).fill(1);\n        else return new Array(nbPoints).fill(0);\n    } else if (!Array.isArray(value)) return new Array(nbPoints).fill(value);\n    else if (value.length == nbPoints) return value;\n    return null;\n}\nfunction $4bcca76f36b7da04$export$c3c5e174940bbb4f(functionType, offset, values0, nbPoints, mode) {\n    offset = $4bcca76f36b7da04$var$setParams(\"offset\", offset, nbPoints, mode);\n    values0 = $4bcca76f36b7da04$var$setParams(\"values\", values0, nbPoints, mode);\n    if (offset == null) throw new Error(\"Length of offset in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints);\n    if (values0 == null) throw new Error(\"Length of values0 in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints);\n    return [\n        offset,\n        values0\n    ];\n}\nfunction $4bcca76f36b7da04$export$d49ab658f2d8f01e(functionType, offset0x, offset0y, values0x, values0y, nbPoints, mode) {\n    offset0x = $4bcca76f36b7da04$var$setParams(\"offset0x\", offset0x, nbPoints, mode);\n    offset0y = $4bcca76f36b7da04$var$setParams(\"offset0y\", offset0y, nbPoints, mode);\n    values0x = $4bcca76f36b7da04$var$setParams(\"values0x\", values0x, nbPoints, mode);\n    values0y = $4bcca76f36b7da04$var$setParams(\"values0y\", values0y, nbPoints, mode);\n    if (offset0x == null) throw new Error(\"Length of offset in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints);\n    if (offset0y == null) throw new Error(\"Length of offset in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints);\n    if (values0x == null) throw new Error(\"Length of values0 in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints);\n    if (values0y == null) throw new Error(\"Length of values0 in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints);\n    return [\n        offset0x,\n        offset0y,\n        values0x,\n        values0y\n    ];\n}\n\n\nfunction $0501c0abff975db7$export$f56f9ea41be369b6(amplitude, offset, nbPoints, values0, mode) {\n    let values = [];\n    [offset, values0] = (0, $4bcca76f36b7da04$export$c3c5e174940bbb4f)(\"Sinusoidal\", offset, values0, nbPoints, mode);\n    for(let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == null) values.push(amplitude * Math.sin(2 * Math.PI / period * i + offset[i]) + values0[i]);\n        else if (mode == \"multiplicative\") values.push(amplitude * Math.pow(base, ampExp * i + offset[i]) * values0[i]);\n    }\n    console.log(\"SINUSOIDAL VALUES:\", values);\n    return values;\n}\nwindow.sinusoidal = $0501c0abff975db7$export$f56f9ea41be369b6;\n\n\n\nfunction $67d7baebc35cb204$export$45db2fc2f15997e7(amplitude, offset, nbPoints, values0, mode) {\n    let values = [];\n    [offset, values0] = (0, $4bcca76f36b7da04$export$c3c5e174940bbb4f)(\"Linear\", offset, values0, nbPoints, mode);\n    for(let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\") values.push(amplitude * i + offset[i] + values0[i]);\n        else if (mode == \"multiplicative\") values.push((amplitude * i + offset[i]) * values0[i]);\n    }\n    return values;\n}\nwindow.linear = $67d7baebc35cb204$export$45db2fc2f15997e7;\n\n\n\nfunction $dd5246b77fe1e789$export$d1fa2f47db032cbd(amplitude, base, ampExp, offset, nbPoints, values0, mode) {\n    let values = [];\n    [offset, values0] = (0, $4bcca76f36b7da04$export$c3c5e174940bbb4f)(\"Exponential\", offset, values0, nbPoints, mode);\n    for(let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == null) values.push(amplitude * Math.pow(base, ampExp * i + offset[i]) + values0[i]);\n        else if (mode == \"multiplicative\") values.push(amplitude * Math.pow(base, ampExp * i + offset[i]) * values0[i]);\n    }\n    return values;\n}\nwindow.exponential = $dd5246b77fe1e789$export$d1fa2f47db032cbd;\n\n\n\nfunction $8d473d3e2d9bbbc6$export$dd4f28cef696bc7d(amplitude, period, offset, bumps, nbPoints, values0, mode) {\n    let values = [];\n    [offset, values0] = (0, $4bcca76f36b7da04$export$c3c5e174940bbb4f)(\"Square\", offset, values0, nbPoints, mode);\n    for(let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == null) {\n            if (bumps && bumps <= (i + offset[i]) % period) values.push(amplitude * 0 + values0[i]);\n            else values.push(amplitude * 1 + values0[i]);\n        } else if (mode == \"multiplicative\") {\n            if (bumps && bumps <= (i + offset[i]) % period) values.push(amplitude * 0 * values0[i]);\n            else values.push(amplitude * 1 * values0[i]);\n        }\n    }\n    return values;\n}\nwindow.square = $8d473d3e2d9bbbc6$export$dd4f28cef696bc7d;\n\n\n\nfunction $36a33659f8567eb6$export$3eba2fb22fdf9e1d(stepWidth, stepHeight, offset, nbPoints, values0, mode) {\n    let values = [];\n    let index = 0;\n    [offset, values0] = (0, $4bcca76f36b7da04$export$c3c5e174940bbb4f)(\"Staircase\", offset, values0, nbPoints, mode);\n    for(let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == null) {\n            if (i % stepWidth == 0 && i != 0) index += stepHeight;\n            values.push(index + offset[i] + values0[i]);\n        }\n        if (mode == \"multiplicative\") {\n            if (i % stepWidth == 0 && i != 0) index += stepHeight;\n            values.push((index + offset[i]) * values0[i]);\n        }\n    }\n    return values;\n}\n\n\n\n\n\nfunction $c8f66e61a8125d9f$export$571f83c887fd1608(amplitudeX1, periodX1, amplitudeX2, periodX2, offset0x, offset0y, nbPoints, values0x, values0y, mode) {\n    let pointsX = [];\n    let pointsY = [];\n    [offset0x, offset0y, values0x, values0y] = (0, $4bcca76f36b7da04$export$d49ab658f2d8f01e)(\"Sinusoidal2D\", offset0x, offset0y, values0x, values0y, nbPoints, mode);\n    for(let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == null) {\n            pointsX.push(amplitudeX1 * Math.cos(2 * Math.PI * i / periodX1 + offset0x[i]) + values0x[i]);\n            pointsY.push(amplitudeX2 * Math.sin(2 * Math.PI * i / periodX2 + offset0y[i]) + values0y[i]);\n        } else if (mode == \"multiplicative\") {\n            pointsX.push(amplitudeX1 * Math.cos(2 * Math.PI * i / periodX1 + offset0x[i]) * values0x[i]);\n            pointsY.push(amplitudeX2 * Math.sin(2 * Math.PI * i / periodX2 + offset0y[i]) * values0y[i]);\n        }\n    }\n    return new Array(pointsX, pointsY);\n}\n\n\n\nfunction $e6c9001f9e65bd78$export$686d7438b647d9cf(amplitudeX1, offsetX1, amplitudeX2, offsetX2, nbPoints, values0x, values0y, mode) {\n    let pointsX = [];\n    let pointsY = [];\n    [offsetX1, offsetX2, values0x, values0y] = (0, $4bcca76f36b7da04$export$d49ab658f2d8f01e)(\"Linear2D\", offsetX1, offsetX2, values0x, values0y, nbPoints, mode);\n    for(let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == \"\") {\n            pointsX.push(amplitudeX1 * i + offsetX1[i] + values0x[i]);\n            pointsY.push(amplitudeX2 * i + offsetX2[i] + values0y[i]);\n        } else if (mode == \"multiplicative\") {\n            pointsX.push((amplitudeX1 * i + offsetX1[i]) * values0x[i]);\n            pointsY.push((amplitudeX2 * i + offsetX2[i]) * values0y[i]);\n        }\n    }\n    return new Array(pointsX, pointsY);\n}\n\n\n\n\n// /* eslint-disable no-unused-vars */\n// import Flatten from 'https://unpkg.com/@flatten-js/core/dist/main.mjs';\n/**\n * Global constant CCW defines counterclockwise direction of arc\n * @type {boolean}\n */ const $2c7a62d6ab88e4d3$export$ce920184faf97f5 = true;\n/**\n * Global constant CW defines clockwise direction of arc\n * @type {boolean}\n */ const $2c7a62d6ab88e4d3$export$640171019d58eb6d = false;\n/**\n * Defines orientation for face of the polygon: clockwise, counterclockwise\n * or not orientable in the case of self-intersection\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\n */ const $2c7a62d6ab88e4d3$export$7423c88bc54edb74 = {\n    CCW: -1,\n    CW: 1,\n    NOT_ORIENTABLE: 0\n};\nconst $2c7a62d6ab88e4d3$var$PIx2 = 2 * Math.PI;\nconst $2c7a62d6ab88e4d3$export$48ea0cac79c83ca8 = 1;\nconst $2c7a62d6ab88e4d3$export$be7fee058d85725d = 0;\nconst $2c7a62d6ab88e4d3$export$a523954c60dca5e4 = 2;\nconst $2c7a62d6ab88e4d3$var$CONTAINS = 3;\nconst $2c7a62d6ab88e4d3$var$INTERLACE = 4;\nconst $2c7a62d6ab88e4d3$export$d8b1260efb4f7671 = 1;\nconst $2c7a62d6ab88e4d3$export$f04bb74d32d98a2c = 2;\nconst $2c7a62d6ab88e4d3$var$NOT_VERTEX$1 = 0;\nconst $2c7a62d6ab88e4d3$var$START_VERTEX$1 = 1;\nconst $2c7a62d6ab88e4d3$var$END_VERTEX$1 = 2;\nvar $2c7a62d6ab88e4d3$var$Constants = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BOUNDARY: $2c7a62d6ab88e4d3$export$a523954c60dca5e4,\n    CCW: $2c7a62d6ab88e4d3$export$ce920184faf97f5,\n    CONTAINS: $2c7a62d6ab88e4d3$var$CONTAINS,\n    CW: $2c7a62d6ab88e4d3$export$640171019d58eb6d,\n    END_VERTEX: $2c7a62d6ab88e4d3$var$END_VERTEX$1,\n    INSIDE: $2c7a62d6ab88e4d3$export$48ea0cac79c83ca8,\n    INTERLACE: $2c7a62d6ab88e4d3$var$INTERLACE,\n    NOT_VERTEX: $2c7a62d6ab88e4d3$var$NOT_VERTEX$1,\n    ORIENTATION: $2c7a62d6ab88e4d3$export$7423c88bc54edb74,\n    OUTSIDE: $2c7a62d6ab88e4d3$export$be7fee058d85725d,\n    OVERLAP_OPPOSITE: $2c7a62d6ab88e4d3$export$f04bb74d32d98a2c,\n    OVERLAP_SAME: $2c7a62d6ab88e4d3$export$d8b1260efb4f7671,\n    PIx2: $2c7a62d6ab88e4d3$var$PIx2,\n    START_VERTEX: $2c7a62d6ab88e4d3$var$START_VERTEX$1\n});\n/**\n * Created by Alex Bol on 2/18/2017.\n */ /**\n * Floating point comparison tolerance.\n * Default value is 0.000001 (10e-6)\n * @type {number}\n */ let $2c7a62d6ab88e4d3$var$DP_TOL = 0.000001;\n/**\n * Set new floating point comparison tolerance\n * @param {number} tolerance\n */ function $2c7a62d6ab88e4d3$var$setTolerance(tolerance) {\n    $2c7a62d6ab88e4d3$var$DP_TOL = tolerance;\n}\n/**\n * Get floating point comparison tolerance\n * @returns {number}\n */ function $2c7a62d6ab88e4d3$var$getTolerance() {\n    return $2c7a62d6ab88e4d3$var$DP_TOL;\n}\nconst $2c7a62d6ab88e4d3$var$DECIMALS = 3;\n/**\n * Returns *true* if value comparable to zero\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */ function $2c7a62d6ab88e4d3$var$EQ_0(x) {\n    return x < $2c7a62d6ab88e4d3$var$DP_TOL && x > -$2c7a62d6ab88e4d3$var$DP_TOL;\n}\n/**\n * Returns *true* if two values are equal up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */ function $2c7a62d6ab88e4d3$var$EQ(x, y) {\n    return x - y < $2c7a62d6ab88e4d3$var$DP_TOL && x - y > -$2c7a62d6ab88e4d3$var$DP_TOL;\n}\n/**\n * Returns *true* if first argument greater than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */ function $2c7a62d6ab88e4d3$var$GT(x, y) {\n    return x - y > $2c7a62d6ab88e4d3$var$DP_TOL;\n}\n/**\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$GE(x, y) {\n    return x - y > -$2c7a62d6ab88e4d3$var$DP_TOL;\n}\n/**\n * Returns *true* if first argument less than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */ function $2c7a62d6ab88e4d3$var$LT(x, y) {\n    return x - y < -$2c7a62d6ab88e4d3$var$DP_TOL;\n}\n/**\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */ function $2c7a62d6ab88e4d3$var$LE(x, y) {\n    return x - y < $2c7a62d6ab88e4d3$var$DP_TOL;\n}\nvar $2c7a62d6ab88e4d3$export$d2ca453b913dcdea = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    DECIMALS: $2c7a62d6ab88e4d3$var$DECIMALS,\n    EQ: $2c7a62d6ab88e4d3$var$EQ,\n    EQ_0: $2c7a62d6ab88e4d3$var$EQ_0,\n    GE: $2c7a62d6ab88e4d3$var$GE,\n    GT: $2c7a62d6ab88e4d3$var$GT,\n    LE: $2c7a62d6ab88e4d3$var$LE,\n    LT: $2c7a62d6ab88e4d3$var$LT,\n    getTolerance: $2c7a62d6ab88e4d3$var$getTolerance,\n    setTolerance: $2c7a62d6ab88e4d3$var$setTolerance\n});\nlet $2c7a62d6ab88e4d3$export$2e2bcd8739ae039 = {\n    Utils: $2c7a62d6ab88e4d3$export$d2ca453b913dcdea,\n    Errors: undefined,\n    Matrix: undefined,\n    Planar_set: undefined,\n    Point: undefined,\n    Vector: undefined,\n    Line: undefined,\n    Circle: undefined,\n    Segment: undefined,\n    Arc: undefined,\n    Box: undefined,\n    Edge: undefined,\n    Face: undefined,\n    Ray: undefined,\n    Ray_shooting: undefined,\n    Multiline: undefined,\n    Polygon: undefined,\n    Distance: undefined,\n    Inversion: undefined\n};\nfor(let c in $2c7a62d6ab88e4d3$var$Constants)$2c7a62d6ab88e4d3$export$2e2bcd8739ae039[c] = $2c7a62d6ab88e4d3$var$Constants[c];\nObject.defineProperty($2c7a62d6ab88e4d3$export$2e2bcd8739ae039, \"DP_TOL\", {\n    get: function() {\n        return $2c7a62d6ab88e4d3$var$getTolerance();\n    },\n    set: function(value) {\n        $2c7a62d6ab88e4d3$var$setTolerance(value);\n    }\n});\n/**\n * Created by Alex Bol on 2/19/2017.\n */ /**\n * Class of system errors\n */ class $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac {\n    /**\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\n     * @returns {ReferenceError}\n     */ static get ILLEGAL_PARAMETERS() {\n        return new ReferenceError(\"Illegal Parameters\");\n    }\n    /**\n     * Throw error ZERO_DIVISION to catch situation of zero division\n     * @returns {Error}\n     */ static get ZERO_DIVISION() {\n        return new Error(\"Zero division\");\n    }\n    /**\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\n     * @returns {Error}\n     */ static get UNRESOLVED_BOUNDARY_CONFLICT() {\n        return new Error(\"Unresolved boundary conflict in boolean operation\");\n    }\n    /**\n     * Error to throw from LinkedList:testInfiniteLoop static method\n     * in case when circular loop detected in linked list\n     * @returns {Error}\n     */ static get INFINITE_LOOP() {\n        return new Error(\"Infinite loop\");\n    }\n    static get CANNOT_COMPLETE_BOOLEAN_OPERATION() {\n        return new Error(\"Cannot complete boolean operation\");\n    }\n    static get CANNOT_INVOKE_ABSTRACT_METHOD() {\n        return new Error(\"Abstract method cannot be invoked\");\n    }\n    static get OPERATION_IS_NOT_SUPPORTED() {\n        return new Error(\"Operation is not supported\");\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Errors = $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac;\n/**\n * Class implements bidirectional non-circular linked list. <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */ class $2c7a62d6ab88e4d3$var$LinkedList {\n    constructor(first, last){\n        this.first = first;\n        this.last = last || this.first;\n    }\n    [Symbol.iterator]() {\n        let value = undefined;\n        return {\n            next: ()=>{\n                value = value ? value.next : this.first;\n                return {\n                    value: value,\n                    done: value === undefined\n                };\n            }\n        };\n    }\n    /**\n     * Return number of elements in the list\n     * @returns {number}\n     */ get size() {\n        let counter = 0;\n        for (let edge of this)counter++;\n        return counter;\n    }\n    /**\n     * Return array of elements from start to end,\n     * If start or end not defined, take first as start, last as end\n     * @returns {Array}\n     */ toArray(start, end) {\n        let elements = [];\n        let from = start || this.first;\n        let to = end || this.last;\n        let element = from;\n        if (element === undefined) return elements;\n        do {\n            elements.push(element);\n            element = element.next;\n        }while (element !== to.next);\n        return elements;\n    }\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */ append(element) {\n        if (this.isEmpty()) this.first = element;\n        else {\n            element.prev = this.last;\n            this.last.next = element;\n        }\n        // update edge to be last\n        this.last = element;\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement\n     * @param {LinkedListElement} elementBefore\n     * @returns {LinkedList}\n     */ insert(newElement, elementBefore) {\n        if (this.isEmpty()) {\n            this.first = newElement;\n            this.last = newElement;\n        } else if (elementBefore === null || elementBefore === undefined) {\n            newElement.next = this.first;\n            this.first.prev = newElement;\n            this.first = newElement;\n        } else {\n            /* set links to new element */ let elementAfter = elementBefore.next;\n            elementBefore.next = newElement;\n            if (elementAfter) elementAfter.prev = newElement;\n            /* set links from new element */ newElement.prev = elementBefore;\n            newElement.next = elementAfter;\n            /* extend list if new element added after the last element */ if (this.last === elementBefore) this.last = newElement;\n        }\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */ remove(element) {\n        // special case if last edge removed\n        if (element === this.first && element === this.last) {\n            this.first = undefined;\n            this.last = undefined;\n        } else {\n            // update linked list\n            if (element.prev) element.prev.next = element.next;\n            if (element.next) element.next.prev = element.prev;\n            // update first if need\n            if (element === this.first) this.first = element.next;\n            // update last if need\n            if (element === this.last) this.last = element.prev;\n        }\n        return this;\n    }\n    /**\n     * Return true if list is empty\n     * @returns {boolean}\n     */ isEmpty() {\n        return this.first === undefined;\n    }\n    /**\n     * Throw an error if circular loop detected in the linked list\n     * @param {LinkedListElement} first element to start iteration\n     * @throws {Errors.INFINITE_LOOP}\n     */ static testInfiniteLoop(first) {\n        let edge = first;\n        let controlEdge = first;\n        do {\n            if (edge != first && edge === controlEdge) throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.INFINITE_LOOP; // new Error(\"Infinite loop\")\n            edge = edge.next;\n            controlEdge = controlEdge.next.next;\n        }while (edge != first);\n    }\n}\nconst $2c7a62d6ab88e4d3$var$defaultAttributes = {\n    stroke: \"black\"\n};\nclass $2c7a62d6ab88e4d3$var$SVGAttributes {\n    constructor(args = $2c7a62d6ab88e4d3$var$defaultAttributes){\n        for(const property in args)this[property] = args[property];\n        this.stroke = args.stroke ?? $2c7a62d6ab88e4d3$var$defaultAttributes.stroke;\n    }\n    toAttributesString() {\n        return Object.keys(this).reduce((acc, key)=>acc + (this[key] !== undefined ? this.toAttrString(key, this[key]) : \"\"), ``);\n    }\n    toAttrString(key, value) {\n        const SVGKey = key === \"className\" ? \"class\" : this.convertCamelToKebabCase(key);\n        return value === null ? `${SVGKey} ` : `${SVGKey}=\"${value.toString()}\" `;\n    }\n    convertCamelToKebabCase(str) {\n        return str.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g).join(\"-\").toLowerCase();\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$convertToString(attrs) {\n    return new $2c7a62d6ab88e4d3$var$SVGAttributes(attrs).toAttributesString();\n}\n/**\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\n */ class $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29 extends $2c7a62d6ab88e4d3$var$LinkedList {\n    constructor(...args){\n        super();\n        if (args.length === 0) return;\n        if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                let shapes = args[0];\n                if (shapes.length === 0) return;\n                // TODO: more strict validation:\n                // there may be only one line\n                // only first and last may be rays\n                shapes.every((shape)=>{\n                    return shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line;\n                });\n                for (let shape of shapes){\n                    let edge = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge(shape);\n                    this.append(edge);\n                }\n                this.setArcLength();\n            }\n        }\n    }\n    /**\n     * (Getter) Return array of edges\n     * @returns {Edge[]}\n     */ get edges() {\n        return [\n            ...this\n        ];\n    }\n    /**\n     * (Getter) Return bounding box of the multiline\n     * @returns {Box}\n     */ get box() {\n        return this.edges.reduce((acc, edge)=>acc.merge(edge.box), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box());\n    }\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Point[]}\n     */ get vertices() {\n        let v = this.edges.map((edge)=>edge.start);\n        v.push(this.last.end);\n        return v;\n    }\n    /**\n     * Return new cloned instance of Multiline\n     * @returns {Multiline}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29(this.toShapes());\n    }\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */ setArcLength() {\n        for (let edge of this)this.setOneEdgeArcLength(edge);\n    }\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) edge.arc_length = 0.0;\n        else edge.arc_length = edge.prev.arc_length + edge.prev.length;\n    }\n    /**\n     * Split edge and add new vertex, return new edge inserted\n     * @param {Point} pt - point on edge that will be added as new vertex\n     * @param {Edge} edge - edge to split\n     * @returns {Edge}\n     */ addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n        if (shapes[0] === null) return edge.prev;\n        if (shapes[1] === null) return edge;\n        let newEdge = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n        /* Insert first split edge into linked list after edgeBefore */ this.insert(newEdge, edgeBefore); // edge.face ?\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n        return newEdge;\n    }\n    getChain(edgeFrom, edgeTo) {\n        let edges = [];\n        for(let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next)edges.push(edge);\n        return edges;\n    }\n    /**\n     * Split edges of multiline with intersection points and return mutated multiline\n     * @param {Point[]} ip - array of points to be added as new vertices\n     * @returns {Multiline}\n     */ split(ip) {\n        for (let pt of ip){\n            let edge = this.findEdgeByPoint(pt);\n            this.addVertex(pt, edge);\n        }\n        return this;\n    }\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt\n     * @returns {Edge}\n     */ findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this)if (edge.shape.contains(pt)) {\n            edgeFound = edge;\n            break;\n        }\n        return edgeFound;\n    }\n    /**\n     * Returns new multiline translated by vector vec\n     * @param {Vector} vec\n     * @returns {Multiline}\n     */ translate(vec) {\n        return new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29(this.edges.map((edge)=>edge.shape.translate(vec)));\n    }\n    /**\n     * Return new multiline rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Multiline} - new rotated polygon\n     */ rotate(angle = 0, center = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point()) {\n        return new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29(this.edges.map((edge)=>edge.shape.rotate(angle, center)));\n    }\n    /**\n     * Return new multiline transformed using affine transformation matrix\n     * Method does not support unbounded shapes\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Multiline} - new multiline\n     */ transform(matrix = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix()) {\n        return new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29(this.edges.map((edge)=>edge.shape.transform(matrix)));\n    }\n    /**\n     * Transform multiline into array of shapes\n     * @returns {Shape[]}\n     */ toShapes() {\n        return this.edges.map((edge)=>edge.shape.clone());\n    }\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */ toJSON() {\n        return this.edges.map((edge)=>edge.toJSON());\n    }\n    /**\n     * Return string to be inserted into 'points' attribute of <polyline> element\n     * @returns {string}\n     */ svgPoints() {\n        return this.vertices.map((p)=>`${p.x},${p.y}`).join(\" \");\n    }\n    /**\n     * Return string to be assigned to 'd' attribute of <path> element\n     * @returns {*}\n     */ dpath() {\n        let dPathStr = `M${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this)dPathStr += edge.svg();\n        return dPathStr;\n    }\n    /**\n     * Return string to draw multiline in svg\n     * @param attrs  - an object with attributes for svg path element\n     * TODO: support semi-infinite Ray and infinite Line\n     * @returns {string}\n     */ svg(attrs = {}) {\n        let svgStr = `\\n<path ${$2c7a62d6ab88e4d3$var$convertToString({\n            fill: \"none\",\n            ...attrs\n        })} d=\"`;\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this)svgStr += edge.svg();\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Multiline = $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29;\n/**\n * Shortcut function to create multiline\n * @param args\n */ const $2c7a62d6ab88e4d3$export$e086dccf8e77e85 = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Multiline(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.multiline = $2c7a62d6ab88e4d3$export$e086dccf8e77e85;\n/*\n    Smart intersections describe intersection points that refers to the edges they intersect\n    This function are supposed for internal usage by morphing and relation methods between\n */ function $2c7a62d6ab88e4d3$var$addToIntPoints(edge, pt, int_points) {\n    let id = int_points.length;\n    let shapes = edge.shape.split(pt);\n    // if (shapes.length < 2) return;\n    if (shapes.length === 0) return; // Point does not belong to edge ?\n    let len = 0;\n    if (shapes[0] === null) len = 0;\n    else if (shapes[1] === null) len = edge.shape.length;\n    else len = shapes[0].length;\n    let is_vertex = $2c7a62d6ab88e4d3$var$NOT_VERTEX$1;\n    if ($2c7a62d6ab88e4d3$var$EQ(len, 0)) is_vertex |= $2c7a62d6ab88e4d3$var$START_VERTEX$1;\n    if ($2c7a62d6ab88e4d3$var$EQ(len, edge.shape.length)) is_vertex |= $2c7a62d6ab88e4d3$var$END_VERTEX$1;\n    // Fix intersection point which is end point of the last edge\n    let arc_length;\n    if (len === Infinity) arc_length = shapes[0].coord(pt);\n    else arc_length = is_vertex & $2c7a62d6ab88e4d3$var$END_VERTEX$1 && edge.next && edge.next.arc_length === 0 ? 0 : edge.arc_length + len;\n    int_points.push({\n        id: id,\n        pt: pt,\n        arc_length: arc_length,\n        edge_before: edge,\n        edge_after: undefined,\n        face: edge.face,\n        is_vertex: is_vertex\n    });\n}\nfunction $2c7a62d6ab88e4d3$var$sortIntersections(intersections) {\n    // augment intersections with new sorted arrays\n    intersections.int_points1_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points1);\n    intersections.int_points2_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points2);\n}\nfunction $2c7a62d6ab88e4d3$var$getSortedArray(int_points) {\n    let faceMap = new Map;\n    let id = 0;\n    // Create integer id's for faces\n    for (let ip of int_points)if (!faceMap.has(ip.face)) {\n        faceMap.set(ip.face, id);\n        id++;\n    }\n    // Augment intersection points with face id's\n    for (let ip of int_points)ip.faceId = faceMap.get(ip.face);\n    // Clone and sort\n    let int_points_sorted = int_points.slice().sort($2c7a62d6ab88e4d3$var$compareFn);\n    return int_points_sorted;\n}\nfunction $2c7a62d6ab88e4d3$var$compareFn(ip1, ip2) {\n    // compare face id's\n    if (ip1.faceId < ip2.faceId) return -1;\n    if (ip1.faceId > ip2.faceId) return 1;\n    // same face - compare arc_length\n    if (ip1.arc_length < ip2.arc_length) return -1;\n    if (ip1.arc_length > ip2.arc_length) return 1;\n    return 0;\n}\nfunction $2c7a62d6ab88e4d3$var$filterDuplicatedIntersections(intersections) {\n    if (intersections.int_points1.length < 2) return;\n    let do_squeeze = false;\n    let int_point_ref1;\n    let int_point_ref2;\n    let int_point_cur1;\n    let int_point_cur2;\n    for(let i = 0; i < intersections.int_points1_sorted.length; i++){\n        if (intersections.int_points1_sorted[i].id === -1) continue;\n        int_point_ref1 = intersections.int_points1_sorted[i];\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n        for(let j = i + 1; j < intersections.int_points1_sorted.length; j++){\n            int_point_cur1 = intersections.int_points1_sorted[j];\n            if (!$2c7a62d6ab88e4d3$var$EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) break;\n            if (int_point_cur1.id === -1) continue;\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\n            if (int_point_cur2.id === -1) continue;\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before && int_point_cur1.edge_after === int_point_ref1.edge_after && int_point_cur2.edge_before === int_point_ref2.edge_before && int_point_cur2.edge_after === int_point_ref2.edge_after) {\n                int_point_cur1.id = -1;\n                /* to be deleted */ int_point_cur2.id = -1;\n                /* to be deleted */ do_squeeze = true;\n            }\n        }\n    }\n    int_point_ref2 = intersections.int_points2_sorted[0];\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n    for(let i = 1; i < intersections.int_points2_sorted.length; i++){\n        let int_point_cur2 = intersections.int_points2_sorted[i];\n        if (int_point_cur2.id === -1) continue;\n        /* already deleted */ if (int_point_ref2.id === -1 || /* can't be reference if already deleted */ !$2c7a62d6ab88e4d3$var$EQ(int_point_cur2.arc_length, int_point_ref2.arc_length)) {\n            int_point_ref2 = int_point_cur2;\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n            continue;\n        }\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before && int_point_cur1.edge_after === int_point_ref1.edge_after && int_point_cur2.edge_before === int_point_ref2.edge_before && int_point_cur2.edge_after === int_point_ref2.edge_after) {\n            int_point_cur1.id = -1;\n            /* to be deleted */ int_point_cur2.id = -1;\n            /* to be deleted */ do_squeeze = true;\n        }\n    }\n    if (do_squeeze) {\n        intersections.int_points1 = intersections.int_points1.filter((int_point)=>int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter((int_point)=>int_point.id >= 0);\n        // update id's\n        intersections.int_points1.forEach((int_point, index)=>int_point.id = index);\n        intersections.int_points2.forEach((int_point, index)=>int_point.id = index);\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$initializeInclusionFlags(int_points) {\n    for (let int_point of int_points){\n        if (int_point.edge_before) {\n            int_point.edge_before.bvStart = undefined;\n            int_point.edge_before.bvEnd = undefined;\n            int_point.edge_before.bv = undefined;\n            int_point.edge_before.overlap = undefined;\n        }\n        if (int_point.edge_after) {\n            int_point.edge_after.bvStart = undefined;\n            int_point.edge_after.bvEnd = undefined;\n            int_point.edge_after.bv = undefined;\n            int_point.edge_after.overlap = undefined;\n        }\n    }\n    for (let int_point of int_points){\n        if (int_point.edge_before) int_point.edge_before.bvEnd = $2c7a62d6ab88e4d3$export$a523954c60dca5e4;\n        if (int_point.edge_after) int_point.edge_after.bvStart = $2c7a62d6ab88e4d3$export$a523954c60dca5e4;\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$calculateInclusionFlags(int_points, polygon) {\n    for (let int_point of int_points){\n        if (int_point.edge_before) int_point.edge_before.setInclusion(polygon);\n        if (int_point.edge_after) int_point.edge_after.setInclusion(polygon);\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$setOverlappingFlags(intersections) {\n    let cur_face = undefined;\n    let first_int_point_in_face_id = undefined;\n    let next_int_point1 = undefined;\n    let num_int_points = intersections.int_points1.length;\n    for(let i = 0; i < num_int_points; i++){\n        let cur_int_point1 = intersections.int_points1_sorted[i];\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = $2c7a62d6ab88e4d3$var$intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points && intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        else next_int_point_id = first_int_point_in_face_id;\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = $2c7a62d6ab88e4d3$var$intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for(let j = next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++){\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face && intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null) continue;\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n        if (!(edge_from1.bv === $2c7a62d6ab88e4d3$export$a523954c60dca5e4 && edge_to1.bv === $2c7a62d6ab88e4d3$export$a523954c60dca5e4)) continue;\n        if (edge_from1 !== edge_to1) continue;\n        /* Find boundary chain in polygon2 between same intersection points */ let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\n        let edge_from2 = cur_int_point2.edge_after;\n        let edge_to2 = next_int_point2.edge_before;\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */ /* check also that chain consist of one or two edges */ if (!(edge_from2.bv === $2c7a62d6ab88e4d3$export$a523954c60dca5e4 && edge_to2.bv === $2c7a62d6ab88e4d3$export$a523954c60dca5e4 && edge_from2 === edge_to2)) {\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\n            edge_from2 = cur_int_point2.edge_after;\n            edge_to2 = next_int_point2.edge_before;\n        }\n        if (!(edge_from2.bv === $2c7a62d6ab88e4d3$export$a523954c60dca5e4 && edge_to2.bv === $2c7a62d6ab88e4d3$export$a523954c60dca5e4 && edge_from2 === edge_to2)) continue; // not an overlapping chain - skip   TODO: fix boundary conflict\n        // Set overlapping flag - one-to-one case\n        edge_from1.setOverlap(edge_from2);\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$intPointsPoolCount(int_points, cur_int_point_num, cur_face) {\n    let int_point_current;\n    let int_point_next;\n    let int_points_pool_num = 1;\n    if (int_points.length === 1) return 1;\n    int_point_current = int_points[cur_int_point_num];\n    for(let i = cur_int_point_num + 1; i < int_points.length; i++){\n        if (int_point_current.face !== cur_face) break;\n        int_point_next = int_points[i];\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) && int_point_next.edge_before === int_point_current.edge_before && int_point_next.edge_after === int_point_current.edge_after)) break; /* next point is different - break and exit */ \n        int_points_pool_num++; /* duplicated intersection point - increase counter */ \n    }\n    return int_points_pool_num;\n}\nfunction $2c7a62d6ab88e4d3$var$splitByIntersections(polygon, int_points) {\n    if (!int_points) return;\n    for (let int_point of int_points){\n        let edge = int_point.edge_before;\n        // recalculate vertex flag: it may be changed after previous split\n        int_point.is_vertex = $2c7a62d6ab88e4d3$var$NOT_VERTEX$1;\n        if (edge.shape.start && edge.shape.start.equalTo(int_point.pt)) int_point.is_vertex |= $2c7a62d6ab88e4d3$var$START_VERTEX$1;\n        if (edge.shape.end && edge.shape.end.equalTo(int_point.pt)) int_point.is_vertex |= $2c7a62d6ab88e4d3$var$END_VERTEX$1;\n        if (int_point.is_vertex & $2c7a62d6ab88e4d3$var$START_VERTEX$1) {\n            int_point.edge_before = edge.prev;\n            if (edge.prev) int_point.is_vertex = $2c7a62d6ab88e4d3$var$END_VERTEX$1; // polygon\n            continue;\n        }\n        if (int_point.is_vertex & $2c7a62d6ab88e4d3$var$END_VERTEX$1) continue;\n        let newEdge = polygon.addVertex(int_point.pt, edge);\n        int_point.edge_before = newEdge;\n    }\n    for (let int_point of int_points){\n        if (int_point.edge_before) int_point.edge_after = int_point.edge_before.next;\n        else if (polygon instanceof $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29 && int_point.is_vertex & $2c7a62d6ab88e4d3$var$START_VERTEX$1) int_point.edge_after = polygon.first;\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$insertBetweenIntPoints(int_point1, int_point2, new_edges) {\n    const edge_before = int_point1.edge_before;\n    const edge_after = int_point2.edge_after;\n    const len = new_edges.length;\n    edge_before.next = new_edges[0];\n    new_edges[0].prev = edge_before;\n    new_edges[len - 1].next = edge_after;\n    edge_after.prev = new_edges[len - 1];\n}\nvar $2c7a62d6ab88e4d3$export$53fcb32448848863 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    addToIntPoints: $2c7a62d6ab88e4d3$var$addToIntPoints,\n    calculateInclusionFlags: $2c7a62d6ab88e4d3$var$calculateInclusionFlags,\n    filterDuplicatedIntersections: $2c7a62d6ab88e4d3$var$filterDuplicatedIntersections,\n    getSortedArray: $2c7a62d6ab88e4d3$var$getSortedArray,\n    initializeInclusionFlags: $2c7a62d6ab88e4d3$var$initializeInclusionFlags,\n    insertBetweenIntPoints: $2c7a62d6ab88e4d3$var$insertBetweenIntPoints,\n    intPointsPoolCount: $2c7a62d6ab88e4d3$var$intPointsPoolCount,\n    setOverlappingFlags: $2c7a62d6ab88e4d3$var$setOverlappingFlags,\n    sortIntersections: $2c7a62d6ab88e4d3$var$sortIntersections,\n    splitByIntersections: $2c7a62d6ab88e4d3$var$splitByIntersections\n});\n/**\n * Created by Alex Bol on 12/02/2018.\n */ /**\n * @module BooleanOperations\n */ const { INSIDE: $2c7a62d6ab88e4d3$var$INSIDE$1, OUTSIDE: $2c7a62d6ab88e4d3$var$OUTSIDE, BOUNDARY: $2c7a62d6ab88e4d3$var$BOUNDARY, OVERLAP_SAME: $2c7a62d6ab88e4d3$var$OVERLAP_SAME, OVERLAP_OPPOSITE: $2c7a62d6ab88e4d3$var$OVERLAP_OPPOSITE } = $2c7a62d6ab88e4d3$var$Constants;\nconst { NOT_VERTEX: $2c7a62d6ab88e4d3$var$NOT_VERTEX, START_VERTEX: $2c7a62d6ab88e4d3$var$START_VERTEX, END_VERTEX: $2c7a62d6ab88e4d3$var$END_VERTEX } = $2c7a62d6ab88e4d3$var$Constants;\nconst $2c7a62d6ab88e4d3$var$BOOLEAN_UNION = 1;\nconst $2c7a62d6ab88e4d3$var$BOOLEAN_INTERSECT = 2;\nconst $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT = 3;\n/**\n * Unify two polygons polygons and returns new polygon. <br/>\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */ function $2c7a62d6ab88e4d3$var$unify(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = $2c7a62d6ab88e4d3$var$booleanOpBinary(polygon1, polygon2, $2c7a62d6ab88e4d3$var$BOOLEAN_UNION, true);\n    return res_poly;\n}\n/**\n * Subtract second polygon from the first and returns new polygon\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */ function $2c7a62d6ab88e4d3$var$subtract(polygon1, polygon2) {\n    let polygon2_tmp = polygon2.clone();\n    let polygon2_reversed = polygon2_tmp.reverse();\n    let [res_poly, wrk_poly] = $2c7a62d6ab88e4d3$var$booleanOpBinary(polygon1, polygon2_reversed, $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT, true);\n    return res_poly;\n}\n/**\n * Intersect two polygons and returns new polygon\n * Point belongs to the resulted polygon is it belongs to the first AND to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */ function $2c7a62d6ab88e4d3$var$intersect$1(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = $2c7a62d6ab88e4d3$var$booleanOpBinary(polygon1, polygon2, $2c7a62d6ab88e4d3$var$BOOLEAN_INTERSECT, true);\n    return res_poly;\n}\n/**\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\n * The first array are shapes from the first polygon, the second array are shapes from the second\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[][]}\n */ function $2c7a62d6ab88e4d3$var$innerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = $2c7a62d6ab88e4d3$var$booleanOpBinary(polygon1, polygon2, $2c7a62d6ab88e4d3$var$BOOLEAN_INTERSECT, false);\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces)clip_shapes1 = [\n        ...clip_shapes1,\n        ...[\n            ...face.edges\n        ].map((edge)=>edge.shape)\n    ];\n    let clip_shapes2 = [];\n    for (let face of wrk_poly.faces)clip_shapes2 = [\n        ...clip_shapes2,\n        ...[\n            ...face.edges\n        ].map((edge)=>edge.shape)\n    ];\n    return [\n        clip_shapes1,\n        clip_shapes2\n    ];\n}\n/**\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[]}\n */ function $2c7a62d6ab88e4d3$var$outerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = $2c7a62d6ab88e4d3$var$booleanOpBinary(polygon1, polygon2, $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT, false);\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces)clip_shapes1 = [\n        ...clip_shapes1,\n        ...[\n            ...face.edges\n        ].map((edge)=>edge.shape)\n    ];\n    return clip_shapes1;\n}\n/**\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\n * Points in the first array belong to first polygon, points from the second - to the second.\n * Points in each array are ordered according to the direction of the correspondent polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Point[][]}\n */ function $2c7a62d6ab88e4d3$var$calculateIntersections(polygon1, polygon2) {\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n    // get intersection points\n    let intersections = $2c7a62d6ab88e4d3$var$getIntersections(res_poly, wrk_poly);\n    // sort intersection points\n    $2c7a62d6ab88e4d3$var$sortIntersections(intersections);\n    // split by intersection points\n    $2c7a62d6ab88e4d3$var$splitByIntersections(res_poly, intersections.int_points1_sorted);\n    $2c7a62d6ab88e4d3$var$splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n    // filter duplicated intersection points\n    $2c7a62d6ab88e4d3$var$filterDuplicatedIntersections(intersections);\n    // sort intersection points again after filtering\n    $2c7a62d6ab88e4d3$var$sortIntersections(intersections);\n    let ip_sorted1 = intersections.int_points1_sorted.map((int_point)=>int_point.pt);\n    let ip_sorted2 = intersections.int_points2_sorted.map((int_point)=>int_point.pt);\n    return [\n        ip_sorted1,\n        ip_sorted2\n    ];\n}\nfunction $2c7a62d6ab88e4d3$var$filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\n    // keep not intersected faces for further remove and merge\n    let notIntersectedFacesRes = $2c7a62d6ab88e4d3$var$getNotIntersectedFaces(res_poly, intersections.int_points1);\n    let notIntersectedFacesWrk = $2c7a62d6ab88e4d3$var$getNotIntersectedFaces(wrk_poly, intersections.int_points2);\n    // calculate inclusion flag for not intersected faces\n    $2c7a62d6ab88e4d3$var$calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\n    $2c7a62d6ab88e4d3$var$calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\n    // initialize inclusion flags for edges incident to intersections\n    $2c7a62d6ab88e4d3$var$initializeInclusionFlags(intersections.int_points1);\n    $2c7a62d6ab88e4d3$var$initializeInclusionFlags(intersections.int_points2);\n    // calculate inclusion flags only for edges incident to intersections\n    $2c7a62d6ab88e4d3$var$calculateInclusionFlags(intersections.int_points1, wrk_poly);\n    $2c7a62d6ab88e4d3$var$calculateInclusionFlags(intersections.int_points2, res_poly);\n    // fix boundary conflicts\n    while($2c7a62d6ab88e4d3$var$fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\n    $2c7a62d6ab88e4d3$var$setOverlappingFlags(intersections);\n    // remove not relevant chains between intersection points\n    $2c7a62d6ab88e4d3$var$removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\n    $2c7a62d6ab88e4d3$var$removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\n    $2c7a62d6ab88e4d3$var$removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\n    $2c7a62d6ab88e4d3$var$removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\n}\nfunction $2c7a62d6ab88e4d3$var$swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\n    // add edges of wrk_poly into the edge container of res_poly\n    $2c7a62d6ab88e4d3$var$copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\n    // swap links from res_poly to wrk_poly and vice versa\n    $2c7a62d6ab88e4d3$var$swapLinks(res_poly, wrk_poly, intersections);\n    // remove old faces\n    $2c7a62d6ab88e4d3$var$removeOldFaces(res_poly, intersections.int_points1);\n    $2c7a62d6ab88e4d3$var$removeOldFaces(wrk_poly, intersections.int_points2);\n    // restore faces\n    $2c7a62d6ab88e4d3$var$restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\n    $2c7a62d6ab88e4d3$var$restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\n// merge relevant not intersected faces from wrk_polygon to res_polygon\n// mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\n}\nfunction $2c7a62d6ab88e4d3$var$booleanOpBinary(polygon1, polygon2, op, restore) {\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n    // get intersection points\n    let intersections = $2c7a62d6ab88e4d3$var$getIntersections(res_poly, wrk_poly);\n    // sort intersection points\n    $2c7a62d6ab88e4d3$var$sortIntersections(intersections);\n    // split by intersection points\n    $2c7a62d6ab88e4d3$var$splitByIntersections(res_poly, intersections.int_points1_sorted);\n    $2c7a62d6ab88e4d3$var$splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n    // filter duplicated intersection points\n    $2c7a62d6ab88e4d3$var$filterDuplicatedIntersections(intersections);\n    // sort intersection points again after filtering\n    $2c7a62d6ab88e4d3$var$sortIntersections(intersections);\n    // calculate inclusion and remove not relevant edges\n    $2c7a62d6ab88e4d3$var$filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\n    if (restore) $2c7a62d6ab88e4d3$var$swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\n    return [\n        res_poly,\n        wrk_poly\n    ];\n}\nfunction $2c7a62d6ab88e4d3$var$getIntersections(polygon1, polygon2) {\n    let intersections = {\n        int_points1: [],\n        int_points2: []\n    };\n    // calculate intersections\n    for (let edge1 of polygon1.edges){\n        // request edges of polygon2 in the box of edge1\n        let resp = polygon2.edges.search(edge1.box);\n        // for each edge2 in response\n        for (let edge2 of resp){\n            // calculate intersections between edge1 and edge2\n            let ip = edge1.shape.intersect(edge2.shape);\n            // for each intersection point\n            for (let pt of ip){\n                $2c7a62d6ab88e4d3$var$addToIntPoints(edge1, pt, intersections.int_points1);\n                $2c7a62d6ab88e4d3$var$addToIntPoints(edge2, pt, intersections.int_points2);\n            }\n        }\n    }\n    return intersections;\n}\nfunction $2c7a62d6ab88e4d3$var$getNotIntersectedFaces(poly, int_points) {\n    let notIntersected = [];\n    for (let face of poly.faces)if (!int_points.find((ip)=>ip.face === face)) notIntersected.push(face);\n    return notIntersected;\n}\nfunction $2c7a62d6ab88e4d3$var$calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2) {\n    for (let face of notIntersectedFaces){\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\n        face.first.setInclusion(poly2);\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections) {\n    let cur_face;\n    let first_int_point_in_face_id;\n    let next_int_point1;\n    let num_int_points = int_points1_sorted.length;\n    let iterate_more = false;\n    for(let i = 0; i < num_int_points; i++){\n        let cur_int_point1 = int_points1_sorted[i];\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = $2c7a62d6ab88e4d3$var$intPointsPoolCount(int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points && int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        else next_int_point_id = first_int_point_in_face_id;\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = $2c7a62d6ab88e4d3$var$intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for(let j = next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++){\n            let next_int_point1_tmp = int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face && int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null) continue;\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\n        if (edge_from1.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_to1.bv != $2c7a62d6ab88e4d3$var$BOUNDARY) {\n            edge_from1.bv = edge_to1.bv;\n            continue;\n        }\n        if (edge_from1.bv != $2c7a62d6ab88e4d3$var$BOUNDARY && edge_to1.bv === $2c7a62d6ab88e4d3$var$BOUNDARY) {\n            edge_to1.bv = edge_from1.bv;\n            continue;\n        }\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\n        if (edge_from1.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_to1.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_from1 != edge_to1 || edge_from1.bv === $2c7a62d6ab88e4d3$var$INSIDE$1 && edge_to1.bv === $2c7a62d6ab88e4d3$var$OUTSIDE || edge_from1.bv === $2c7a62d6ab88e4d3$var$OUTSIDE && edge_to1.bv === $2c7a62d6ab88e4d3$var$INSIDE$1) {\n            let edge_tmp = edge_from1.next;\n            while(edge_tmp != edge_to1){\n                edge_tmp.bvStart = undefined;\n                edge_tmp.bvEnd = undefined;\n                edge_tmp.bv = undefined;\n                edge_tmp.setInclusion(poly2);\n                edge_tmp = edge_tmp.next;\n            }\n        }\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\n        if (edge_from1.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_to1.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_from1 != edge_to1) {\n            let edge_tmp = edge_from1.next;\n            let new_bv;\n            while(edge_tmp != edge_to1){\n                if (edge_tmp.bv != $2c7a62d6ab88e4d3$var$BOUNDARY) {\n                    if (new_bv === undefined) new_bv = edge_tmp.bv;\n                    else {\n                        if (edge_tmp.bv != new_bv) throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.UNRESOLVED_BOUNDARY_CONFLICT;\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n            if (new_bv != undefined) {\n                edge_from1.bv = new_bv;\n                edge_to1.bv = new_bv;\n            }\n            continue; // all middle edges are boundary, proceed with this\n        }\n        // Case 3. One of the ends is inner, another is outer\n        if (edge_from1.bv === $2c7a62d6ab88e4d3$var$INSIDE$1 && edge_to1.bv === $2c7a62d6ab88e4d3$var$OUTSIDE || edge_from1.bv === $2c7a62d6ab88e4d3$var$OUTSIDE && edge_to1.bv === $2c7a62d6ab88e4d3$var$INSIDE$1) {\n            let edge_tmp = edge_from1;\n            // Find missing intersection point\n            while(edge_tmp != edge_to1){\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\n                    if (dist < 10 * $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.DP_TOL) {\n                        // let pt = edge_tmp.end;\n                        // add to the list of intersections of poly1\n                        $2c7a62d6ab88e4d3$var$addToIntPoints(edge_tmp, segment.ps, int_points1);\n                        // split edge_tmp in poly1 if need\n                        let int_point1 = int_points1[int_points1.length - 1];\n                        if (int_point1.is_vertex & $2c7a62d6ab88e4d3$var$START_VERTEX) {\n                            int_point1.edge_after = edge_tmp;\n                            int_point1.edge_before = edge_tmp.prev;\n                            edge_tmp.bvStart = $2c7a62d6ab88e4d3$var$BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        } else if (int_point1.is_vertex & $2c7a62d6ab88e4d3$var$END_VERTEX) {\n                            int_point1.edge_after = edge_tmp.next;\n                            edge_tmp.bvEnd = $2c7a62d6ab88e4d3$var$BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        } else {\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\n                            int_point1.edge_before = newEdge1;\n                            int_point1.edge_after = newEdge1.next;\n                            newEdge1.setInclusion(poly2);\n                            newEdge1.next.bvStart = $2c7a62d6ab88e4d3$var$BOUNDARY;\n                            newEdge1.next.bvEnd = undefined;\n                            newEdge1.next.bv = undefined;\n                            newEdge1.next.setInclusion(poly2);\n                        }\n                        // add to the list of intersections of poly2\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\n                        $2c7a62d6ab88e4d3$var$addToIntPoints(edge2, segment.pe, int_points2);\n                        // split edge2 in poly2 if need\n                        let int_point2 = int_points2[int_points2.length - 1];\n                        if (int_point2.is_vertex & $2c7a62d6ab88e4d3$var$START_VERTEX) {\n                            int_point2.edge_after = edge2;\n                            int_point2.edge_before = edge2.prev;\n                        } else if (int_point2.is_vertex & $2c7a62d6ab88e4d3$var$END_VERTEX) int_point2.edge_after = edge2.next;\n                        else {\n                            // first locate int_points that may refer to edge2 as edge.after\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\n                            let int_point2_edge_after = int_points2.find((int_point)=>int_point.edge_after === edge2);\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\n                            int_point2.edge_before = newEdge2;\n                            int_point2.edge_after = newEdge2.next;\n                            if (int_point2_edge_after) int_point2_edge_after.edge_after = newEdge2;\n                            newEdge2.bvStart = undefined;\n                            newEdge2.bvEnd = $2c7a62d6ab88e4d3$var$BOUNDARY;\n                            newEdge2.bv = undefined;\n                            newEdge2.setInclusion(poly1);\n                            newEdge2.next.bvStart = $2c7a62d6ab88e4d3$var$BOUNDARY;\n                            newEdge2.next.bvEnd = undefined;\n                            newEdge2.next.bv = undefined;\n                            newEdge2.next.setInclusion(poly1);\n                        }\n                        $2c7a62d6ab88e4d3$var$sortIntersections(intersections);\n                        iterate_more = true;\n                        break;\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n            // we changed intersections inside loop, have to exit and repair again\n            if (iterate_more) break;\n            throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.UNRESOLVED_BOUNDARY_CONFLICT;\n        }\n    }\n    return iterate_more;\n}\nfunction $2c7a62d6ab88e4d3$var$removeNotRelevantChains(polygon, op, int_points, is_res_polygon) {\n    if (!int_points) return;\n    let cur_face = undefined;\n    let first_int_point_in_face_num = undefined;\n    let int_point_current;\n    let int_point_next;\n    for(let i = 0; i < int_points.length; i++){\n        int_point_current = int_points[i];\n        if (int_point_current.face !== cur_face) {\n            first_int_point_in_face_num = i;\n            cur_face = int_point_current.face;\n        }\n        if (cur_face.isEmpty()) continue;\n        // Get next int point from the same face that current\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\n        let int_points_from_pull_start = i;\n        let int_points_from_pull_num = $2c7a62d6ab88e4d3$var$intPointsPoolCount(int_points, i, cur_face);\n        let next_int_point_num;\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length && int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\n        else next_int_point_num = first_int_point_in_face_num;\n        int_point_next = int_points[next_int_point_num];\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */ let int_points_to_pull_start = next_int_point_num;\n        let int_points_to_pull_num = $2c7a62d6ab88e4d3$var$intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\n        let edge_from = int_point_current.edge_after;\n        let edge_to = int_point_next.edge_before;\n        if (edge_from.bv === $2c7a62d6ab88e4d3$var$INSIDE$1 && edge_to.bv === $2c7a62d6ab88e4d3$var$INSIDE$1 && op === $2c7a62d6ab88e4d3$var$BOOLEAN_UNION || edge_from.bv === $2c7a62d6ab88e4d3$var$OUTSIDE && edge_to.bv === $2c7a62d6ab88e4d3$var$OUTSIDE && op === $2c7a62d6ab88e4d3$var$BOOLEAN_INTERSECT || (edge_from.bv === $2c7a62d6ab88e4d3$var$OUTSIDE || edge_to.bv === $2c7a62d6ab88e4d3$var$OUTSIDE) && op === $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT && !is_res_polygon || (edge_from.bv === $2c7a62d6ab88e4d3$var$INSIDE$1 || edge_to.bv === $2c7a62d6ab88e4d3$var$INSIDE$1) && op === $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT && is_res_polygon || edge_from.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_to.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_from.overlap & $2c7a62d6ab88e4d3$var$OVERLAP_SAME && is_res_polygon || edge_from.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_to.bv === $2c7a62d6ab88e4d3$var$BOUNDARY && edge_from.overlap & $2c7a62d6ab88e4d3$var$OVERLAP_OPPOSITE) {\n            polygon.removeChain(cur_face, edge_from, edge_to);\n            /* update all points in \"points from\" pull */ for(let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++)int_points[k].edge_after = undefined;\n            /* update all points in \"points to\" pull */ for(let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++)int_points[k].edge_before = undefined;\n        }\n        /* skip to the last point in \"points from\" group */ i += int_points_from_pull_num - 1;\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$copyWrkToRes(res_polygon, wrk_polygon, op, int_points) {\n    for (let face of wrk_polygon.faces){\n        for (let edge of face)res_polygon.edges.add(edge);\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\n        if (/*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/ int_points.find((ip)=>ip.face === face) === undefined) res_polygon.addFace(face.first, face.last);\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$swapLinks(res_polygon, wrk_polygon, intersections) {\n    if (intersections.int_points1.length === 0) return;\n    for(let i = 0; i < intersections.int_points1.length; i++){\n        let int_point1 = intersections.int_points1[i];\n        let int_point2 = intersections.int_points2[i];\n        // Simple case - find continuation on the other polygon\n        // Process edge from res_polygon\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {\n                // Connect edges\n                int_point1.edge_before.next = int_point2.edge_after;\n                int_point2.edge_after.prev = int_point1.edge_before;\n                // Fill in missed links in intersection points\n                int_point1.edge_after = int_point2.edge_after;\n                int_point2.edge_before = int_point1.edge_before;\n            }\n        }\n        // Process edge from wrk_polygon\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {\n                // Connect edges\n                int_point2.edge_before.next = int_point1.edge_after;\n                int_point1.edge_after.prev = int_point2.edge_before;\n                // Complete missed links\n                int_point2.edge_after = int_point1.edge_after;\n                int_point1.edge_before = int_point2.edge_before;\n            }\n        }\n        // Continuation not found - complex case\n        // Continuation will be found on the same polygon.\n        // It happens when intersection point is actually touching point\n        // Polygon1\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) for (let int_point of intersections.int_points1_sorted){\n            if (int_point === int_point1) continue; // skip same\n            if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                if (int_point.pt.equalTo(int_point1.pt)) {\n                    // Connect edges\n                    int_point1.edge_before.next = int_point.edge_after;\n                    int_point.edge_after.prev = int_point1.edge_before;\n                    // Complete missed links\n                    int_point1.edge_after = int_point.edge_after;\n                    int_point.edge_before = int_point1.edge_before;\n                }\n            }\n        }\n        // Polygon2\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) for (let int_point of intersections.int_points2_sorted){\n            if (int_point === int_point2) continue; // skip same\n            if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                if (int_point.pt.equalTo(int_point2.pt)) {\n                    // Connect edges\n                    int_point2.edge_before.next = int_point.edge_after;\n                    int_point.edge_after.prev = int_point2.edge_before;\n                    // Complete missed links\n                    int_point2.edge_after = int_point.edge_after;\n                    int_point.edge_before = int_point2.edge_before;\n                }\n            }\n        }\n    }\n// Sanity check that no dead ends left\n}\nfunction $2c7a62d6ab88e4d3$var$removeOldFaces(polygon, int_points) {\n    for (let int_point of int_points){\n        polygon.faces.delete(int_point.face);\n        int_point.face = undefined;\n        if (int_point.edge_before) int_point.edge_before.face = undefined;\n        if (int_point.edge_after) int_point.edge_after.face = undefined;\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$restoreFaces(polygon, int_points, other_int_points) {\n    // For each intersection point - create new face\n    for (let int_point of int_points){\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined) continue;\n        if (int_point.face) continue;\n        if (int_point.edge_after.face || int_point.edge_before.face) continue;\n        let first = int_point.edge_after; // face start\n        let last = int_point.edge_before; // face end;\n        try {\n            $2c7a62d6ab88e4d3$var$LinkedList.testInfiniteLoop(first); // check and throw error if infinite loop found\n        } catch (error) {\n            throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.CANNOT_COMPLETE_BOOLEAN_OPERATION;\n        }\n        let face = polygon.addFace(first, last);\n        // Mark intersection points from the newly create face\n        // to avoid multiple creation of the same face.\n        // Face was assigned to each edge of new face in addFace function\n        for (let int_point_tmp of int_points)if (int_point_tmp.edge_before && int_point_tmp.edge_after && int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) int_point_tmp.face = face;\n        // Mark other intersection points as well\n        for (let int_point_tmp of other_int_points)if (int_point_tmp.edge_before && int_point_tmp.edge_after && int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) int_point_tmp.face = face;\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon) {\n    for (let face of notIntersectedFaces){\n        let rel = face.first.bv;\n        if (op === $2c7a62d6ab88e4d3$var$BOOLEAN_UNION && rel === $2c7a62d6ab88e4d3$var$INSIDE$1 || op === $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT && rel === $2c7a62d6ab88e4d3$var$INSIDE$1 && is_res_polygon || op === $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT && rel === $2c7a62d6ab88e4d3$var$OUTSIDE && !is_res_polygon || op === $2c7a62d6ab88e4d3$var$BOOLEAN_INTERSECT && rel === $2c7a62d6ab88e4d3$var$OUTSIDE) polygon.deleteFace(face);\n    }\n}\nvar $2c7a62d6ab88e4d3$export$7810ed04e2e13fba = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BOOLEAN_INTERSECT: $2c7a62d6ab88e4d3$var$BOOLEAN_INTERSECT,\n    BOOLEAN_SUBTRACT: $2c7a62d6ab88e4d3$var$BOOLEAN_SUBTRACT,\n    BOOLEAN_UNION: $2c7a62d6ab88e4d3$var$BOOLEAN_UNION,\n    calculateIntersections: $2c7a62d6ab88e4d3$var$calculateIntersections,\n    innerClip: $2c7a62d6ab88e4d3$var$innerClip,\n    intersect: $2c7a62d6ab88e4d3$var$intersect$1,\n    outerClip: $2c7a62d6ab88e4d3$var$outerClip,\n    removeNotRelevantChains: $2c7a62d6ab88e4d3$var$removeNotRelevantChains,\n    removeOldFaces: $2c7a62d6ab88e4d3$var$removeOldFaces,\n    restoreFaces: $2c7a62d6ab88e4d3$var$restoreFaces,\n    subtract: $2c7a62d6ab88e4d3$var$subtract,\n    unify: $2c7a62d6ab88e4d3$var$unify\n});\n/*\n    Dimensionally extended 9-intersected model\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\n */ // const DISJOINT = RegExp('FF.FF....');\nconst $2c7a62d6ab88e4d3$var$EQUAL = RegExp(\"T.F..FFF.|T.F...F..\");\nconst $2c7a62d6ab88e4d3$var$INTERSECT = RegExp(\"T........|.T.......|...T.....|....T....\");\nconst $2c7a62d6ab88e4d3$var$TOUCH = RegExp(\"FT.......|F..T.....|F...T....\");\nconst $2c7a62d6ab88e4d3$var$INSIDE = RegExp(\"T.F..F...\");\nconst $2c7a62d6ab88e4d3$var$COVERED = RegExp(\"T.F..F...|.TF..F...|..FT.F...|..F.TF...\");\nclass $2c7a62d6ab88e4d3$var$DE9IM {\n    /**\n     * Create new instance of DE9IM matrix\n     */ constructor(){\n        /**\n         * Array representing 3x3 intersection matrix\n         * @type {Shape[]}\n         */ this.m = new Array(9).fill(undefined);\n    }\n    /**\n     * Get Interior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */ get I2I() {\n        return this.m[0];\n    }\n    /**\n     * Set Interior To Interior intersection\n     * @param geom\n     */ set I2I(geom) {\n        this.m[0] = geom;\n    }\n    /**\n     * Get Interior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */ get I2B() {\n        return this.m[1];\n    }\n    /**\n     * Set Interior to Boundary intersection\n     * @param geomc\n     */ set I2B(geom) {\n        this.m[1] = geom;\n    }\n    /**\n     * Get Interior To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */ get I2E() {\n        return this.m[2];\n    }\n    /**\n     * Set Interior to Exterior intersection\n     * @param geom\n     */ set I2E(geom) {\n        this.m[2] = geom;\n    }\n    /**\n     * Get Boundary To Interior intersection\n     * @returns {Shape[] | undefined}\n     */ get B2I() {\n        return this.m[3];\n    }\n    /**\n     * Set Boundary to Interior intersection\n     * @param geom\n     */ set B2I(geom) {\n        this.m[3] = geom;\n    }\n    /**\n     * Get Boundary To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */ get B2B() {\n        return this.m[4];\n    }\n    /**\n     * Set Boundary to Boundary intersection\n     * @param geom\n     */ set B2B(geom) {\n        this.m[4] = geom;\n    }\n    /**\n     * Get Boundary To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */ get B2E() {\n        return this.m[5];\n    }\n    /**\n     * Set Boundary to Exterior intersection\n     * @param geom\n     */ set B2E(geom) {\n        this.m[5] = geom;\n    }\n    /**\n     * Get Exterior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */ get E2I() {\n        return this.m[6];\n    }\n    /**\n     * Set Exterior to Interior intersection\n     * @param geom\n     */ set E2I(geom) {\n        this.m[6] = geom;\n    }\n    /**\n     * Get Exterior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */ get E2B() {\n        return this.m[7];\n    }\n    /**\n     * Set Exterior to Boundary intersection\n     * @param geom\n     */ set E2B(geom) {\n        this.m[7] = geom;\n    }\n    /**\n     * Get Exterior to Exterior intersection\n     * @returns {Shape[] | undefined}\n     */ get E2E() {\n        return this.m[8];\n    }\n    /**\n     * Set Exterior to Exterior intersection\n     * @param geom\n     */ set E2E(geom) {\n        this.m[8] = geom;\n    }\n    /**\n     * Return de9im matrix as string where<br/>\n     * - intersection is 'T'<br/>\n     * - not intersected is 'F'<br/>\n     * - not relevant is '*'<br/>\n     * For example, string 'FF**FF****' means 'DISJOINT'\n     * @returns {string}\n     */ toString() {\n        return this.m.map((e)=>{\n            if (e instanceof Array && e.length > 0) return \"T\";\n            else if (e instanceof Array && e.length === 0) return \"F\";\n            else return \"*\";\n        }).join(\"\");\n    }\n    equal() {\n        return $2c7a62d6ab88e4d3$var$EQUAL.test(this.toString());\n    }\n    intersect() {\n        return $2c7a62d6ab88e4d3$var$INTERSECT.test(this.toString());\n    }\n    touch() {\n        return $2c7a62d6ab88e4d3$var$TOUCH.test(this.toString());\n    }\n    inside() {\n        return $2c7a62d6ab88e4d3$var$INSIDE.test(this.toString());\n    }\n    covered() {\n        return $2c7a62d6ab88e4d3$var$COVERED.test(this.toString());\n    }\n}\n/**\n * Intersection\n *\n * */ function $2c7a62d6ab88e4d3$var$intersectLine2Line(line1, line2) {\n    let ip = [];\n    let [A1, B1, C1] = line1.standard;\n    let [A2, B2, C2] = line2.standard;\n    /* Cramer's rule */ let det = A1 * B2 - B1 * A2;\n    let detX = C1 * B2 - B1 * C2;\n    let detY = A1 * C2 - C1 * A2;\n    if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(det)) {\n        let x, y;\n        if (B1 === 0) {\n            x = C1 / A1;\n            y = detY / det;\n        } else if (B2 === 0) {\n            x = C2 / A2;\n            y = detY / det;\n        } else if (A1 === 0) {\n            x = detX / det;\n            y = C1 / B1;\n        } else if (A2 === 0) {\n            x = detX / det;\n            y = C2 / B2;\n        } else {\n            x = detX / det;\n            y = detY / det;\n        }\n        ip.push(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(x, y));\n    }\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectLine2Circle(line, circle) {\n    let ip = [];\n    let prj = circle.pc.projectionOn(line); // projection of circle center on a line\n    let dist = circle.pc.distanceTo(prj)[0]; // distance from circle center to projection\n    if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(dist, circle.r)) ip.push(prj);\n    else if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist, circle.r)) {\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\n        let v_trans, pt;\n        v_trans = line.norm.rotate90CCW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n        v_trans = line.norm.rotate90CW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n    }\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectLine2Box(line, box) {\n    let ips = [];\n    for (let seg of box.toSegments()){\n        let ips_tmp = $2c7a62d6ab88e4d3$var$intersectSegment2Line(seg, line);\n        for (let pt of ips_tmp)if (!$2c7a62d6ab88e4d3$var$ptInIntPoints(pt, ips)) ips.push(pt);\n    }\n    return ips;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectLine2Arc(line, arc) {\n    let ip = [];\n    if ($2c7a62d6ab88e4d3$var$intersectLine2Box(line, arc.box).length === 0) return ip;\n    let circle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc.pc, arc.r);\n    let ip_tmp = $2c7a62d6ab88e4d3$var$intersectLine2Circle(line, circle);\n    for (let pt of ip_tmp)if (pt.on(arc)) ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectSegment2Line(seg, line) {\n    let ip = [];\n    // Boundary cases\n    if (seg.ps.on(line)) ip.push(seg.ps);\n    // If both ends lay on line, return two intersection points\n    if (seg.pe.on(line) && !seg.isZeroLength()) ip.push(seg.pe);\n    if (ip.length > 0) return ip; // done, intersection found\n    // If zero-length segment and nothing found, return no intersections\n    if (seg.isZeroLength()) return ip;\n    // Not a boundary case, check if both points are on the same side and\n    // hence there is no intersection\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) || !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) return ip;\n    // Calculate intersection between lines\n    let line1 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(seg.ps, seg.pe);\n    return $2c7a62d6ab88e4d3$var$intersectLine2Line(line1, line);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectSegment2Segment(seg1, seg2) {\n    let ip = [];\n    // quick reject\n    if (seg1.box.not_intersect(seg2.box)) return ip;\n    // Special case of seg1 zero length\n    if (seg1.isZeroLength()) {\n        if (seg1.ps.on(seg2)) ip.push(seg1.ps);\n        return ip;\n    }\n    // Special case of seg2 zero length\n    if (seg2.isZeroLength()) {\n        if (seg2.ps.on(seg1)) ip.push(seg2.ps);\n        return ip;\n    }\n    // Neither seg1 nor seg2 is zero length\n    let line1 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(seg1.ps, seg1.pe);\n    let line2 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(seg2.ps, seg2.pe);\n    // Check overlapping between segments in case of incidence\n    // If segments touching, add one point. If overlapping, add two points\n    if (line1.incidentTo(line2)) {\n        if (seg1.ps.on(seg2)) ip.push(seg1.ps);\n        if (seg1.pe.on(seg2)) ip.push(seg1.pe);\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) ip.push(seg2.ps);\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) ip.push(seg2.pe);\n    } else {\n        // Calculate intersection between lines\n        let new_ip = $2c7a62d6ab88e4d3$var$intersectLine2Line(line1, line2);\n        if (new_ip.length > 0) {\n            if ($2c7a62d6ab88e4d3$var$isPointInSegmentBox(new_ip[0], seg1) && $2c7a62d6ab88e4d3$var$isPointInSegmentBox(new_ip[0], seg2)) ip.push(new_ip[0]);\n        }\n    }\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$isPointInSegmentBox(point, segment) {\n    const box = segment.box;\n    return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(point.x, box.xmax) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(point.x, box.xmin) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(point.y, box.ymax) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(point.y, box.ymin);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectSegment2Circle(segment, circle) {\n    let ips = [];\n    if (segment.box.not_intersect(circle.box)) return ips;\n    // Special case of zero length segment\n    if (segment.isZeroLength()) {\n        let [dist, _] = segment.ps.distanceTo(circle.pc);\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(dist, circle.r)) ips.push(segment.ps);\n        return ips;\n    }\n    // Non zero-length segment\n    let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(segment.ps, segment.pe);\n    let ips_tmp = $2c7a62d6ab88e4d3$var$intersectLine2Circle(line, circle);\n    for (let ip of ips_tmp)if (ip.on(segment)) ips.push(ip);\n    return ips;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectSegment2Arc(segment, arc) {\n    let ip = [];\n    if (segment.box.not_intersect(arc.box)) return ip;\n    // Special case of zero-length segment\n    if (segment.isZeroLength()) {\n        if (segment.ps.on(arc)) ip.push(segment.ps);\n        return ip;\n    }\n    // Non-zero length segment\n    let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(segment.ps, segment.pe);\n    let circle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc.pc, arc.r);\n    let ip_tmp = $2c7a62d6ab88e4d3$var$intersectLine2Circle(line, circle);\n    for (let pt of ip_tmp)if (pt.on(segment) && pt.on(arc)) ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectSegment2Box(segment, box) {\n    let ips = [];\n    for (let seg of box.toSegments()){\n        let ips_tmp = $2c7a62d6ab88e4d3$var$intersectSegment2Segment(seg, segment);\n        for (let ip of ips_tmp)ips.push(ip);\n    }\n    return ips;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectCircle2Circle(circle1, circle2) {\n    let ip = [];\n    if (circle1.box.not_intersect(circle2.box)) return ip;\n    let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(circle1.pc, circle2.pc);\n    let r1 = circle1.r;\n    let r2 = circle2.r;\n    // Degenerated circle\n    if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(r1) || $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(r2)) return ip;\n    // In case of equal circles return one leftmost point\n    if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(vec.x) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(vec.y) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(r1, r2)) {\n        ip.push(circle1.pc.translate(-r1, 0));\n        return ip;\n    }\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\n    if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GT(dist, r1 + r2)) return ip;\n    if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist, Math.abs(r1 - r2))) return ip;\n    // Normalize vector.\n    vec.x /= dist;\n    vec.y /= dist;\n    let pt;\n    // Case of touching from outside or from inside - single intersection point\n    // TODO: check this specifically not sure if correct\n    if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(dist, r1 + r2) || $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(dist, Math.abs(r1 - r2))) {\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\n        ip.push(pt);\n        return ip;\n    }\n    // Case of two intersection points\n    // Distance from first center to center of common chord:\n    //   a = (r1^2 - r2^2 + d^2) / 2d\n    // Separate for better accuracy\n    let a = r1 * r1 / (2 * dist) - r2 * r2 / (2 * dist) + dist / 2;\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\n    let h = Math.sqrt(r1 * r1 - a * a);\n    // let norm;\n    // norm = vec.rotate90CCW().multiply(h);\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n    ip.push(pt);\n    // norm = vec.rotate90CW();\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n    ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectCircle2Box(circle, box) {\n    let ips = [];\n    for (let seg of box.toSegments()){\n        let ips_tmp = $2c7a62d6ab88e4d3$var$intersectSegment2Circle(seg, circle);\n        for (let ip of ips_tmp)ips.push(ip);\n    }\n    return ips;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectArc2Arc(arc1, arc2) {\n    let ip = [];\n    if (arc1.box.not_intersect(arc2.box)) return ip;\n    // Special case: overlapping arcs\n    // May return up to 4 intersection points\n    if (arc1.pc.equalTo(arc2.pc) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(arc1.r, arc2.r)) {\n        let pt;\n        pt = arc1.start;\n        if (pt.on(arc2)) ip.push(pt);\n        pt = arc1.end;\n        if (pt.on(arc2)) ip.push(pt);\n        pt = arc2.start;\n        if (pt.on(arc1)) ip.push(pt);\n        pt = arc2.end;\n        if (pt.on(arc1)) ip.push(pt);\n        return ip;\n    }\n    // Common case\n    let circle1 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc1.pc, arc1.r);\n    let circle2 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc2.pc, arc2.r);\n    let ip_tmp = circle1.intersect(circle2);\n    for (let pt of ip_tmp)if (pt.on(arc1) && pt.on(arc2)) ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectArc2Circle(arc, circle) {\n    let ip = [];\n    if (arc.box.not_intersect(circle.box)) return ip;\n    // Case when arc center incident to circle center\n    // Return arc's end points as 2 intersection points\n    if (circle.pc.equalTo(arc.pc) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(circle.r, arc.r)) {\n        ip.push(arc.start);\n        ip.push(arc.end);\n        return ip;\n    }\n    // Common case\n    let circle1 = circle;\n    let circle2 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc.pc, arc.r);\n    let ip_tmp = $2c7a62d6ab88e4d3$var$intersectCircle2Circle(circle1, circle2);\n    for (let pt of ip_tmp)if (pt.on(arc)) ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectArc2Box(arc, box) {\n    let ips = [];\n    for (let seg of box.toSegments()){\n        let ips_tmp = $2c7a62d6ab88e4d3$var$intersectSegment2Arc(seg, arc);\n        for (let ip of ips_tmp)ips.push(ip);\n    }\n    return ips;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectEdge2Segment(edge, segment) {\n    return edge.isSegment ? $2c7a62d6ab88e4d3$var$intersectSegment2Segment(edge.shape, segment) : $2c7a62d6ab88e4d3$var$intersectSegment2Arc(segment, edge.shape);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectEdge2Arc(edge, arc) {\n    return edge.isSegment ? $2c7a62d6ab88e4d3$var$intersectSegment2Arc(edge.shape, arc) : $2c7a62d6ab88e4d3$var$intersectArc2Arc(edge.shape, arc);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectEdge2Line(edge, line) {\n    return edge.isSegment ? $2c7a62d6ab88e4d3$var$intersectSegment2Line(edge.shape, line) : $2c7a62d6ab88e4d3$var$intersectLine2Arc(line, edge.shape);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectEdge2Ray(edge, ray) {\n    return edge.isSegment ? $2c7a62d6ab88e4d3$var$intersectRay2Segment(ray, edge.shape) : $2c7a62d6ab88e4d3$var$intersectRay2Arc(ray, edge.shape);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectEdge2Circle(edge, circle) {\n    return edge.isSegment ? $2c7a62d6ab88e4d3$var$intersectSegment2Circle(edge.shape, circle) : $2c7a62d6ab88e4d3$var$intersectArc2Circle(edge.shape, circle);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectSegment2Polygon(segment, polygon) {\n    let ip = [];\n    for (let edge of polygon.edges)for (let pt of $2c7a62d6ab88e4d3$var$intersectEdge2Segment(edge, segment))ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectArc2Polygon(arc, polygon) {\n    let ip = [];\n    for (let edge of polygon.edges)for (let pt of $2c7a62d6ab88e4d3$var$intersectEdge2Arc(edge, arc))ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectLine2Polygon(line, polygon) {\n    let ip = [];\n    if (polygon.isEmpty()) return ip;\n    for (let edge of polygon.edges){\n        for (let pt of $2c7a62d6ab88e4d3$var$intersectEdge2Line(edge, line))if (!$2c7a62d6ab88e4d3$var$ptInIntPoints(pt, ip)) ip.push(pt);\n    }\n    return line.sortPoints(ip);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectCircle2Polygon(circle, polygon) {\n    let ip = [];\n    if (polygon.isEmpty()) return ip;\n    for (let edge of polygon.edges)for (let pt of $2c7a62d6ab88e4d3$var$intersectEdge2Circle(edge, circle))ip.push(pt);\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectEdge2Edge(edge1, edge2) {\n    if (edge1.isSegment) return $2c7a62d6ab88e4d3$var$intersectEdge2Segment(edge2, edge1.shape);\n    else if (edge1.isArc) return $2c7a62d6ab88e4d3$var$intersectEdge2Arc(edge2, edge1.shape);\n    else if (edge1.isLine) return $2c7a62d6ab88e4d3$var$intersectEdge2Line(edge2, edge1.shape);\n    else if (edge1.isRay) return $2c7a62d6ab88e4d3$var$intersectEdge2Ray(edge2, edge1.shape);\n    return [];\n}\nfunction $2c7a62d6ab88e4d3$var$intersectEdge2Polygon(edge, polygon) {\n    let ip = [];\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) return ip;\n    let resp_edges = polygon.edges.search(edge.shape.box);\n    for (let resp_edge of resp_edges)ip = [\n        ...ip,\n        ...$2c7a62d6ab88e4d3$var$intersectEdge2Edge(edge, resp_edge)\n    ];\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectPolygon2Polygon(polygon1, polygon2) {\n    let ip = [];\n    if (polygon1.isEmpty() || polygon2.isEmpty()) return ip;\n    if (polygon1.box.not_intersect(polygon2.box)) return ip;\n    for (let edge1 of polygon1.edges)ip = [\n        ...ip,\n        ...$2c7a62d6ab88e4d3$var$intersectEdge2Polygon(edge1, polygon2)\n    ];\n    return ip;\n}\nfunction $2c7a62d6ab88e4d3$var$intersectShape2Polygon(shape, polygon) {\n    if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$intersectLine2Polygon(shape, polygon);\n    else if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$var$intersectSegment2Polygon(shape, polygon);\n    else if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$var$intersectArc2Polygon(shape, polygon);\n    else return [];\n}\nfunction $2c7a62d6ab88e4d3$var$ptInIntPoints(new_pt, ip) {\n    return ip.some((pt)=>pt.equalTo(new_pt));\n}\nfunction $2c7a62d6ab88e4d3$var$createLineFromRay(ray) {\n    return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(ray.start, ray.norm);\n}\nfunction $2c7a62d6ab88e4d3$var$intersectRay2Segment(ray, segment) {\n    return $2c7a62d6ab88e4d3$var$intersectSegment2Line(segment, $2c7a62d6ab88e4d3$var$createLineFromRay(ray)).filter((pt)=>ray.contains(pt));\n}\nfunction $2c7a62d6ab88e4d3$var$intersectRay2Arc(ray, arc) {\n    return $2c7a62d6ab88e4d3$var$intersectLine2Arc($2c7a62d6ab88e4d3$var$createLineFromRay(ray), arc).filter((pt)=>ray.contains(pt));\n}\nfunction $2c7a62d6ab88e4d3$var$intersectRay2Circle(ray, circle) {\n    return $2c7a62d6ab88e4d3$var$intersectLine2Circle($2c7a62d6ab88e4d3$var$createLineFromRay(ray), circle).filter((pt)=>ray.contains(pt));\n}\nfunction $2c7a62d6ab88e4d3$var$intersectRay2Box(ray, box) {\n    return $2c7a62d6ab88e4d3$var$intersectLine2Box($2c7a62d6ab88e4d3$var$createLineFromRay(ray), box).filter((pt)=>ray.contains(pt));\n}\nfunction $2c7a62d6ab88e4d3$var$intersectRay2Line(ray, line) {\n    return $2c7a62d6ab88e4d3$var$intersectLine2Line($2c7a62d6ab88e4d3$var$createLineFromRay(ray), line).filter((pt)=>ray.contains(pt));\n}\nfunction $2c7a62d6ab88e4d3$var$intersectRay2Ray(ray1, ray2) {\n    return $2c7a62d6ab88e4d3$var$intersectLine2Line($2c7a62d6ab88e4d3$var$createLineFromRay(ray1), $2c7a62d6ab88e4d3$var$createLineFromRay(ray2)).filter((pt)=>ray1.contains(pt)).filter((pt)=>ray2.contains(pt));\n}\nfunction $2c7a62d6ab88e4d3$var$intersectRay2Polygon(ray, polygon) {\n    return $2c7a62d6ab88e4d3$var$intersectLine2Polygon($2c7a62d6ab88e4d3$var$createLineFromRay(ray), polygon).filter((pt)=>ray.contains(pt));\n}\n/**\n * @module RayShoot\n */ /**\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\n * @param {Polygon} polygon - polygon to test\n * @param {Point} point - point to test\n * @returns {INSIDE|OUTSIDE|BOUNDARY}\n */ function $2c7a62d6ab88e4d3$export$3adad403c78dc9b2(polygon, point) {\n    let contains = undefined;\n    // 1. Quick reject\n    // if (polygon.box.not_intersect(point.box)) {\n    //     return Flatten.OUTSIDE;\n    // }\n    let ray = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray(point);\n    let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(ray.pt, ray.norm);\n    // 2. Locate relevant edges of the polygon\n    const searchBox = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(ray.box.xmin - $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.DP_TOL, ray.box.ymin - $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.DP_TOL, ray.box.xmax, ray.box.ymax + $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.DP_TOL);\n    if (polygon.box.not_intersect(searchBox)) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE;\n    let resp_edges = polygon.edges.search(searchBox);\n    if (resp_edges.length === 0) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE;\n    // 2.5 Check if boundary\n    for (let edge of resp_edges){\n        if (edge.shape.contains(point)) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.BOUNDARY;\n    }\n    let faces = [\n        ...polygon.faces\n    ];\n    // 3. Calculate intersections\n    let intersections = [];\n    for (let edge of resp_edges)for (let ip of ray.intersect(edge.shape)){\n        // If intersection is equal to query point then point lays on boundary\n        if (ip.equalTo(point)) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.BOUNDARY;\n        intersections.push({\n            pt: ip,\n            edge: edge,\n            face_index: faces.indexOf(edge.face)\n        });\n    }\n    // 4. Sort intersection in x-ascending order\n    intersections.sort((i1, i2)=>{\n        if ($2c7a62d6ab88e4d3$var$LT(i1.pt.x, i2.pt.x)) return -1;\n        if ($2c7a62d6ab88e4d3$var$GT(i1.pt.x, i2.pt.x)) return 1;\n        if (i1.face_index < i2.face_index) return -1;\n        if (i1.face_index > i2.face_index) return 1;\n        if (i1.edge.arc_length < i2.edge.arc_length) return -1;\n        if (i1.edge.arc_length > i2.edge.arc_length) return 1;\n        return 0;\n    });\n    // 5. Count real intersections, exclude touching\n    let counter = 0;\n    for(let i = 0; i < intersections.length; i++){\n        let intersection = intersections[i];\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n            /* skip same point between same edges if already counted */ if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.face_index === intersections[i - 1].face_index && intersection.edge.prev === intersections[i - 1].edge) continue;\n            let prev_edge = intersection.edge.prev;\n            while($2c7a62d6ab88e4d3$var$EQ_0(prev_edge.length))prev_edge = prev_edge.prev;\n            let prev_tangent = prev_edge.shape.tangentInEnd();\n            let prev_point = intersection.pt.translate(prev_tangent);\n            let cur_tangent = intersection.edge.shape.tangentInStart();\n            let cur_point = intersection.pt.translate(cur_tangent);\n            let prev_on_the_left = prev_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n            if (prev_on_the_left && !cur_on_the_left || !prev_on_the_left && cur_on_the_left) counter++;\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n            /* skip same point between same edges if already counted */ if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) && intersection.face_index === intersections[i - 1].face_index && intersection.edge.next === intersections[i - 1].edge) continue;\n            let next_edge = intersection.edge.next;\n            while($2c7a62d6ab88e4d3$var$EQ_0(next_edge.length))next_edge = next_edge.next;\n            let next_tangent = next_edge.shape.tangentInStart();\n            let next_point = intersection.pt.translate(next_tangent);\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\n            let cur_point = intersection.pt.translate(cur_tangent);\n            let next_on_the_left = next_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n            if (next_on_the_left && !cur_on_the_left || !next_on_the_left && cur_on_the_left) counter++;\n        } else if (intersection.edge.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) counter++;\n        else {\n            /* Check if ray does not touch the curve in the extremal (top or bottom) point */ let box = intersection.edge.shape.box;\n            if (!($2c7a62d6ab88e4d3$var$EQ(intersection.pt.y, box.ymin) || $2c7a62d6ab88e4d3$var$EQ(intersection.pt.y, box.ymax))) counter++;\n        }\n    }\n    // 6. Odd or even?\n    contains = counter % 2 === 1 ? $2c7a62d6ab88e4d3$export$48ea0cac79c83ca8 : $2c7a62d6ab88e4d3$export$be7fee058d85725d;\n    return contains;\n}\n/*\n    Calculate relationship between two shapes and return result in the form of\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\n */ /**\n * Returns true if shapes are topologically equal:  their interiors intersect and\n * no part of the interior or boundary of one geometry intersects the exterior of the other\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$equal(shape1, shape2) {\n    return $2c7a62d6ab88e4d3$var$relate(shape1, shape2).equal();\n}\n/**\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$intersect(shape1, shape2) {\n    return $2c7a62d6ab88e4d3$var$relate(shape1, shape2).intersect();\n}\n/**\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$touch(shape1, shape2) {\n    return $2c7a62d6ab88e4d3$var$relate(shape1, shape2).touch();\n}\n/**\n * Returns true if shapes have no points in common neither in interior nor in boundary\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$disjoint(shape1, shape2) {\n    return !$2c7a62d6ab88e4d3$var$intersect(shape1, shape2);\n}\n/**\n * Returns true shape1 lies in the interior of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$inside(shape1, shape2) {\n    return $2c7a62d6ab88e4d3$var$relate(shape1, shape2).inside();\n}\n/**\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$covered(shape1, shape2) {\n    return $2c7a62d6ab88e4d3$var$relate(shape1, shape2).covered();\n}\n/**\n * Returns true shape1's interior contains shape2 <br/>\n * Same as inside(shape2, shape1)\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$contain(shape1, shape2) {\n    return $2c7a62d6ab88e4d3$var$inside(shape2, shape1);\n}\n/**\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$var$cover(shape1, shape2) {\n    return $2c7a62d6ab88e4d3$var$covered(shape2, shape1);\n}\n/**\n * Returns relation between two shapes as intersection 3x3 matrix, where each\n * element contains relevant intersection as array of shapes.\n * If there is no intersection, element contains empty array\n * If intersection is irrelevant it left undefined. (For example, intersection\n * between two exteriors is usually irrelevant)\n * @param shape1\n * @param shape2\n * @returns {DE9IM}\n */ function $2c7a62d6ab88e4d3$var$relate(shape1, shape2) {\n    if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$relateLine2Line(shape1, shape2);\n    else if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$var$relateLine2Circle(shape1, shape2);\n    else if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return $2c7a62d6ab88e4d3$var$relateLine2Box(shape1, shape2);\n    else if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$relateLine2Polygon(shape1, shape2);\n    else if ((shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment || shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$relateShape2Polygon(shape1, shape2);\n    else if ((shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment || shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) && (shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle || shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box)) return $2c7a62d6ab88e4d3$var$relateShape2Polygon(shape1, new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(shape2));\n    else if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$relatePolygon2Polygon(shape1, shape2);\n    else if ((shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle || shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) && (shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle || shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box)) return $2c7a62d6ab88e4d3$var$relatePolygon2Polygon(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(shape1), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(shape2));\n    else if ((shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle || shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$relatePolygon2Polygon(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(shape1), shape2);\n    else if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon && (shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle || shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box)) return $2c7a62d6ab88e4d3$var$relatePolygon2Polygon(shape1, new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(shape2));\n}\nfunction $2c7a62d6ab88e4d3$var$relateLine2Line(line1, line2) {\n    let denim = new $2c7a62d6ab88e4d3$var$DE9IM();\n    let ip = $2c7a62d6ab88e4d3$var$intersectLine2Line(line1, line2);\n    if (ip.length === 0) {\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\n            denim.I2I = [\n                line1\n            ]; // equal  'T.F...F..'  - no boundary\n            denim.I2E = [];\n            denim.E2I = [];\n        } else {\n            denim.I2I = [];\n            denim.I2E = [\n                line1\n            ];\n            denim.E2I = [\n                line2\n            ];\n        }\n    } else {\n        denim.I2I = ip;\n        denim.I2E = line1.split(ip);\n        denim.E2I = line2.split(ip);\n    }\n    return denim;\n}\nfunction $2c7a62d6ab88e4d3$var$relateLine2Circle(line, circle) {\n    let denim = new $2c7a62d6ab88e4d3$var$DE9IM();\n    let ip = $2c7a62d6ab88e4d3$var$intersectLine2Circle(line, circle);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [\n            line\n        ];\n        denim.E2I = [\n            circle\n        ];\n    } else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n        denim.E2I = [\n            circle\n        ];\n    } else {\n        let multiline = new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29([\n            line\n        ]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n        denim.I2I = [\n            splitShapes[1]\n        ];\n        denim.I2B = ip_sorted;\n        denim.I2E = [\n            splitShapes[0],\n            splitShapes[2]\n        ];\n        denim.E2I = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon([\n            circle.toArc()\n        ]).cutWithLine(line);\n    }\n    return denim;\n}\nfunction $2c7a62d6ab88e4d3$var$relateLine2Box(line, box) {\n    let denim = new $2c7a62d6ab88e4d3$var$DE9IM();\n    let ip = $2c7a62d6ab88e4d3$var$intersectLine2Box(line, box);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [\n            line\n        ];\n        denim.E2I = [\n            box\n        ];\n    } else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n        denim.E2I = [\n            box\n        ];\n    } else {\n        let multiline = new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29([\n            line\n        ]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n        /* Are two intersection points on the same segment of the box boundary ? */ if (box.toSegments().some((segment)=>segment.contains(ip[0]) && segment.contains(ip[1]))) {\n            denim.I2I = []; // case of touching\n            denim.I2B = [\n                splitShapes[1]\n            ];\n            denim.I2E = [\n                splitShapes[0],\n                splitShapes[2]\n            ];\n            denim.E2I = [\n                box\n            ];\n        } else {\n            denim.I2I = [\n                splitShapes[1]\n            ]; // [segment(ip[0], ip[1])];\n            denim.I2B = ip_sorted;\n            denim.I2E = [\n                splitShapes[0],\n                splitShapes[2]\n            ];\n            denim.E2I = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(box.toSegments()).cutWithLine(line);\n        }\n    }\n    return denim;\n}\nfunction $2c7a62d6ab88e4d3$var$relateLine2Polygon(line, polygon) {\n    let denim = new $2c7a62d6ab88e4d3$var$DE9IM();\n    let ip = $2c7a62d6ab88e4d3$var$intersectLine2Polygon(line, polygon);\n    let multiline = new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29([\n        line\n    ]);\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\n    multiline.split(ip_sorted);\n    [\n        ...multiline\n    ].forEach((edge)=>edge.setInclusion(polygon));\n    denim.I2I = [\n        ...multiline\n    ].filter((edge)=>edge.bv === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.INSIDE).map((edge)=>edge.shape);\n    denim.I2B = [\n        ...multiline\n    ].slice(1).map((edge)=>edge.bv === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.BOUNDARY ? edge.shape : edge.shape.start);\n    denim.I2E = [\n        ...multiline\n    ].filter((edge)=>edge.bv === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE).map((edge)=>edge.shape);\n    denim.E2I = polygon.cutWithLine(line);\n    return denim;\n}\nfunction $2c7a62d6ab88e4d3$var$relateShape2Polygon(shape, polygon) {\n    let denim = new $2c7a62d6ab88e4d3$var$DE9IM();\n    let ip = $2c7a62d6ab88e4d3$var$intersectShape2Polygon(shape, polygon);\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\n    let multiline = new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29([\n        shape\n    ]);\n    multiline.split(ip_sorted);\n    [\n        ...multiline\n    ].forEach((edge)=>edge.setInclusion(polygon));\n    denim.I2I = [\n        ...multiline\n    ].filter((edge)=>edge.bv === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.INSIDE).map((edge)=>edge.shape);\n    denim.I2B = [\n        ...multiline\n    ].slice(1).map((edge)=>edge.bv === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.BOUNDARY ? edge.shape : edge.shape.start);\n    denim.I2E = [\n        ...multiline\n    ].filter((edge)=>edge.bv === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE).map((edge)=>edge.shape);\n    denim.B2I = [];\n    denim.B2B = [];\n    denim.B2E = [];\n    for (let pt of [\n        shape.start,\n        shape.end\n    ])switch($2c7a62d6ab88e4d3$export$3adad403c78dc9b2(polygon, pt)){\n        case $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.INSIDE:\n            denim.B2I.push(pt);\n            break;\n        case $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.BOUNDARY:\n            denim.B2B.push(pt);\n            break;\n        case $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE:\n            denim.B2E.push(pt);\n            break;\n    }\n    // denim.E2I  TODO: calculate, not clear what is expected result\n    return denim;\n}\nfunction $2c7a62d6ab88e4d3$var$relatePolygon2Polygon(polygon1, polygon2) {\n    let denim = new $2c7a62d6ab88e4d3$var$DE9IM();\n    let [ip_sorted1, ip_sorted2] = $2c7a62d6ab88e4d3$var$calculateIntersections(polygon1, polygon2);\n    let boolean_intersection = $2c7a62d6ab88e4d3$var$intersect$1(polygon1, polygon2);\n    let boolean_difference1 = $2c7a62d6ab88e4d3$var$subtract(polygon1, polygon2);\n    let boolean_difference2 = $2c7a62d6ab88e4d3$var$subtract(polygon2, polygon1);\n    let [inner_clip_shapes1, inner_clip_shapes2] = $2c7a62d6ab88e4d3$var$innerClip(polygon1, polygon2);\n    let outer_clip_shapes1 = $2c7a62d6ab88e4d3$var$outerClip(polygon1, polygon2);\n    let outer_clip_shapes2 = $2c7a62d6ab88e4d3$var$outerClip(polygon2, polygon1);\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [\n        boolean_intersection\n    ];\n    denim.I2B = inner_clip_shapes2;\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [\n        boolean_difference1\n    ];\n    denim.B2I = inner_clip_shapes1;\n    denim.B2B = ip_sorted1;\n    denim.B2E = outer_clip_shapes1;\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [\n        boolean_difference2\n    ];\n    denim.E2B = outer_clip_shapes2;\n    // denim.E2E    not relevant meanwhile\n    return denim;\n}\nvar $2c7a62d6ab88e4d3$export$932c2897ef8e4e8e = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    contain: $2c7a62d6ab88e4d3$var$contain,\n    cover: $2c7a62d6ab88e4d3$var$cover,\n    covered: $2c7a62d6ab88e4d3$var$covered,\n    disjoint: $2c7a62d6ab88e4d3$var$disjoint,\n    equal: $2c7a62d6ab88e4d3$var$equal,\n    inside: $2c7a62d6ab88e4d3$var$inside,\n    intersect: $2c7a62d6ab88e4d3$var$intersect,\n    relate: $2c7a62d6ab88e4d3$var$relate,\n    touch: $2c7a62d6ab88e4d3$var$touch\n});\n/**\n * Class representing an affine transformation 3x3 matrix:\n * <pre>\n *      [ a  c  tx\n * A =    b  d  ty\n *        0  0  1  ]\n * </pre\n * @type {Matrix}\n */ class $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85 {\n    /**\n     * Construct new instance of affine transformation matrix <br/>\n     * If parameters omitted, construct identity matrix a = 1, d = 1\n     * @param {number} a - position(0,0)   sx*cos(alpha)\n     * @param {number} b - position (0,1)  sx*sin(alpha)\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\n     * @param {number} d - position (1,1)  sy*cos(alpha)\n     * @param {number} tx - position (2,0) translation by x\n     * @param {number} ty - position (2,1) translation by y\n     */ constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0){\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n    /**\n     * Return new cloned instance of matrix\n     * @return {Matrix}\n     **/ clone() {\n        return new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85(this.a, this.b, this.c, this.d, this.tx, this.ty);\n    }\n    /**\n     * Transform vector [x,y] using transformation matrix. <br/>\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\n     * <code>\n     * [x'       [ ax + by + tx\n     *  y'   =     cx + dy + ty\n     *  1]                    1 ]\n     * </code>\n     * @param {number[]} vector - array[2] of numbers\n     * @returns {number[]} transformation result - array[2] of numbers\n     */ transform(vector) {\n        return [\n            vector[0] * this.a + vector[1] * this.c + this.tx,\n            vector[0] * this.b + vector[1] * this.d + this.ty\n        ];\n    }\n    /**\n     * Returns result of multiplication of this matrix by other matrix\n     * @param {Matrix} other_matrix - matrix to multiply by\n     * @returns {Matrix}\n     */ multiply(other_matrix) {\n        return new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85(this.a * other_matrix.a + this.c * other_matrix.b, this.b * other_matrix.a + this.d * other_matrix.b, this.a * other_matrix.c + this.c * other_matrix.d, this.b * other_matrix.c + this.d * other_matrix.d, this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx, this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty);\n    }\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix(1,0,0,1,tx,ty)\n     * @param {Vector} vector - Translation by vector or\n     * @param {number} tx - translation by x-axis\n     * @param {number} ty - translation by y-axis\n     * @returns {Matrix}\n     */ translate(...args) {\n        let tx, ty;\n        if (args.length == 1 && !isNaN(args[0].x) && !isNaN(args[0].y)) {\n            tx = args[0].x;\n            ty = args[0].y;\n        } else if (args.length === 2 && typeof args[0] == \"number\" && typeof args[1] == \"number\") {\n            tx = args[0];\n            ty = args[1];\n        } else throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n        return this.multiply(new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85(1, 0, 0, 1, tx, ty));\n    }\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix that defines rotation by given angle (in radians) around\n     * center of rotation (centerX,centerY) in counterclockwise direction\n     * @param {number} angle - angle in radians\n     * @param {number} centerX - center of rotation\n     * @param {number} centerY - center of rotation\n     * @returns {Matrix}\n     */ rotate(angle, centerX = 0.0, centerY = 0.0) {\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        return this.translate(centerX, centerY).multiply(new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85(cos, sin, -sin, cos, 0, 0)).translate(-centerX, -centerY);\n    }\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Matrix}\n     */ scale(sx, sy) {\n        return this.multiply(new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85(sx, 0, 0, sy, 0, 0));\n    }\n    /**\n     * Returns true if two matrix are equal parameter by parameter\n     * @param {Matrix} matrix - other matrix\n     * @returns {boolean} true if equal, false otherwise\n     */ equalTo(matrix) {\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.tx, matrix.tx)) return false;\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.ty, matrix.ty)) return false;\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.a, matrix.a)) return false;\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.b, matrix.b)) return false;\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.c, matrix.c)) return false;\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.d, matrix.d)) return false;\n        return true;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix = $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85;\n/**\n * Function to create matrix equivalent to \"new\" constructor\n * @param args\n */ const $2c7a62d6ab88e4d3$export$9bdad1ae37d738e0 = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.matrix = $2c7a62d6ab88e4d3$export$9bdad1ae37d738e0;\n/**\n * Created by Alex Bol on 4/1/2017.\n */ /**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */ const $2c7a62d6ab88e4d3$var$Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */ constructor(low, high){\n        this.low = low;\n        this.high = high;\n    }\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */ clone() {\n        return new Interval(this.low, this.high);\n    }\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */ get max() {\n        return this.clone(); // this.high;\n    }\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */ less_than(other_interval) {\n        return this.low < other_interval.low || this.low == other_interval.low && this.high < other_interval.high;\n    }\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */ equal_to(other_interval) {\n        return this.low == other_interval.low && this.high == other_interval.high;\n    }\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */ intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */ not_intersect(other_interval) {\n        return this.high < other_interval.low || other_interval.high < this.low;\n    }\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} interval - Other interval to merge with\n     * @returns {Interval}\n     */ merge(other_interval) {\n        return new Interval(this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low), this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high));\n    }\n    /**\n     * Returns how key should return\n     */ output() {\n        return [\n            this.low,\n            this.high\n        ];\n    }\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */ static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */ static comparable_less_than(val1, val2) {\n        return val1 < val2;\n    }\n};\n/**\n * Created by Alex Bol on 3/28/2017.\n */ // module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\nconst $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED = 0;\nconst $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK = 1;\n/**\n * Created by Alex Bol on 4/1/2017.\n */ class $2c7a62d6ab88e4d3$var$Node {\n    constructor(key, value, left = null, right = null, parent = null, color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK){\n        this.left = left; // reference to left child node\n        this.right = right; // reference to right child node\n        this.parent = parent; // reference to parent node\n        this.color = color;\n        this.item = {\n            key: key,\n            value: value\n        }; // key is supposed to be instance of Interval\n        /* If not, this should by an array of two numbers */ if (key && key instanceof Array && key.length == 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) this.item.key = new $2c7a62d6ab88e4d3$var$Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n        }\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n    isNil() {\n        return this.item.key === undefined && this.item.value === undefined && this.left === null && this.right === null && this.color === $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n    }\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) : this.item.value < other_node.item.value;\n    }\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) return this.item.key.less_than(other_node.item.key);\n        else return this.item.key.less_than(other_node.item.key) || this.item.key.equal_to(other_node.item.key) && this._value_less_than(other_node);\n    }\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) : this.item.value == other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) return this.item.key.equal_to(other_node.item.key);\n        else return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n    }\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max; // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max; // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than; // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than; // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n/**\n * Created by Alex Bol on 3/31/2017.\n */ // const nil_node = new Node();\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */ class $2c7a62d6ab88e4d3$var$IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */ constructor(){\n        this.root = null;\n        this.nil_node = new $2c7a62d6ab88e4d3$var$Node();\n    }\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */ get size() {\n        let count = 0;\n        this.tree_walk(this.root, ()=>count++);\n        return count;\n    }\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */ get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node)=>res.push(node.item.key.output ? node.item.key.output() : node.item.key));\n        return res;\n    }\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */ get values() {\n        let res = [];\n        this.tree_walk(this.root, (node)=>res.push(node.item.value));\n        return res;\n    }\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */ get items() {\n        let res = [];\n        this.tree_walk(this.root, (node)=>res.push({\n                key: node.item.key.output ? node.item.key.output() : node.item.key,\n                value: node.item.value\n            }));\n        return res;\n    }\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */ isEmpty() {\n        return this.root == null || this.root == this.nil_node;\n    }\n    /**\n     * Clear tree\n     */ clear() {\n        this.root = null;\n    }\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */ insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new $2c7a62d6ab88e4d3$var$Node(key, value, this.nil_node, this.nil_node, null, $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */ exist(key, value = key) {\n        let search_node = new $2c7a62d6ab88e4d3$var$Node(key, value);\n        return this.tree_search(this.root, search_node) ? true : false;\n    }\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */ remove(key, value = key) {\n        let search_node = new $2c7a62d6ab88e4d3$var$Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) this.tree_delete(delete_node);\n        return delete_node;\n    }\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */ search(interval, outputMapperFn = (value, key)=>value === key ? key.output() : value) {\n        let search_node = new $2c7a62d6ab88e4d3$var$Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map((node)=>outputMapperFn(node.item.value, node.item.key));\n    }\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */ intersect_any(interval) {\n        let search_node = new $2c7a62d6ab88e4d3$var$Node(interval);\n        let found = this.tree_find_any_interval(this.root, search_node);\n        return found;\n    }\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */ forEach(visitor) {\n        this.tree_walk(this.root, (node)=>visitor(node.item.key, node.item.value));\n    }\n    /** Value Mapper. Walk through every node and map node value to another value\n    * @param callback(value,key) - function to be called for each tree item\n    */ map(callback) {\n        const tree = new $2c7a62d6ab88e4d3$var$IntervalTree();\n        this.tree_walk(this.root, (node)=>tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n    recalc_max(node) {\n        let node_current = node;\n        while(node_current.parent != null){\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n        if (this.root == null || this.root == this.nil_node) this.root = insert_node;\n        else {\n            while(current_node != this.nil_node){\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) current_node = current_node.left;\n                else current_node = current_node.right;\n            }\n            insert_node.parent = parent_node;\n            if (insert_node.less_than(parent_node)) parent_node.left = insert_node;\n            else parent_node.right = insert_node;\n        }\n        this.insert_fixup(insert_node);\n    }\n    // After insertion insert_node may have red-colored parent, and this is a single possible violation\n    // Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n        current_node = insert_node;\n        while(current_node != this.root && current_node.parent.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED)if (current_node.parent == current_node.parent.parent.left) {\n            uncle_node = current_node.parent.parent.right; // right brother of parent\n            if (uncle_node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED) {\n                // re-color father and uncle into black\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                uncle_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                current_node.parent.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED;\n                current_node = current_node.parent.parent;\n            } else {\n                if (current_node == current_node.parent.right) {\n                    // This case is transformed into Case 3.\n                    current_node = current_node.parent;\n                    this.rotate_left(current_node);\n                }\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK; // Case 3. Current is left child.\n                // Re-color father and grandfather, rotate grandfather right\n                current_node.parent.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED;\n                this.rotate_right(current_node.parent.parent);\n            }\n        } else {\n            uncle_node = current_node.parent.parent.left; // left brother of parent\n            if (uncle_node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED) {\n                // re-color father and uncle into black\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                uncle_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                current_node.parent.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED;\n                current_node = current_node.parent.parent;\n            } else {\n                if (current_node == current_node.parent.left) {\n                    // Transform into case 6\n                    current_node = current_node.parent;\n                    this.rotate_right(current_node);\n                }\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK; // Case 6. Current is right child.\n                // Re-color father and grandfather, rotate grandfather left\n                current_node.parent.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED;\n                this.rotate_left(current_node.parent.parent);\n            }\n        }\n        this.root.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n    }\n    tree_delete(delete_node) {\n        let cut_node; // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node; // node to fix rb tree property   (\"x\" from 14.4)\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) cut_node = delete_node;\n        else cut_node = this.tree_successor(delete_node);\n        // fix_node if single child of cut_node\n        if (cut_node.left != this.nil_node) fix_node = cut_node.left;\n        else fix_node = cut_node.right;\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/ fix_node.parent = cut_node.parent;\n        /*}*/ if (cut_node == this.root) this.root = fix_node;\n        else {\n            if (cut_node == cut_node.parent.left) cut_node.parent.left = fix_node;\n            else cut_node.parent.right = fix_node;\n            cut_node.parent.update_max(); // update max property of the parent\n        }\n        this.recalc_max(fix_node); // update max property upward from fix_node to root\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node != delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max(); // update max property of the cut node at the new place\n            this.recalc_max(delete_node); // update max property upward from delete_node to root\n        }\n        if (/*fix_node != this.nil_node && */ cut_node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK) this.delete_fixup(fix_node);\n    }\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n        while(current_node != this.root && current_node.parent != null && current_node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK)if (current_node == current_node.parent.left) {\n            brother_node = current_node.parent.right;\n            if (brother_node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED) {\n                brother_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK; // re-color brother\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED; // re-color father\n                this.rotate_left(current_node.parent);\n                brother_node = current_node.parent.right; // update brother\n            }\n            // Derive to cases 2..4: brother is black\n            if (brother_node.left.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK && brother_node.right.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK) {\n                brother_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED; // re-color brother\n                current_node = current_node.parent; // continue iteration\n            } else {\n                if (brother_node.right.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK) {\n                    brother_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED; // re-color brother\n                    brother_node.left.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK; // re-color nephew\n                    this.rotate_right(brother_node);\n                    brother_node = current_node.parent.right; // update brother\n                // Derive to case 4: left nephew black, right nephew red\n                }\n                // case 4: left nephew black, right nephew red\n                brother_node.color = current_node.parent.color;\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                brother_node.right.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                this.rotate_left(current_node.parent);\n                current_node = this.root; // exit from loop\n            }\n        } else {\n            brother_node = current_node.parent.left;\n            if (brother_node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED) {\n                brother_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK; // re-color brother\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED; // re-color father\n                this.rotate_right(current_node.parent);\n                brother_node = current_node.parent.left; // update brother\n            }\n            // Go to cases 2..4\n            if (brother_node.left.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK && brother_node.right.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK) {\n                brother_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED; // re-color brother\n                current_node = current_node.parent; // continue iteration\n            } else {\n                if (brother_node.left.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK) {\n                    brother_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED; // re-color brother\n                    brother_node.right.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK; // re-color nephew\n                    this.rotate_left(brother_node);\n                    brother_node = current_node.parent.left; // update brother\n                // Derive to case 4: right nephew black, left nephew red\n                }\n                // case 4: right nephew black, left nephew red\n                brother_node.color = current_node.parent.color;\n                current_node.parent.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                brother_node.left.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n                this.rotate_right(current_node.parent);\n                current_node = this.root; // force exit from loop\n            }\n        }\n        current_node.color = $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK;\n    }\n    tree_search(node, search_node) {\n        if (node == null || node == this.nil_node) return undefined;\n        if (search_node.equal_to(node)) return node;\n        if (search_node.less_than(node)) return this.tree_search(node.left, search_node);\n        else return this.tree_search(node.right, search_node);\n    }\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) this.tree_search_interval(node.left, search_node, res);\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) res.push(node);\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) this.tree_search_interval(node.right, search_node, res);\n        }\n    }\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) found = this.tree_find_any_interval(node.left, search_node);\n            // if (low <= node->high && node->low <= high) {\n            if (!found) found = node.intersect(search_node);\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) found = this.tree_find_any_interval(node.right, search_node);\n        }\n        return found;\n    }\n    local_minimum(node) {\n        let node_min = node;\n        while(node_min.left != null && node_min.left != this.nil_node)node_min = node_min.left;\n        return node_min;\n    }\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while(node_max.right != null && node_max.right != this.nil_node)node_max = node_max.right;\n        return node_max;\n    }\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n        if (node.right != this.nil_node) node_successor = this.local_minimum(node.right);\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while(parent_node != null && parent_node.right == current_node){\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n    rotate_left(x) {\n        let y = x.right;\n        x.right = y.left; // b goes to x.right\n        if (y.left != this.nil_node) y.left.parent = x; // x becomes parent of b\n        y.parent = x.parent; // move parent\n        if (x == this.root) this.root = y; // y becomes root\n        else if (x == x.parent.left) x.parent.left = y;\n        else x.parent.right = y;\n        y.left = x; // x becomes left child of y\n        x.parent = y; // and y becomes parent of x\n        if (x != null && x != this.nil_node) x.update_max();\n        y = x.parent;\n        if (y != null && y != this.nil_node) y.update_max();\n    }\n    rotate_right(y) {\n        let x = y.left;\n        y.left = x.right; // b goes to y.left\n        if (x.right != this.nil_node) x.right.parent = y; // y becomes parent of b\n        x.parent = y.parent; // move parent\n        if (y == this.root) this.root = x;\n        else if (y == y.parent.left) y.parent.left = x;\n        else y.parent.right = x;\n        x.right = y; // y becomes right child of x\n        y.parent = x; // and x becomes parent of y\n        if (y != null && y != this.nil_node) y.update_max();\n        x = y.parent;\n        if (x != null && x != this.nil_node) x.update_max();\n    }\n    tree_walk(node, action) {\n        if (node != null && node != this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n    /* Return true if all red nodes have exactly two black child nodes */ testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function(node) {\n            if (node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_RED) {\n                if (!(node.left.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK && node.right.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK)) res = false;\n            }\n        });\n        return res;\n    }\n    /* Throw error if not every path from root to bottom has same black height */ testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color == $2c7a62d6ab88e4d3$var$RB_TREE_COLOR_BLACK) height++;\n        if (node.left != this.nil_node) heightLeft = this.testBlackHeightProperty(node.left);\n        else heightLeft = 1;\n        if (node.right != this.nil_node) heightRight = this.testBlackHeightProperty(node.right);\n        else heightRight = 1;\n        if (heightLeft != heightRight) throw new Error(\"Red-black height property violated\");\n        height += heightLeft;\n        return height;\n    }\n}\n/**\n * Created by Alex Bol on 3/12/2017.\n */ /**\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\n * perform spatial queries. Planar set is an extension of Set container, so it supports\n * Set properties and methods\n */ class $2c7a62d6ab88e4d3$export$bfc59922c63341df extends Set {\n    /**\n     * Create new instance of PlanarSet\n     * @param shapes - array or set of geometric objects to store in planar set\n     * Each object should have a <b>box</b> property\n     */ constructor(shapes){\n        super(shapes);\n        this.index = new $2c7a62d6ab88e4d3$var$IntervalTree();\n        this.forEach((shape)=>this.index.insert(shape));\n    }\n    /**\n     * Add new shape to planar set and to its spatial index.<br/>\n     * If shape already exist, it will not be added again.\n     * This happens with no error, it is possible to use <i>size</i> property to check if\n     * a shape was actually added.<br/>\n     * Method returns planar set object updated and may be chained\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be added, should have valid <i>box</i> property\n     * Another option to transfer as an object {key: Box, value: AnyShape}\n     * @returns {PlanarSet}\n     */ add(entry) {\n        let size = this.size;\n        const { key: key, value: value } = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        super.add(shape);\n        // size not changed - item not added, probably trying to add same item twice\n        if (this.size > size) this.index.insert(box, shape);\n        return this; // in accordance to Set.add interface\n    }\n    /**\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be deleted\n     * @returns {boolean}\n     */ delete(entry) {\n        const { key: key, value: value } = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        let deleted = super.delete(shape);\n        if (deleted) this.index.remove(box, shape);\n        return deleted;\n    }\n    /**\n     * Clear planar set\n     */ clear() {\n        super.clear();\n        this.index = new $2c7a62d6ab88e4d3$var$IntervalTree();\n    }\n    /**\n     * 2d range search in planar set.<br/>\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\n     * @param {Box} box - query box\n     * @returns {AnyShape[]}\n     */ search(box) {\n        let resp = this.index.search(box);\n        return resp;\n    }\n    /**\n     * Point location test. Returns array of shapes which contains given point\n     * @param {Point} point - query point\n     * @returns {AnyShape[]}\n     */ hit(point) {\n        let box = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n        let resp = this.index.search(box);\n        return resp.filter((shape)=>point.on(shape));\n    }\n    /**\n     * Returns svg string to draw all shapes in planar set\n     * @returns {String}\n     */ svg() {\n        let svgcontent = [\n            ...this\n        ].reduce((acc, shape)=>acc + shape.svg(), \"\");\n        return svgcontent;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet = $2c7a62d6ab88e4d3$export$bfc59922c63341df;\n/**\n * Base class representing shape\n * Implement common methods of affine transformations\n */ class $2c7a62d6ab88e4d3$var$Shape {\n    get name() {\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.CANNOT_INVOKE_ABSTRACT_METHOD;\n    }\n    get box() {\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.CANNOT_INVOKE_ABSTRACT_METHOD;\n    }\n    clone() {\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.CANNOT_INVOKE_ABSTRACT_METHOD;\n    }\n    /**\n     * Returns new shape translated by given vector.\n     * Translation vector may be also defined by a pair of numbers.\n     * @param {Vector | (number, number) } args - Translation vector\n     * or tuple of numbers\n     * @returns {Shape}\n     */ translate(...args) {\n        return this.transform(new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85().translate(...args));\n    }\n    /**\n     * Returns new shape rotated by given angle around given center point.\n     * If center point is omitted, rotates around zero point (0,0).\n     * Positive value of angle defines rotation in counterclockwise direction,\n     * negative angle defines rotation in clockwise direction\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     * @returns {Shape}\n     */ rotate(angle, center = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point()) {\n        return this.transform(new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85().rotate(angle, center.x, center.y));\n    }\n    /**\n     * Return new shape with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Shape}\n     */ scale(sx, sy) {\n        return this.transform(new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85().scale(sx, sy));\n    }\n    transform(...args) {\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.CANNOT_INVOKE_ABSTRACT_METHOD;\n    }\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */ toJSON() {\n        return Object.assign({}, this, {\n            name: this.name\n        });\n    }\n    svg(attrs = {}) {\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.CANNOT_INVOKE_ABSTRACT_METHOD;\n    }\n}\n/**\n * Created by Alex Bol on 2/18/2017.\n */ /**\n *\n * Class representing a point\n * @type {Point}\n */ let $2c7a62d6ab88e4d3$export$baf26146a414f24a = class Point extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     * Point may be constructed by two numbers, or by array of two numbers\n     * @param {number} x - x-coordinate (float number)\n     * @param {number} y - y-coordinate (float number)\n     */ constructor(...args){\n        super();\n        /**\n         * x-coordinate (float number)\n         * @type {number}\n         */ this.x = 0;\n        /**\n         * y-coordinate (float number)\n         * @type {number}\n         */ this.y = 0;\n        if (args.length === 0) return;\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof arr[0] == \"number\" && typeof arr[1] == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\n            let { x: x, y: y } = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n        if (args.length === 2) {\n            if (typeof args[0] == \"number\" && typeof args[1] == \"number\") {\n                this.x = args[0];\n                this.y = args[1];\n                return;\n            }\n        }\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n    }\n    /**\n     * Returns bounding box of a point\n     * @returns {Box}\n     */ get box() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(this.x, this.y, this.x, this.y);\n    }\n    /**\n     * Return new cloned instance of point\n     * @returns {Point}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.x, this.y);\n    }\n    get vertices() {\n        return [\n            this.clone()\n        ];\n    }\n    /**\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */ equalTo(pt) {\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.x, pt.x) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.y, pt.y);\n    }\n    /**\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */ lessThan(pt) {\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(this.y, pt.y)) return true;\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.y, pt.y) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(this.x, pt.x)) return true;\n        return false;\n    }\n    /**\n     * Return new point transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Point}\n     */ transform(m) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(m.transform([\n            this.x,\n            this.y\n        ]));\n    }\n    /**\n     * Returns projection point on given line\n     * @param {Line} line Line this point be projected on\n     * @returns {Point}\n     */ projectionOn(line) {\n        if (this.equalTo(line.pt)) return this.clone();\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this, line.pt);\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(vec.cross(line.norm))) return line.pt.clone();\n        let dist = vec.dot(line.norm); // signed distance\n        let proj_vec = line.norm.multiply(dist);\n        return this.translate(proj_vec);\n    }\n    /**\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\n     * @param {Line} line Query line\n     * @returns {boolean}\n     */ leftTo(line) {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(line.pt, this);\n        let onLeftSemiPlane = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GT(vec.dot(line.norm), 0);\n        return onLeftSemiPlane;\n    }\n    /**\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from point to shape\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\n     */ distanceTo(shape) {\n        if (shape instanceof Point) {\n            let dx = shape.x - this.x;\n            let dy = shape.y - this.y;\n            return [\n                Math.sqrt(dx * dx + dy * dy),\n                new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(this, shape)\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2line(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2circle(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2segment(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2arc(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2polygon(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2planarSet(this, shape);\n    }\n    /**\n     * Returns true if point is on a shape, false otherwise\n     * @param {Shape} shape\n     * @returns {boolean}\n     */ on(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return this.equalTo(shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return shape.contains(this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return shape.contains(this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return shape.contains(this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return shape.contains(this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return shape.contains(this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return shape.contains(this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return shape.contains(this);\n    }\n    get name() {\n        return \"point\";\n    }\n    /**\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\n     * Accept any valid attributes of svg elements as svg object\n     * Defaults attribues are: <br/>\n     * {\n     *    r:\"3\",\n     *    stroke:\"black\",\n     *    strokeWidth:\"1\",\n     *    fill:\"red\"\n     * }\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\n     * @returns {String}\n     */ svg(attrs = {}) {\n        const r = attrs.r ?? 3; // default radius - 3\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r}\"\n            ${$2c7a62d6ab88e4d3$var$convertToString({\n            fill: \"red\",\n            ...attrs\n        })} />`;\n    }\n};\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point = $2c7a62d6ab88e4d3$export$baf26146a414f24a;\n/**\n * Function to create point equivalent to \"new\" constructor\n * @param args\n */ const $2c7a62d6ab88e4d3$export$105684a3041cb6f3 = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.point = $2c7a62d6ab88e4d3$export$105684a3041cb6f3;\n// export {Point};\n/**\n * Created by Alex Bol on 2/19/2017.\n */ /**\n * Class representing a vector\n * @type {Vector}\n */ let $2c7a62d6ab88e4d3$export$9b781de7bf37bf48 = class Vector extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     * Vector may be constructed by two points, or by two float numbers,\n     * or by array of two numbers\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */ constructor(...args){\n        super();\n        /**\n         * x-coordinate of a vector (float number)\n         * @type {number}\n         */ this.x = 0;\n        /**\n         * y-coordinate of a vector (float number)\n         * @type {number}\n         */ this.y = 0;\n        /* return zero vector */ if (args.length === 0) return;\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof arr[0] == \"number\" && typeof arr[1] == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\n            let { x: x, y: y } = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n            if (typeof a1 == \"number\" && typeof a2 == \"number\") {\n                this.x = a1;\n                this.y = a2;\n                return;\n            }\n            if (a1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point && a2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n                this.x = a2.x - a1.x;\n                this.y = a2.y - a1.y;\n                return;\n            }\n        }\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n    }\n    /**\n     * Method clone returns new instance of Vector\n     * @returns {Vector}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.x, this.y);\n    }\n    /**\n     * Slope of the vector in radians from 0 to 2PI\n     * @returns {number}\n     */ get slope() {\n        let angle = Math.atan2(this.y, this.x);\n        if (angle < 0) angle = 2 * Math.PI + angle;\n        return angle;\n    }\n    /**\n     * Length of vector\n     * @returns {number}\n     */ get length() {\n        return Math.sqrt(this.dot(this));\n    }\n    /**\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\n     * tolerance\n     * @param {Vector} v\n     * @returns {boolean}\n     */ equalTo(v) {\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.x, v.x) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.y, v.y);\n    }\n    /**\n     * Returns new vector multiplied by scalar\n     * @param {number} scalar\n     * @returns {Vector}\n     */ multiply(scalar) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(scalar * this.x, scalar * this.y);\n    }\n    /**\n     * Returns scalar product (dot product) of two vectors <br/>\n     * <code>dot_product = (this * v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */ dot(v) {\n        return this.x * v.x + this.y * v.y;\n    }\n    /**\n     * Returns vector product (cross product) of two vectors <br/>\n     * <code>cross_product = (this x v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */ cross(v) {\n        return this.x * v.y - this.y * v.x;\n    }\n    /**\n     * Returns unit vector.<br/>\n     * Throw error if given vector has zero length\n     * @returns {Vector}\n     */ normalize() {\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(this.length)) return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.x / this.length, this.y / this.length);\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ZERO_DIVISION;\n    }\n    /**\n     * Returns new vector rotated by given angle,\n     * positive angle defines rotation in counterclockwise direction,\n     * negative - in clockwise direction\n     * Vector only can be rotated around (0,0) point!\n     * @param {number} angle - Angle in radians\n     * @returns {Vector}\n     */ rotate(angle, center = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point()) {\n        if (center.x === 0 && center.y === 0) return this.transform(new $2c7a62d6ab88e4d3$export$5b12bf1653c0dd85().rotate(angle));\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.OPERATION_IS_NOT_SUPPORTED;\n    }\n    /**\n     * Return new vector transformed by affine transformation matrix m\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Vector}\n     */ transform(m) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(m.transform([\n            this.x,\n            this.y\n        ]));\n    }\n    /**\n     * Returns vector rotated 90 degrees counterclockwise\n     * @returns {Vector}\n     */ rotate90CCW() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(-this.y, this.x);\n    }\n    /**\n     * Returns vector rotated 90 degrees clockwise\n     * @returns {Vector}\n     */ rotate90CW() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.y, -this.x);\n    }\n    /**\n     * Return inverted vector\n     * @returns {Vector}\n     */ invert() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(-this.x, -this.y);\n    }\n    /**\n     * Return result of addition of other vector to this vector as a new vector\n     * @param {Vector} v Other vector\n     * @returns {Vector}\n     */ add(v) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.x + v.x, this.y + v.y);\n    }\n    /**\n     * Return result of subtraction of other vector from current vector as a new vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */ subtract(v) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.x - v.x, this.y - v.y);\n    }\n    /**\n     * Return angle between this vector and other vector. <br/>\n     * Angle is measured from 0 to 2*PI in the counterclockwise direction\n     * from current vector to  another.\n     * @param {Vector} v Another vector\n     * @returns {number}\n     */ angleTo(v) {\n        let norm1 = this.normalize();\n        let norm2 = v.normalize();\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\n        if (angle < 0) angle += 2 * Math.PI;\n        return angle;\n    }\n    /**\n     * Return vector projection of the current vector on another vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */ projectionOn(v) {\n        let n = v.normalize();\n        let d = this.dot(n);\n        return n.multiply(d);\n    }\n    get name() {\n        return \"vector\";\n    }\n};\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector = $2c7a62d6ab88e4d3$export$9b781de7bf37bf48;\n/**\n * Function to create vector equivalent to \"new\" constructor\n * @param args\n */ const $2c7a62d6ab88e4d3$export$6074e20ba5c64bef = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.vector = $2c7a62d6ab88e4d3$export$6074e20ba5c64bef;\n/**\n * Created by Alex Bol on 3/10/2017.\n */ /**\n * Class representing a segment\n * @type {Segment}\n */ class $2c7a62d6ab88e4d3$export$d53aa5c5ab432700 extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     *\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */ constructor(...args){\n        super();\n        /**\n         * Start point\n         * @type {Point}\n         */ this.ps = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point();\n        /**\n         * End Point\n         * @type {Point}\n         */ this.pe = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point();\n        if (args.length === 0) return;\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\n            let coords = args[0];\n            this.ps = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(coords[0], coords[1]);\n            this.pe = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(coords[2], coords[3]);\n            return;\n        }\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\n            let { ps: ps, pe: pe } = args[0];\n            this.ps = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(ps.x, ps.y);\n            this.pe = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(pe.x, pe.y);\n            return;\n        }\n        // second point omitted issue #84\n        if (args.length === 1 && args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            this.ps = args[0].clone();\n            return;\n        }\n        if (args.length === 2 && args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point && args[1] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            this.ps = args[0].clone();\n            this.pe = args[1].clone();\n            return;\n        }\n        if (args.length === 4) {\n            this.ps = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(args[0], args[1]);\n            this.pe = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(args[2], args[3]);\n            return;\n        }\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n    }\n    /**\n     * Return new cloned instance of segment\n     * @returns {Segment}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(this.start, this.end);\n    }\n    /**\n     * Start point\n     * @returns {Point}\n     */ get start() {\n        return this.ps;\n    }\n    /**\n     * End point\n     * @returns {Point}\n     */ get end() {\n        return this.pe;\n    }\n    /**\n     * Returns array of start and end point\n     * @returns [Point,Point]\n     */ get vertices() {\n        return [\n            this.ps.clone(),\n            this.pe.clone()\n        ];\n    }\n    /**\n     * Length of a segment\n     * @returns {number}\n     */ get length() {\n        return this.start.distanceTo(this.end)[0];\n    }\n    /**\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\n     * @returns {number}\n     */ get slope() {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.start, this.end);\n        return vec.slope;\n    }\n    /**\n     * Bounding box\n     * @returns {Box}\n     */ get box() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(Math.min(this.start.x, this.end.x), Math.min(this.start.y, this.end.y), Math.max(this.start.x, this.end.x), Math.max(this.start.y, this.end.y));\n    }\n    /**\n     * Returns true if equals to query segment, false otherwise\n     * @param {Seg} seg - query segment\n     * @returns {boolean}\n     */ equalTo(seg) {\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\n    }\n    /**\n     * Returns true if segment contains point\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */ contains(pt) {\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(this.distanceToPoint(pt));\n    }\n    /**\n     * Returns array of intersection points between segment and other shape\n     * @param {Shape} shape - Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */ intersect(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return this.contains(shape) ? [\n            shape\n        ] : [];\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$intersectSegment2Line(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return $2c7a62d6ab88e4d3$var$intersectRay2Segment(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$var$intersectSegment2Segment(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$var$intersectSegment2Circle(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return $2c7a62d6ab88e4d3$var$intersectSegment2Box(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$var$intersectSegment2Arc(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$intersectSegment2Polygon(this, shape);\n    }\n    /**\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from segment to shape\n     * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\n     */ distanceTo(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2segment(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.segment2circle(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.segment2line(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.segment2segment(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.segment2arc(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2polygon(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2planarSet(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n    }\n    /**\n     * Returns unit vector in the direction from start to end\n     * @returns {Vector}\n     */ tangentInStart() {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.start, this.end);\n        return vec.normalize();\n    }\n    /**\n     * Return unit vector in the direction from end to start\n     * @returns {Vector}\n     */ tangentInEnd() {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.end, this.start);\n        return vec.normalize();\n    }\n    /**\n     * Returns new segment with swapped start and end points\n     * @returns {Segment}\n     */ reverse() {\n        return new $2c7a62d6ab88e4d3$export$d53aa5c5ab432700(this.end, this.start);\n    }\n    /**\n     * When point belongs to segment, return array of two segments split by given point,\n     * if point is inside segment. Returns clone of this segment if query point is incident\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\n     * @param {Point} pt Query point\n     * @returns {Segment[]}\n     */ split(pt) {\n        if (this.start.equalTo(pt)) return [\n            null,\n            this.clone()\n        ];\n        if (this.end.equalTo(pt)) return [\n            this.clone(),\n            null\n        ];\n        return [\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(this.start, pt),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pt, this.end)\n        ];\n    }\n    /**\n     * Return middle point of the segment\n     * @returns {Point}\n     */ middle() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    }\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the segment\n     * @returns {Point}\n     */ pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length == 0) return this.start;\n        if (length == this.length) return this.end;\n        let factor = length / this.length;\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point((this.end.x - this.start.x) * factor + this.start.x, (this.end.y - this.start.y) * factor + this.start.y);\n    }\n    distanceToPoint(pt) {\n        let [dist, ...rest] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2segment(pt, this);\n        return dist;\n    }\n    definiteIntegral(ymin = 0.0) {\n        let dx = this.end.x - this.start.x;\n        let dy1 = this.start.y - ymin;\n        let dy2 = this.end.y - ymin;\n        return dx * (dy1 + dy2) / 2;\n    }\n    /**\n     * Return new segment transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Segment} - transformed segment\n     */ transform(matrix = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix()) {\n        return new $2c7a62d6ab88e4d3$export$d53aa5c5ab432700(this.ps.transform(matrix), this.pe.transform(matrix));\n    }\n    /**\n     * Returns true if segment start is equal to segment end up to DP_TOL\n     * @returns {boolean}\n     */ isZeroLength() {\n        return this.ps.equalTo(this.pe);\n    }\n    /**\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\n     * @param {Point[]} - array of points\n     * @returns {Point[]} new array sorted\n     */ sortPoints(pts) {\n        let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(this.start, this.end);\n        return line.sortPoints(pts);\n    }\n    get name() {\n        return \"segment\";\n    }\n    /**\n     * Return string to draw segment in svg\n     * @param {Object} attrs - an object with attributes for svg path element,\n     * like \"stroke\", \"strokeWidth\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\n     * @returns {string}\n     */ svg(attrs = {}) {\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" ${$2c7a62d6ab88e4d3$var$convertToString(attrs)} />`;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment = $2c7a62d6ab88e4d3$export$d53aa5c5ab432700;\n/**\n * Shortcut method to create new segment\n */ const $2c7a62d6ab88e4d3$export$6519c25590136c5e = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.segment = $2c7a62d6ab88e4d3$export$6519c25590136c5e;\n/**\n * Created by Alex Bol on 2/20/2017.\n */ let { vector: $2c7a62d6ab88e4d3$var$vector } = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039;\n/**\n * Class representing a line\n * @type {Line}\n */ let $2c7a62d6ab88e4d3$export$17d680238e50603e = class Line extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     * Line may be constructed by point and normal vector or by two points that a line passes through\n     * @param {Point} pt - point that a line passes through\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\n     */ constructor(...args){\n        super();\n        /**\n         * Point a line passes through\n         * @type {Point}\n         */ this.pt = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point();\n        /**\n         * Normal vector to a line <br/>\n         * Vector is normalized (length == 1)<br/>\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\n         * @type {Vector}\n         */ this.norm = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(0, 1);\n        if (args.length === 0) return;\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"line\") {\n            let { pt: pt, norm: norm } = args[0];\n            this.pt = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(pt);\n            this.norm = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(norm);\n            return;\n        }\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n            if (a1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point && a2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n                this.pt = a1;\n                this.norm = Line.points2norm(a1, a2);\n                if (this.norm.dot($2c7a62d6ab88e4d3$var$vector(this.pt.x, this.pt.y)) >= 0) this.norm.invert();\n                return;\n            }\n            if (a1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point && a2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector) {\n                if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(a2.x) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(a2.y)) throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n                this.pt = a1.clone();\n                this.norm = a2.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot($2c7a62d6ab88e4d3$var$vector(this.pt.x, this.pt.y)) >= 0) this.norm.invert();\n                return;\n            }\n            if (a1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector && a2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n                if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(a1.x) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(a1.y)) throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n                this.pt = a2.clone();\n                this.norm = a1.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot($2c7a62d6ab88e4d3$var$vector(this.pt.x, this.pt.y)) >= 0) this.norm.invert();\n                return;\n            }\n        }\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n    }\n    /**\n     * Return new cloned instance of line\n     * @returns {Line}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(this.pt, this.norm);\n    }\n    /* The following methods need for implementation of Edge interface\n    /**\n     * Line has no start point\n     * @returns {undefined}\n     */ get start() {\n        return undefined;\n    }\n    /**\n     * Line has no end point\n     */ get end() {\n        return undefined;\n    }\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */ get length() {\n        return Number.POSITIVE_INFINITY;\n    }\n    /**\n     * Returns infinite box\n     * @returns {Box}\n     */ get box() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    }\n    /**\n     * Middle point is undefined\n     * @returns {undefined}\n     */ get middle() {\n        return undefined;\n    }\n    /**\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */ get slope() {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n    /**\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\n     * @code [A, B, C] = line.standard\n     * @returns {number[]} - array of coefficients\n     */ get standard() {\n        let A = this.norm.x;\n        let B = this.norm.y;\n        let C = this.norm.dot($2c7a62d6ab88e4d3$var$vector(this.pt.x, this.pt.y));\n        return [\n            A,\n            B,\n            C\n        ];\n    }\n    /**\n     * Return true if parallel or incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */ parallelTo(other_line) {\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(this.norm.cross(other_line.norm));\n    }\n    /**\n     * Returns true if incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */ incidentTo(other_line) {\n        return this.parallelTo(other_line) && this.pt.on(other_line);\n    }\n    /**\n     * Returns true if point belongs to line\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */ contains(pt) {\n        if (this.pt.equalTo(pt)) return true;\n        /* Line contains point if vector to point is orthogonal to the line normal vector */ let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.pt, pt);\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(this.norm.dot(vec));\n    }\n    /**\n     * Return coordinate of the point that lies on the line in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the line and does not check it\n     * @param {Point} pt - point on a line\n     * @returns {number}\n     */ coord(pt) {\n        return $2c7a62d6ab88e4d3$var$vector(pt.x, pt.y).cross(this.norm);\n    }\n    /**\n     * Returns array of intersection points\n     * @param {Shape} shape - shape to intersect with\n     * @returns {Point[]}\n     */ intersect(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return this.contains(shape) ? [\n            shape\n        ] : [];\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$intersectLine2Line(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return $2c7a62d6ab88e4d3$var$intersectRay2Line(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$var$intersectLine2Circle(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return $2c7a62d6ab88e4d3$var$intersectLine2Box(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$var$intersectSegment2Line(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$var$intersectLine2Arc(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$intersectLine2Polygon(this, shape);\n    }\n    /**\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\n     * @returns {[number, Segment]}\n     */ distanceTo(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.circle2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.segment2line(shape, this);\n            return [\n                distance,\n                shortest_segment.reverse()\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.arc2line(shape, this);\n            return [\n                distance,\n                shortest_segment.reverse()\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2polygon(this, shape);\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n    }\n    /**\n     * Split line with a point or array of points and return array of shapes\n     * Assumed (but not checked) that all points lay on the line\n     * @param {Point | Point[]} pt\n     * @returns {MultilineShapes}\n     */ split(pt) {\n        if (pt instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return [\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray(pt, this.norm),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray(pt, this.norm)\n        ];\n        else {\n            let multiline = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Multiline([\n                this\n            ]);\n            let sorted_points = this.sortPoints(pt);\n            multiline.split(sorted_points);\n            return multiline.toShapes();\n        }\n    }\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */ rotate(angle, center = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point()) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(this.pt.rotate(angle, center), this.norm.rotate(angle));\n    }\n    /**\n     * Return new line transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Line}\n     */ transform(m) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(this.pt.transform(m), this.norm.clone());\n    }\n    /**\n     * Sort given array of points that lay on a line with respect to coordinate on a line\n     * The method assumes that points lay on the line and does not check this\n     * @param {Point[]} pts - array of points\n     * @returns {Point[]} new array sorted\n     */ sortPoints(pts) {\n        return pts.slice().sort((pt1, pt2)=>{\n            if (this.coord(pt1) < this.coord(pt2)) return -1;\n            if (this.coord(pt1) > this.coord(pt2)) return 1;\n            return 0;\n        });\n    }\n    get name() {\n        return \"line\";\n    }\n    /**\n     * Return string to draw svg segment representing line inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg circle element\n     */ svg(box, attrs = {}) {\n        let ip = $2c7a62d6ab88e4d3$var$intersectLine2Box(this, box);\n        if (ip.length === 0) return \"\";\n        let ps = ip[0];\n        let pe = ip.length === 2 ? ip[1] : ip.find((pt)=>!pt.equalTo(ps));\n        if (pe === undefined) pe = ps;\n        let segment = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ps, pe);\n        return segment.svg(attrs);\n    }\n    static points2norm(pt1, pt2) {\n        if (pt1.equalTo(pt2)) throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(pt1, pt2);\n        let unit = vec.normalize();\n        return unit.rotate90CCW();\n    }\n};\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line = $2c7a62d6ab88e4d3$export$17d680238e50603e;\n/**\n * Function to create line equivalent to \"new\" constructor\n * @param args\n */ const $2c7a62d6ab88e4d3$export$53f1d5ea8de3d7c = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.line = $2c7a62d6ab88e4d3$export$53f1d5ea8de3d7c;\n/**\n * Created by Alex Bol on 3/6/2017.\n */ /**\n * Class representing a circle\n * @type {Circle}\n */ let $2c7a62d6ab88e4d3$export$c89a927ffc67e6fa = class Circle extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     * Class private property\n     * @type {string}\n     */ /**\n     *\n     * @param {Point} pc - circle center point\n     * @param {number} r - circle radius\n     */ constructor(...args){\n        super();\n        /**\n         * Circle center\n         * @type {Point}\n         */ this.pc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point();\n        /**\n         * Circle radius\n         * @type {number}\n         */ this.r = 1;\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"circle\") {\n            let { pc: pc, r: r } = args[0];\n            this.pc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(pc);\n            this.r = r;\n        } else {\n            let [pc, r] = [\n                ...args\n            ];\n            if (pc && pc instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n        }\n    // throw Errors.ILLEGAL_PARAMETERS;    unreachable code\n    }\n    /**\n     * Return new cloned instance of circle\n     * @returns {Circle}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(this.pc.clone(), this.r);\n    }\n    /**\n     * Circle center\n     * @returns {Point}\n     */ get center() {\n        return this.pc;\n    }\n    /**\n     * Circle bounding box\n     * @returns {Box}\n     */ get box() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(this.pc.x - this.r, this.pc.y - this.r, this.pc.x + this.r, this.pc.y + this.r);\n    }\n    /**\n     * Return true if circle contains shape: no point of shape lies outside of the circle\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */ contains(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(shape.distanceTo(this.center)[0], this.r);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return this.intersect(shape).length === 0 && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return this.intersect(shape).length === 0 && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(shape.r, this.r) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\n    /* TODO: box, polygon */ }\n    /**\n     * Transform circle to closed arc\n     * @param {boolean} counterclockwise\n     * @returns {Arc}\n     */ toArc(counterclockwise = true) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n    }\n    /**\n     * Method scale is supported only for uniform scaling of the circle with (0,0) center\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Circle}\n     */ scale(sx, sy) {\n        if (sx !== sy) throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.OPERATION_IS_NOT_SUPPORTED;\n        if (!(this.pc.x === 0.0 && this.pc.y === 0.0)) throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.OPERATION_IS_NOT_SUPPORTED;\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(this.pc, this.r * sx);\n    }\n    /**\n     * Return new circle transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Circle}\n     */ transform(matrix = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix()) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(this.pc.transform(matrix), this.r);\n    }\n    /**\n     * Returns array of intersection points between circle and other shape\n     * @param {Shape} shape Shape of the one of supported types\n     * @returns {Point[]}\n     */ intersect(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return this.contains(shape) ? [\n            shape\n        ] : [];\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$intersectLine2Circle(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return $2c7a62d6ab88e4d3$var$intersectRay2Circle(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$var$intersectSegment2Circle(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$var$intersectCircle2Circle(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return $2c7a62d6ab88e4d3$var$intersectCircle2Box(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$var$intersectArc2Circle(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$intersectCircle2Polygon(this, shape);\n    }\n    /**\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from circle to shape\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\n\n     */ distanceTo(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.circle2circle(this, shape);\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.circle2line(this, shape);\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.segment2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.arc2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) {\n            let [distance, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2polygon(this, shape);\n            return [\n                distance,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2planarSet(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n    }\n    get name() {\n        return \"circle\";\n    }\n    /**\n     * Return string to draw circle in svg\n     * @param {Object} attrs - an object with attributes of svg circle element\n     * @returns {string}\n     */ svg(attrs = {}) {\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\"\n                ${$2c7a62d6ab88e4d3$var$convertToString({\n            fill: \"none\",\n            ...attrs\n        })} />`;\n    }\n};\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle = $2c7a62d6ab88e4d3$export$c89a927ffc67e6fa;\n/**\n * Shortcut to create new circle\n * @param args\n */ const $2c7a62d6ab88e4d3$export$e1d786d2f707b414 = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.circle = $2c7a62d6ab88e4d3$export$e1d786d2f707b414;\n/**\n * Created by Alex Bol on 3/10/2017.\n */ /**\n * Class representing a circular arc\n * @type {Arc}\n */ class $2c7a62d6ab88e4d3$export$6ef80ffb606dd232 extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     *\n     * @param {Point} pc - arc center\n     * @param {number} r - arc radius\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counterclockwise\n     */ constructor(...args){\n        super();\n        /**\n         * Arc center\n         * @type {Point}\n         */ this.pc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point();\n        /**\n         * Arc radius\n         * @type {number}\n         */ this.r = 1;\n        /**\n         * Arc start angle in radians\n         * @type {number}\n         */ this.startAngle = 0;\n        /**\n         * Arc end angle in radians\n         * @type {number}\n         */ this.endAngle = 2 * Math.PI;\n        /**\n         * Arc orientation\n         * @type {boolean}\n         */ this.counterClockwise = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.CCW;\n        if (args.length === 0) return;\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"arc\") {\n            let { pc: pc, r: r, startAngle: startAngle, endAngle: endAngle, counterClockwise: counterClockwise } = args[0];\n            this.pc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(pc.x, pc.y);\n            this.r = r;\n            this.startAngle = startAngle;\n            this.endAngle = endAngle;\n            this.counterClockwise = counterClockwise;\n        } else {\n            let [pc, r, startAngle, endAngle, counterClockwise] = [\n                ...args\n            ];\n            if (pc && pc instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n            if (startAngle !== undefined) this.startAngle = startAngle;\n            if (endAngle !== undefined) this.endAngle = endAngle;\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\n        }\n    // throw Flatten.Errors.ILLEGAL_PARAMETERS; unreachable code\n    }\n    /**\n     * Return new cloned instance of arc\n     * @returns {Arc}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\n    }\n    /**\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\n     * @returns {number}\n     */ get sweep() {\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.startAngle, this.endAngle)) return 0.0;\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(Math.abs(this.startAngle - this.endAngle), $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PIx2)) return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PIx2;\n        let sweep;\n        if (this.counterClockwise) sweep = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GT(this.endAngle, this.startAngle) ? this.endAngle - this.startAngle : this.endAngle - this.startAngle + $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PIx2;\n        else sweep = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GT(this.startAngle, this.endAngle) ? this.startAngle - this.endAngle : this.startAngle - this.endAngle + $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PIx2;\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GT(sweep, $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PIx2)) sweep -= $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PIx2;\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(sweep, 0)) sweep += $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PIx2;\n        return sweep;\n    }\n    /**\n     * Get start point of arc\n     * @returns {Point}\n     */ get start() {\n        let p0 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.startAngle, this.pc);\n    }\n    /**\n     * Get end point of arc\n     * @returns {Point}\n     */ get end() {\n        let p0 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.endAngle, this.pc);\n    }\n    /**\n     * Get center of arc\n     * @returns {Point}\n     */ get center() {\n        return this.pc.clone();\n    }\n    get vertices() {\n        return [\n            this.start.clone(),\n            this.end.clone()\n        ];\n    }\n    /**\n     * Get arc length\n     * @returns {number}\n     */ get length() {\n        return Math.abs(this.sweep * this.r);\n    }\n    /**\n     * Get bounding box of the arc\n     * @returns {Box}\n     */ get box() {\n        let func_arcs = this.breakToFunctional();\n        let box = func_arcs.reduce((acc, arc)=>acc.merge(arc.start.box), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box());\n        box = box.merge(this.end.box);\n        return box;\n    }\n    /**\n     * Returns true if arc contains point, false otherwise\n     * @param {Point} pt - point to test\n     * @returns {boolean}\n     */ contains(pt) {\n        // first check if  point on circle (pc,r)\n        if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.pc.distanceTo(pt)[0], this.r)) return false;\n        // point on circle\n        if (pt.equalTo(this.start)) return true;\n        let angle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.pc, pt).slope;\n        let test_arc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(test_arc.length, this.length);\n    }\n    /**\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\n     * empty array.\n     * @param {Point} pt Query point\n     * @returns {Arc[]}\n     */ split(pt) {\n        if (this.start.equalTo(pt)) return [\n            null,\n            this.clone()\n        ];\n        if (this.end.equalTo(pt)) return [\n            this.clone(),\n            null\n        ];\n        let angle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.pc, pt).slope;\n        return [\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\n        ];\n    }\n    /**\n     * Return middle point of the arc\n     * @returns {Point}\n     */ middle() {\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\n        let arc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the arc\n     * @returns {Point}\n     */ pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length === 0) return this.start;\n        if (length === this.length) return this.end;\n        let factor = length / this.length;\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;\n        let arc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n    /**\n     * Returns chord height (\"sagitta\") of the arc\n     * @returns {number}\n     */ chordHeight() {\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\n    }\n    /**\n     * Returns array of intersection points between arc and other shape\n     * @param {Shape} shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */ intersect(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return this.contains(shape) ? [\n            shape\n        ] : [];\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$intersectLine2Arc(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return $2c7a62d6ab88e4d3$var$intersectRay2Arc(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$var$intersectArc2Circle(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$var$intersectSegment2Arc(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return $2c7a62d6ab88e4d3$var$intersectArc2Box(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$var$intersectArc2Arc(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$intersectArc2Polygon(this, shape);\n    }\n    /**\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from arc to shape\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\n\n     */ distanceTo(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.arc2circle(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.arc2line(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.segment2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.arc2arc(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2polygon(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2planarSet(this, shape);\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n    }\n    /**\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\n     * @returns {Arc[]}\n     */ breakToFunctional() {\n        let func_arcs_array = [];\n        let angles = [\n            0,\n            Math.PI / 2,\n            2 * Math.PI / 2,\n            3 * Math.PI / 2\n        ];\n        let pts = [\n            this.pc.translate(this.r, 0),\n            this.pc.translate(0, this.r),\n            this.pc.translate(-this.r, 0),\n            this.pc.translate(0, -this.r)\n        ];\n        // If arc contains extreme point,\n        // create test arc started at start point and ended at this extreme point\n        let test_arcs = [];\n        for(let i = 0; i < 4; i++)if (pts[i].on(this)) test_arcs.push(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\n        if (test_arcs.length === 0) func_arcs_array.push(this.clone());\n        else {\n            // sort these arcs by length\n            test_arcs.sort((arc1, arc2)=>arc1.length - arc2.length);\n            for(let i = 0; i < test_arcs.length; i++){\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n                let new_arc;\n                if (prev_arc) new_arc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\n                else new_arc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\n                if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(new_arc.length)) func_arcs_array.push(new_arc.clone());\n            }\n            // add last sub arc\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n            let new_arc;\n            if (prev_arc) new_arc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\n            else new_arc = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\n            if (!$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(new_arc.length) && !$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(new_arc.sweep, 2 * Math.PI)) func_arcs_array.push(new_arc.clone());\n        }\n        return func_arcs_array;\n    }\n    /**\n     * Return tangent unit vector in the start point in the direction from start to end\n     * @returns {Vector}\n     */ tangentInStart() {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.pc, this.start);\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n    /**\n     * Return tangent unit vector in the end point in the direction from end to start\n     * @returns {Vector}\n     */ tangentInEnd() {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.pc, this.end);\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n    /**\n     * Returns new arc with swapped start and end angles and reversed direction\n     * @returns {Arc}\n     */ reverse() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\n    }\n    /**\n     * Return new arc transformed using affine transformation matrix <br/>\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Arc}\n     */ transform(matrix = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix()) {\n        let newStart = this.start.transform(matrix);\n        let newEnd = this.end.transform(matrix);\n        let newCenter = this.pc.transform(matrix);\n        let newDirection = this.counterClockwise;\n        if (matrix.a * matrix.d < 0) newDirection = !newDirection;\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\n    }\n    static arcSE(center, start, end, counterClockwise) {\n        let { vector: vector } = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039;\n        let startAngle = vector(center, start).slope;\n        let endAngle = vector(center, end).slope;\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(startAngle, endAngle)) {\n            endAngle += 2 * Math.PI;\n            counterClockwise = true;\n        }\n        let r = vector(center, start).length;\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(center, r, startAngle, endAngle, counterClockwise);\n    }\n    definiteIntegral(ymin = 0) {\n        let f_arcs = this.breakToFunctional();\n        let area = f_arcs.reduce((acc, arc)=>acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\n        return area;\n    }\n    circularSegmentDefiniteIntegral(ymin) {\n        let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(this.start, this.end);\n        let onLeftSide = this.pc.leftTo(line);\n        let segment = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(this.start, this.end);\n        let areaTrapez = segment.definiteIntegral(ymin);\n        let areaCircularSegment = this.circularSegmentArea();\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\n        return area;\n    }\n    circularSegmentArea() {\n        return 0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep));\n    }\n    /**\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\n     * @param {Point[]} pts array of points\n     * @returns {Point[]} new array sorted\n     */ sortPoints(pts) {\n        let { vector: vector } = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039;\n        return pts.slice().sort((pt1, pt2)=>{\n            let slope1 = vector(this.pc, pt1).slope;\n            let slope2 = vector(this.pc, pt2).slope;\n            if (slope1 < slope2) return -1;\n            if (slope1 > slope2) return 1;\n            return 0;\n        });\n    }\n    get name() {\n        return \"arc\";\n    }\n    /**\n     * Return string to draw arc in svg\n     * @param {Object} attrs - an object with attributes of svg path element\n     * @returns {string}\n     */ svg(attrs = {}) {\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(this.sweep, 2 * Math.PI)) {\n            let circle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(this.pc, this.r);\n            return circle.svg(attrs);\n        } else return `\\n<path d=\"M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\n                    ${$2c7a62d6ab88e4d3$var$convertToString({\n            fill: \"none\",\n            ...attrs\n        })} />`;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc = $2c7a62d6ab88e4d3$export$6ef80ffb606dd232;\n/**\n * Function to create arc equivalent to \"new\" constructor\n * @param args\n */ const $2c7a62d6ab88e4d3$export$ff1ef9a5c671f043 = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.arc = $2c7a62d6ab88e4d3$export$ff1ef9a5c671f043;\n/**\n * Created by Alex Bol on 3/7/2017.\n */ /**\n * Class Box represents bounding box of the shape.\n * It may also represent axis-aligned rectangle\n * @type {Box}\n */ class $2c7a62d6ab88e4d3$export$e71c4d32a2263218 extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     *\n     * @param {number} xmin - minimal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */ constructor(xmin, ymin, xmax, ymax){\n        super();\n        /**\n         * Minimal x coordinate\n         * @type {number}\n         */ this.xmin = xmin;\n        /**\n         * Minimal y coordinate\n         * @type {number}\n         */ this.ymin = ymin;\n        /**\n         * Maximal x coordinate\n         * @type {number}\n         */ this.xmax = xmax;\n        /**\n         * Maximal y coordinate\n         * @type {number}\n         */ this.ymax = ymax;\n    }\n    /**\n     * Return new cloned instance of box\n     * @returns {Box}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$e71c4d32a2263218(this.xmin, this.ymin, this.xmax, this.ymax);\n    }\n    /**\n     * Property low need for interval tree interface\n     * @returns {Point}\n     */ get low() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.xmin, this.ymin);\n    }\n    /**\n     * Property high need for interval tree interface\n     * @returns {Point}\n     */ get high() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.xmax, this.ymax);\n    }\n    /**\n     * Property max returns the box itself !\n     * @returns {Box}\n     */ get max() {\n        return this.clone();\n    }\n    /**\n     * Return center of the box\n     * @returns {Point}\n     */ get center() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\n    }\n    /**\n     * Return the width of the box\n     * @returns {number}\n     */ get width() {\n        return Math.abs(this.xmax - this.xmin);\n    }\n    /**\n     * Return the height of the box\n     * @returns {number}\n     */ get height() {\n        return Math.abs(this.ymax - this.ymin);\n    }\n    /**\n     * Return property box like all other shapes\n     * @returns {Box}\n     */ get box() {\n        return this.clone();\n    }\n    /**\n     * Returns true if not intersected with other box\n     * @param {Box} other_box - other box to test\n     * @returns {boolean}\n     */ not_intersect(other_box) {\n        return this.xmax < other_box.xmin || this.xmin > other_box.xmax || this.ymax < other_box.ymin || this.ymin > other_box.ymax;\n    }\n    /**\n     * Returns true if intersected with other box\n     * @param {Box} other_box - Query box\n     * @returns {boolean}\n     */ intersect(other_box) {\n        return !this.not_intersect(other_box);\n    }\n    /**\n     * Returns new box merged with other box\n     * @param {Box} other_box - Other box to merge with\n     * @returns {Box}\n     */ merge(other_box) {\n        return new $2c7a62d6ab88e4d3$export$e71c4d32a2263218(this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin), this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin), this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax), this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax));\n    }\n    /**\n     * Defines predicate \"less than\" between two boxes. Need for interval index\n     * @param {Box} other_box - other box\n     * @returns {boolean} - true if this box less than other box, false otherwise\n     */ less_than(other_box) {\n        if (this.low.lessThan(other_box.low)) return true;\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high)) return true;\n        return false;\n    }\n    /**\n     * Returns true if this box is equal to other box, false otherwise\n     * @param {Box} other_box - query box\n     * @returns {boolean}\n     */ equal_to(other_box) {\n        return this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high);\n    }\n    output() {\n        return this.clone();\n    }\n    static comparable_max(box1, box2) {\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\n        return box1.merge(box2);\n    }\n    static comparable_less_than(pt1, pt2) {\n        return pt1.lessThan(pt2);\n    }\n    /**\n     * Set new values to the box object\n     * @param {number} xmin - mininal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */ set(xmin, ymin, xmax, ymax) {\n        this.xmin = xmin;\n        this.ymin = ymin;\n        this.xmax = xmax;\n        this.ymax = ymax;\n    }\n    /**\n     * Transform box into array of points from low left corner in counterclockwise\n     * @returns {Point[]}\n     */ toPoints() {\n        return [\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.xmin, this.ymin),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.xmax, this.ymin),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.xmax, this.ymax),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(this.xmin, this.ymax)\n        ];\n    }\n    /**\n     * Transform box into array of segments from low left corner in counterclockwise\n     * @returns {Segment[]}\n     */ toSegments() {\n        let pts = this.toPoints();\n        return [\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pts[0], pts[1]),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pts[1], pts[2]),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pts[2], pts[3]),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pts[3], pts[0])\n        ];\n    }\n    /**\n     * Box rotation is not supported\n     * Attempt to rotate box throws error\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     */ rotate(angle, center = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point()) {\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.OPERATION_IS_NOT_SUPPORTED;\n    }\n    /**\n     * Return new box transformed using affine transformation matrix\n     * New box is a bounding box of transformed corner points\n     * @param {Matrix} m - affine transformation matrix\n     * @returns {Box}\n     */ transform(m = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix()) {\n        const transformed_points = this.toPoints().map((pt)=>pt.transform(m));\n        return transformed_points.reduce((new_box, pt)=>new_box.merge(pt.box), new $2c7a62d6ab88e4d3$export$e71c4d32a2263218());\n    }\n    /**\n     * Return true if box contains shape: no point of shape lies outside the box\n     * @param {AnyShape} shape - test shape\n     * @returns {boolean}\n     */ contains(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return shape.x >= this.xmin && shape.x <= this.xmax && shape.y >= this.ymin && shape.y <= this.ymax;\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return shape.vertices.every((vertex)=>this.contains(vertex));\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return shape.toSegments().every((segment)=>this.contains(segment));\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return this.contains(shape.box);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return shape.vertices.every((vertex)=>this.contains(vertex)) && shape.toSegments().every((segment)=>$2c7a62d6ab88e4d3$var$intersectSegment2Arc(segment, shape).length === 0);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return false;\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Multiline) return shape.toShapes().every((shape)=>this.contains(shape));\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return this.contains(shape.box);\n    }\n    get name() {\n        return \"box\";\n    }\n    /**\n     * Return string to draw box in svg\n     * @param {Object} attrs - an object with attributes of svg rectangle element\n     * @returns {string}\n     */ svg(attrs = {}) {\n        const width = this.xmax - this.xmin;\n        const height = this.ymax - this.ymin;\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height}\n                ${$2c7a62d6ab88e4d3$var$convertToString({\n            fill: \"none\",\n            ...attrs\n        })} />`;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box = $2c7a62d6ab88e4d3$export$e71c4d32a2263218;\n/**\n * Shortcut to create new box\n * @param args\n * @returns {Box}\n */ const $2c7a62d6ab88e4d3$export$827f4ee28efc37 = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.box = $2c7a62d6ab88e4d3$export$827f4ee28efc37;\n/**\n * Created by Alex Bol on 3/17/2017.\n */ /**\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\n * Each edge contains references to the next and previous edges in the face of the polygon.\n *\n * @type {Edge}\n */ class $2c7a62d6ab88e4d3$export$b9d9805c9b77a56d {\n    /**\n     * Construct new instance of edge\n     * @param {Shape} shape Shape of type Segment or Arc\n     */ constructor(shape){\n        /**\n         * Shape of the edge: Segment or Arc\n         * @type {Segment|Arc}\n         */ this.shape = shape;\n        /**\n         * Pointer to the next edge in the face\n         * @type {Edge}\n         */ this.next = undefined;\n        /**\n         * Pointer to the previous edge in the face\n         * @type {Edge}\n         */ this.prev = undefined;\n        /**\n         * Pointer to the face containing this edge\n         * @type {Face}\n         */ this.face = undefined;\n        /**\n         * \"Arc distance\" from the face start\n         * @type {number}\n         */ this.arc_length = 0;\n        /**\n         * Start inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */ this.bvStart = undefined;\n        /**\n         * End inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */ this.bvEnd = undefined;\n        /**\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\n         * @type {*}\n         */ this.bv = undefined;\n        /**\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\n         * @type {*}\n         */ this.overlap = undefined;\n    }\n    /**\n     * Get edge start point\n     */ get start() {\n        return this.shape.start;\n    }\n    /**\n     * Get edge end point\n     */ get end() {\n        return this.shape.end;\n    }\n    /**\n     * Get edge length\n     */ get length() {\n        return this.shape.length;\n    }\n    /**\n     * Get bounding box of the edge\n     * @returns {Box}\n     */ get box() {\n        return this.shape.box;\n    }\n    get isSegment() {\n        return this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment;\n    }\n    get isArc() {\n        return this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc;\n    }\n    get isLine() {\n        return this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line;\n    }\n    get isRay() {\n        return this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray;\n    }\n    /**\n     * Get middle point of the edge\n     * @returns {Point}\n     */ middle() {\n        return this.shape.middle();\n    }\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the edge\n     * @returns {Point}\n     */ pointAtLength(length) {\n        return this.shape.pointAtLength(length);\n    }\n    /**\n     * Returns true if point belongs to the edge, false otherwise\n     * @param {Point} pt - test point\n     */ contains(pt) {\n        return this.shape.contains(pt);\n    }\n    /**\n     * Set inclusion flag of the edge with respect to another polygon\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\n     * @param polygon\n     */ setInclusion(polygon) {\n        if (this.bv !== undefined) return this.bv;\n        if (this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line || this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) {\n            this.bv = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE;\n            return this.bv;\n        }\n        if (this.bvStart === undefined) this.bvStart = $2c7a62d6ab88e4d3$export$3adad403c78dc9b2(polygon, this.start);\n        if (this.bvEnd === undefined) this.bvEnd = $2c7a62d6ab88e4d3$export$3adad403c78dc9b2(polygon, this.end);\n        /* At least one end outside - the whole edge outside */ if (this.bvStart === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE || this.bvEnd == $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE) this.bv = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OUTSIDE;\n        else if (this.bvStart === $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.INSIDE || this.bvEnd == $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.INSIDE) this.bv = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.INSIDE;\n        else {\n            let bvMiddle = $2c7a62d6ab88e4d3$export$3adad403c78dc9b2(polygon, this.middle());\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\n            this.bv = bvMiddle;\n        }\n        return this.bv;\n    }\n    /**\n     * Set overlapping between two coincident boundary edges\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\n     * @param edge\n     */ setOverlap(edge) {\n        let flag = undefined;\n        let shape1 = this.shape;\n        let shape2 = edge.shape;\n        if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) flag = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OVERLAP_SAME;\n            else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) flag = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OVERLAP_OPPOSITE;\n        } else if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/ shape1.middle().equalTo(shape2.middle())) flag = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OVERLAP_SAME;\n            else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/ shape1.middle().equalTo(shape2.middle())) flag = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OVERLAP_OPPOSITE;\n        } else if (shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc || shape1 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc && shape2 instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) flag = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OVERLAP_SAME;\n            else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) flag = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.OVERLAP_OPPOSITE;\n        }\n        /* Do not update overlap flag if already set on previous chain */ if (this.overlap === undefined) this.overlap = flag;\n        if (edge.overlap === undefined) edge.overlap = flag;\n    }\n    svg() {\n        if (this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return ` L${this.shape.end.x},${this.shape.end.y}`;\n        else if (this.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) {\n            let arc = this.shape;\n            let largeArcFlag;\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n            // Draw full circe arc as special case: split it into two half-circles\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ(arc.sweep, 2 * Math.PI)) {\n                let sign = arc.counterClockwise ? 1 : -1;\n                let halfArc1 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\n                let halfArc2 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\n                largeArcFlag = \"0\";\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`;\n            } else {\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\n            }\n        }\n    }\n    toJSON() {\n        return this.shape.toJSON();\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge = $2c7a62d6ab88e4d3$export$b9d9805c9b77a56d;\n/**\n * Class implements circular bidirectional linked list <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */ class $2c7a62d6ab88e4d3$var$CircularLinkedList extends $2c7a62d6ab88e4d3$var$LinkedList {\n    constructor(first, last){\n        super(first, last);\n        this.setCircularLinks();\n    }\n    setCircularLinks() {\n        if (this.isEmpty()) return;\n        this.last.next = this.first;\n        this.first.prev = this.last;\n    }\n    [Symbol.iterator]() {\n        let element = undefined;\n        return {\n            next: ()=>{\n                let value = element ? element : this.first;\n                let done = this.first ? element ? element === this.first : false : true;\n                element = value ? value.next : undefined;\n                return {\n                    value: value,\n                    done: done\n                };\n            }\n        };\n    }\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element - new element to be appended\n     * @returns {CircularLinkedList}\n     */ append(element) {\n        super.append(element);\n        this.setCircularLinks();\n        return this;\n    }\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement - new element to be inserted\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\n     * @returns {CircularLinkedList}\n     */ insert(newElement, elementBefore) {\n        super.insert(newElement, elementBefore);\n        this.setCircularLinks();\n        return this;\n    }\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element - element to be removed from the list\n     * @returns {CircularLinkedList}\n     */ remove(element) {\n        super.remove(element);\n        // this.setCircularLinks();\n        return this;\n    }\n}\n/**\n * Created by Alex Bol on 3/17/2017.\n */ /**\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\n * Face object cannot be instantiated with a constructor.\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\n * <br/>\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\n * Container of edges is a property of the polygon object. <br/>\n *\n * @example\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\n * for (let edge of face) {\n *      console.log(edge.shape.length)     // do something\n * }\n *\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\n * let edge = face.first;\n * do {\n *   console.log(edge.shape.length);   // do something\n *   edge = edge.next;\n * } while (edge != face.first)\n */ class $2c7a62d6ab88e4d3$export$aa6504bc3c7c25a1 extends $2c7a62d6ab88e4d3$var$CircularLinkedList {\n    constructor(polygon, ...args){\n        super(); // construct empty list of edges\n        /**\n         * Reference to the first edge in face\n         */ // this.first;\n        /**\n         * Reference to the last edge in face\n         */ // this.last;\n        this._box = undefined; // new Box();\n        this._orientation = undefined;\n        if (args.length === 0) return;\n        /* If passed an array it supposed to be:\n         1) array of shapes that performs close loop or\n         2) array of points that performs set of vertices\n         */ if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                // let argsArray = args[0];\n                let shapes = args[0]; // argsArray[0];\n                if (shapes.length === 0) return;\n                /* array of Flatten.Points */ if (shapes.every((shape)=>{\n                    return shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point;\n                })) {\n                    let segments = $2c7a62d6ab88e4d3$export$aa6504bc3c7c25a1.points2segments(shapes);\n                    this.shapes2face(polygon.edges, segments);\n                } else if (shapes.every((shape)=>{\n                    return shape instanceof Array && shape.length === 2;\n                })) {\n                    let points = shapes.map((shape)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(shape[0], shape[1]));\n                    let segments = $2c7a62d6ab88e4d3$export$aa6504bc3c7c25a1.points2segments(points);\n                    this.shapes2face(polygon.edges, segments);\n                } else if (shapes.every((shape)=>{\n                    return shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc;\n                })) this.shapes2face(polygon.edges, shapes);\n                else if (shapes.every((shape)=>{\n                    return shape.name === \"segment\" || shape.name === \"arc\";\n                })) {\n                    let flattenShapes = [];\n                    for (let shape of shapes){\n                        let flattenShape;\n                        if (shape.name === \"segment\") flattenShape = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(shape);\n                        else flattenShape = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc(shape);\n                        flattenShapes.push(flattenShape);\n                    }\n                    this.shapes2face(polygon.edges, flattenShapes);\n                }\n            } else if (args[0] instanceof $2c7a62d6ab88e4d3$export$aa6504bc3c7c25a1) {\n                let face = args[0];\n                this.first = face.first;\n                this.last = face.last;\n                for (let edge of face)polygon.edges.add(edge);\n            } else if (args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) this.shapes2face(polygon.edges, [\n                args[0].toArc($2c7a62d6ab88e4d3$export$ce920184faf97f5)\n            ]);\n            else if (args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) {\n                let box = args[0];\n                this.shapes2face(polygon.edges, [\n                    new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmin, box.ymin), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmax, box.ymin)),\n                    new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmax, box.ymin), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmax, box.ymax)),\n                    new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmax, box.ymax), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmin, box.ymax)),\n                    new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmin, box.ymax), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point(box.xmin, box.ymin))\n                ]);\n            }\n        }\n        /* If passed two edges, consider them as start and end of the face loop */ /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */ /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */ if (args.length === 2 && args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge && args[1] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge) {\n            this.first = args[0]; // first edge in face or undefined\n            this.last = args[1]; // last edge in face or undefined\n            this.last.next = this.first;\n            this.first.prev = this.last;\n            // set arc length\n            this.setArcLength();\n        // this.box = this.getBox();\n        // this.orientation = this.getOrientation();      // face direction cw or ccw\n        }\n    }\n    /**\n     * Return array of edges from first to last\n     * @returns {Array}\n     */ get edges() {\n        return this.toArray();\n    }\n    /**\n     * Return array of shapes which comprise face\n     * @returns {Array}\n     */ get shapes() {\n        return this.edges.map((edge)=>edge.shape.clone());\n    }\n    /**\n     * Return bounding box of the face\n     * @returns {Box}\n     */ get box() {\n        if (this._box === undefined) {\n            let box = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box();\n            for (let edge of this)box = box.merge(edge.box);\n            this._box = box;\n        }\n        return this._box;\n    }\n    /**\n     * Get all edges length\n     * @returns {number}\n     */ get perimeter() {\n        return this.last.arc_length + this.last.length;\n    }\n    /**\n     * Get point on face boundary at given length\n     * @param {number} length - The length along the face boundary\n     * @returns {Point}\n     */ pointAtLength(length) {\n        if (length > this.perimeter || length < 0) return null;\n        let point = null;\n        for (let edge of this)if (length >= edge.arc_length && (edge === this.last || length < edge.next.arc_length)) {\n            point = edge.pointAtLength(length - edge.arc_length);\n            break;\n        }\n        return point;\n    }\n    static points2segments(points) {\n        let segments = [];\n        for(let i = 0; i < points.length; i++){\n            // skip zero length segment\n            if (points[i].equalTo(points[(i + 1) % points.length])) continue;\n            segments.push(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(points[i], points[(i + 1) % points.length]));\n        }\n        return segments;\n    }\n    shapes2face(edges, shapes) {\n        for (let shape of shapes){\n            let edge = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge(shape);\n            this.append(edge);\n            // this.box = this.box.merge(shape.box);\n            edges.add(edge);\n        }\n    // this.orientation = this.getOrientation();              // face direction cw or ccw\n    }\n    /**\n     * Append edge after the last edge of the face (and before the first edge). <br/>\n     * @param {Edge} edge - Edge to be appended to the linked list\n     * @returns {Face}\n     */ append(edge) {\n        super.append(edge);\n        // set arc length\n        this.setOneEdgeArcLength(edge);\n        edge.face = this;\n        // edges.add(edge);      // Add new edges into edges container\n        return this;\n    }\n    /**\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\n     * @param {Edge} newEdge - Edge to be inserted into linked list\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\n     * @returns {Face}\n     */ insert(newEdge, edgeBefore) {\n        super.insert(newEdge, edgeBefore);\n        // set arc length\n        this.setOneEdgeArcLength(newEdge);\n        newEdge.face = this;\n        return this;\n    }\n    /**\n     * Remove the given edge from the linked list of the face <br/>\n     * @param {Edge} edge - Edge to be removed\n     * @returns {Face}\n     */ remove(edge) {\n        super.remove(edge);\n        // Recalculate arc length\n        this.setArcLength();\n        return this;\n    }\n    /**\n     * Merge current edge with the next edge. Given edge will be extended,\n     * next edge after it will be removed. The distortion of the polygon\n     * is on the responsibility of the user of this method\n     * @param {Edge} edge - edge to be extended\n     * @returns {Face}\n     */ merge_with_next_edge(edge) {\n        edge.shape.end.x = edge.next.shape.end.x;\n        edge.shape.end.y = edge.next.shape.end.y;\n        this.remove(edge.next);\n        return this;\n    }\n    /**\n     * Reverse orientation of the face: first edge become last and vice a verse,\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\n     * clockwise, it becomes counterclockwise and vice versa\n     */ reverse() {\n        // collect edges in revert order with reverted shapes\n        let edges = [];\n        let edge_tmp = this.last;\n        do {\n            // reverse shape\n            edge_tmp.shape = edge_tmp.shape.reverse();\n            edges.push(edge_tmp);\n            edge_tmp = edge_tmp.prev;\n        }while (edge_tmp !== this.last);\n        // restore linked list\n        this.first = undefined;\n        this.last = undefined;\n        for (let edge of edges){\n            if (this.first === undefined) {\n                edge.prev = edge;\n                edge.next = edge;\n                this.first = edge;\n                this.last = edge;\n            } else {\n                // append to end\n                edge.prev = this.last;\n                this.last.next = edge;\n                // update edge to be last\n                this.last = edge;\n                // restore circular links\n                this.last.next = this.first;\n                this.first.prev = this.last;\n            }\n            // set arc length\n            this.setOneEdgeArcLength(edge);\n        }\n        // Recalculate orientation, if set\n        if (this._orientation !== undefined) {\n            this._orientation = undefined;\n            this._orientation = this.orientation();\n        }\n    }\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */ setArcLength() {\n        for (let edge of this){\n            this.setOneEdgeArcLength(edge);\n            edge.face = this;\n        }\n    }\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) edge.arc_length = 0.0;\n        else edge.arc_length = edge.prev.arc_length + edge.prev.length;\n    }\n    /**\n     * Returns the absolute value of the area of the face\n     * @returns {number}\n     */ area() {\n        return Math.abs(this.signedArea());\n    }\n    /**\n     * Returns signed area of the simple face.\n     * Face is simple if it has no self intersections that change its orientation.\n     * Then the area will be positive if the orientation of the face is clockwise,\n     * and negative if orientation is counterclockwise.\n     * It may be zero if polygon is degenerated.\n     * @returns {number}\n     */ signedArea() {\n        let sArea = 0;\n        let ymin = this.box.ymin;\n        for (let edge of this)sArea += edge.shape.definiteIntegral(ymin);\n        return sArea;\n    }\n    /**\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\n     * and the sign of the integral will be defined by the direction of the curve.\n     * When the integral (\"signed area\") will be negative, direction is counterclockwise,\n     * when positive - clockwise and when it is zero, polygon is not orientable.\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\n     * @returns {number}\n     */ orientation() {\n        if (this._orientation === undefined) {\n            let area = this.signedArea();\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(area)) this._orientation = $2c7a62d6ab88e4d3$export$7423c88bc54edb74.NOT_ORIENTABLE;\n            else if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(area, 0)) this._orientation = $2c7a62d6ab88e4d3$export$7423c88bc54edb74.CCW;\n            else this._orientation = $2c7a62d6ab88e4d3$export$7423c88bc54edb74.CW;\n        }\n        return this._orientation;\n    }\n    /**\n     * Returns true if face of the polygon is simple (no self-intersection points found)\n     * NOTE: this method is incomplete because it does not exclude touching points.\n     * Self intersection test should check if polygon change orientation in the test point.\n     * @param {PlanarSet} edges - reference to polygon edges to provide search index\n     * @returns {boolean}\n     */ isSimple(edges) {\n        let ip = $2c7a62d6ab88e4d3$export$aa6504bc3c7c25a1.getSelfIntersections(this, edges, true);\n        return ip.length === 0;\n    }\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\n        let int_points = [];\n        // calculate intersections\n        for (let edge1 of face){\n            // request edges of polygon in the box of edge1\n            let resp = edges.search(edge1.box);\n            // for each edge2 in response\n            for (let edge2 of resp){\n                // Skip itself\n                if (edge1 === edge2) continue;\n                // Skip is edge2 belongs to another face\n                if (edge2.face !== face) continue;\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\n                if (edge1.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment && edge2.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment && (edge1.next === edge2 || edge1.prev === edge2)) continue;\n                // calculate intersections between edge1 and edge2\n                let ip = edge1.shape.intersect(edge2.shape);\n                // for each intersection point\n                for (let pt of ip){\n                    // skip start-end connections\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev) continue;\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next) continue;\n                    int_points.push(pt);\n                    if (exitOnFirst) break;\n                }\n                if (int_points.length > 0 && exitOnFirst) break;\n            }\n            if (int_points.length > 0 && exitOnFirst) break;\n        }\n        return int_points;\n    }\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt - test point\n     * @returns {Edge}\n     */ findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this){\n            if (pt.equalTo(edge.shape.start)) continue;\n            if (pt.equalTo(edge.shape.end) || edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n    /**\n     * Returns new polygon created from one face\n     * @returns {Polygon}\n     */ toPolygon() {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(this.shapes);\n    }\n    toJSON() {\n        return this.edges.map((edge)=>edge.toJSON());\n    }\n    /**\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\n     * @returns {string}\n     */ svg() {\n        let svgStr = `M${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this)svgStr += edge.svg();\n        svgStr += ` z`;\n        return svgStr;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Face = $2c7a62d6ab88e4d3$export$aa6504bc3c7c25a1;\n/**\n * Class representing a ray (a half-infinite line).\n * @type {Ray}\n */ class $2c7a62d6ab88e4d3$export$a186db52eed6d40e extends $2c7a62d6ab88e4d3$var$Shape {\n    /**\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\n     * on a ray fit an equation: <br />\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\n     * @param {Point} pt - start point\n     * @param {Vector} norm - normal vector\n     */ constructor(...args){\n        super();\n        this.pt = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point();\n        this.norm = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(0, 1);\n        if (args.length === 0) return;\n        if (args.length >= 1 && args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) this.pt = args[0].clone();\n        if (args.length === 1) return;\n        if (args.length === 2 && args[1] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector) {\n            this.norm = args[1].clone();\n            return;\n        }\n        throw $2c7a62d6ab88e4d3$export$b8e9cd941e8016ac.ILLEGAL_PARAMETERS;\n    }\n    /**\n     * Return new cloned instance of ray\n     * @returns {Ray}\n     */ clone() {\n        return new $2c7a62d6ab88e4d3$export$a186db52eed6d40e(this.pt, this.norm);\n    }\n    /**\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */ get slope() {\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n    /**\n     * Returns half-infinite bounding box of the ray\n     * @returns {Box} - bounding box\n     */ get box() {\n        let slope = this.slope;\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box(slope > Math.PI / 2 && slope < 3 * Math.PI / 2 ? Number.NEGATIVE_INFINITY : this.pt.x, slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY, slope >= Math.PI / 2 && slope <= 3 * Math.PI / 2 ? this.pt.x : Number.POSITIVE_INFINITY, slope >= Math.PI && slope <= 2 * Math.PI || slope === 0 ? this.pt.y : Number.POSITIVE_INFINITY);\n    }\n    /**\n     * Return ray start point\n     * @returns {Point} - ray start point\n     */ get start() {\n        return this.pt;\n    }\n    /**\n     * Ray has no end point?\n     * @returns {undefined}\n     */ get end() {\n        return undefined;\n    }\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */ get length() {\n        return Number.POSITIVE_INFINITY;\n    }\n    /**\n     * Returns true if point belongs to ray\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */ contains(pt) {\n        if (this.pt.equalTo(pt)) return true;\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\n            and cross product from vector to point is positive */ let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(this.pt, pt);\n        return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(this.norm.dot(vec)) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(vec.cross(this.norm), 0);\n    }\n    /**\n     * Return coordinate of the point that lies on the ray in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line containing this ray and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the ray\n     * @param {Point} pt - point on a ray\n     * @returns {number}\n     */ coord(pt) {\n        return $2c7a62d6ab88e4d3$export$6074e20ba5c64bef(pt.x, pt.y).cross(this.norm);\n    }\n    /**\n     * Split ray with point and return array of segment and new ray\n     * @param {Point} pt\n     * @returns [Segment,Ray]\n     */ split(pt) {\n        if (!this.contains(pt)) return [];\n        if (this.pt.equalTo(pt)) return [\n            this\n        ];\n        return [\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(this.pt, pt),\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray(pt, this.norm)\n        ];\n    }\n    /**\n     * Returns array of intersection points between ray and another shape\n     * @param {Shape} shape - Shape to intersect with ray\n     * @returns {Point[]} array of intersection points\n     */ intersect(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return this.contains(shape) ? [\n            shape\n        ] : [];\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$var$intersectRay2Segment(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$var$intersectRay2Arc(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$intersectRay2Line(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return $2c7a62d6ab88e4d3$var$intersectRay2Ray(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$var$intersectRay2Circle(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box) return $2c7a62d6ab88e4d3$var$intersectRay2Box(this, shape);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$intersectRay2Polygon(this, shape);\n    }\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */ rotate(angle, center = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point()) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray(this.pt.rotate(angle, center), this.norm.rotate(angle));\n    }\n    /**\n     * Return new ray transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Ray}\n     */ transform(m) {\n        return new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray(this.pt.transform(m), this.norm.clone());\n    }\n    get name() {\n        return \"ray\";\n    }\n    /**\n     * Return string to draw svg segment representing ray inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg segment element\n     */ svg(box, attrs = {}) {\n        let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(this.pt, this.norm);\n        let ip = $2c7a62d6ab88e4d3$var$intersectLine2Box(line, box);\n        ip = ip.filter((pt)=>this.contains(pt));\n        if (ip.length === 0 || ip.length === 2) return \"\";\n        let segment = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(this.pt, ip[0]);\n        return segment.svg(attrs);\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray = $2c7a62d6ab88e4d3$export$a186db52eed6d40e;\nconst $2c7a62d6ab88e4d3$export$e006947b4f05482d = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.ray = $2c7a62d6ab88e4d3$export$e006947b4f05482d;\n/**\n * Created by Alex Bol on 3/15/2017.\n */ /**\n * Class representing a polygon.<br/>\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\n * @type {Polygon}\n */ class $2c7a62d6ab88e4d3$export$7d31b617c820d435 {\n    /**\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\n     * Constructor accepts as argument array that define loop of shapes\n     * or array of arrays in case of multi polygon <br/>\n     * Loop may be defined in different ways: <br/>\n     * - array of shapes of type Segment or Arc <br/>\n     * - array of points (Flatten.Point) <br/>\n     * - array of numeric pairs which represent points <br/>\n     * - box or circle object <br/>\n     * Alternatively, it is possible to use polygon.addFace method\n     * @param {args} - array of shapes or array of arrays\n     */ constructor(){\n        /**\n         * Container of faces (closed loops), may be empty\n         * @type {PlanarSet}\n         */ this.faces = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet();\n        /**\n         * Container of edges\n         * @type {PlanarSet}\n         */ this.edges = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet();\n        /* It may be array of something that may represent one loop (face) or\n         array of arrays that represent multiple loops\n         */ let args = [\n            ...arguments\n        ];\n        if (args.length === 1 && (args[0] instanceof Array && args[0].length > 0 || args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle || args[0] instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box)) {\n            let argsArray = args[0];\n            if (args[0] instanceof Array && args[0].every((loop)=>{\n                return loop instanceof Array;\n            })) {\n                if (argsArray.every((el)=>{\n                    return el instanceof Array && el.length === 2 && typeof el[0] === \"number\" && typeof el[1] === \"number\";\n                })) this.faces.add(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Face(this, argsArray)); // one-loop polygon as array of pairs of numbers\n                else for (let loop of argsArray){\n                    /* Check extra level of nesting for GeoJSON-style multi polygons */ if (loop instanceof Array && loop[0] instanceof Array && loop[0].every((el)=>{\n                        return el instanceof Array && el.length === 2 && typeof el[0] === \"number\" && typeof el[1] === \"number\";\n                    })) for (let loop1 of loop)this.faces.add(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Face(this, loop1));\n                    else this.faces.add(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Face(this, loop));\n                }\n            } else this.faces.add(new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Face(this, argsArray)); // one-loop polygon\n        }\n    }\n    /**\n     * (Getter) Returns bounding box of the polygon\n     * @returns {Box}\n     */ get box() {\n        return [\n            ...this.faces\n        ].reduce((acc, face)=>acc.merge(face.box), new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Box());\n    }\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Array}\n     */ get vertices() {\n        return [\n            ...this.edges\n        ].map((edge)=>edge.start);\n    }\n    /**\n     * Create new cloned instance of the polygon\n     * @returns {Polygon}\n     */ clone() {\n        let polygon = new $2c7a62d6ab88e4d3$export$7d31b617c820d435();\n        for (let face of this.faces)polygon.addFace(face.shapes);\n        return polygon;\n    }\n    /**\n     * Return true is polygon has no edges\n     * @returns {boolean}\n     */ isEmpty() {\n        return this.edges.size === 0;\n    }\n    /**\n     * Return true if polygon is valid for boolean operations\n     * Polygon is valid if <br/>\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\n     * @returns {boolean}\n     */ isValid() {\n        let valid = true;\n        // 1. Polygon is invalid if at least one face is not simple\n        for (let face of this.faces)if (!face.isSimple(this.edges)) {\n            valid = false;\n            break;\n        }\n        // 2. TODO: check if no island inside island and no hole inside hole\n        // 3. TODO: check the there is no intersection between faces\n        return valid;\n    }\n    /**\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\n     * @returns {number}\n     */ area() {\n        let signedArea = [\n            ...this.faces\n        ].reduce((acc, face)=>acc + face.signedArea(), 0);\n        return Math.abs(signedArea);\n    }\n    /**\n     * Add new face to polygon. Returns added face\n     * @param {Point[]|Segment[]|Arc[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\n     * 1) array of points that describe closed path (edges are segments) <br/>\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\n     * 3) circle - will be added as counterclockwise arc <br/>\n     * 4) box - will be added as counterclockwise rectangle <br/>\n     * You can chain method face.reverse() is you need to change direction of the creates face\n     * @returns {Face}\n     */ addFace(...args) {\n        let face = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Face(this, ...args);\n        this.faces.add(face);\n        return face;\n    }\n    /**\n     * Delete existing face from polygon\n     * @param {Face} face Face to be deleted\n     * @returns {boolean}\n     */ deleteFace(face) {\n        for (let edge of face)this.edges.delete(edge);\n        return this.faces.delete(face);\n    }\n    /**\n     * Clear all faces and create new faces from edges\n     */ recreateFaces() {\n        // Remove all faces\n        this.faces.clear();\n        for (let edge of this.edges)edge.face = null;\n        // Restore faces\n        let first;\n        let unassignedEdgeFound = true;\n        while(unassignedEdgeFound){\n            unassignedEdgeFound = false;\n            for (let edge of this.edges)if (edge.face === null) {\n                first = edge;\n                unassignedEdgeFound = true;\n                break;\n            }\n            if (unassignedEdgeFound) {\n                let last = first;\n                do last = last.next;\n                while (last.next !== first);\n                this.addFace(first, last);\n            }\n        }\n    }\n    /**\n     * Delete chain of edges from the face.\n     * @param {Face} face Face to remove chain\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\n     * @param {Edge} edgeTo End of the chain of edges to be removed\n     */ removeChain(face, edgeFrom, edgeTo) {\n        // Special case: all edges removed\n        if (edgeTo.next === edgeFrom) {\n            this.deleteFace(face);\n            return;\n        }\n        for(let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next){\n            face.remove(edge);\n            this.edges.delete(edge); // delete from PlanarSet of edges and update index\n            if (face.isEmpty()) {\n                this.deleteFace(face); // delete from PlanarSet of faces and update index\n                break;\n            }\n        }\n    }\n    /**\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\n     * When edge is split, new edge created from the start of the edge to the new vertex\n     * and inserted before current edge.\n     * Current edge is trimmed and updated.\n     * Method returns new edge added. If no edge added, it returns edge before vertex\n     * @param {Point} pt Point to be added as a new vertex\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\n     * @returns {Edge}\n     */ addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n        if (shapes[0] === null) return edge.prev;\n        if (shapes[1] === null) return edge;\n        let newEdge = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n        /* Insert first split edge into linked list after edgeBefore */ edge.face.insert(newEdge, edgeBefore);\n        // Remove old edge from edges container and 2d index\n        this.edges.delete(edge);\n        // Insert new edge to the edges container and 2d index\n        this.edges.add(newEdge);\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n        // Add updated edge to the edges container and 2d index\n        this.edges.add(edge);\n        return newEdge;\n    }\n    /**\n     * Merge given edge with next edge and remove vertex between them\n     * @param {Edge} edge\n     */ removeEndVertex(edge) {\n        const edge_next = edge.next;\n        if (edge_next === edge) return;\n        edge.face.merge_with_next_edge(edge);\n        this.edges.delete(edge_next);\n    }\n    /**\n     * Cut polygon with multiline and return a new polygon\n     * @param {Multiline} multiline\n     * @returns {Polygon}\n     */ cut(multiline) {\n        let newPoly = this.clone();\n        // smart intersections\n        let intersections = {\n            int_points1: [],\n            int_points2: [],\n            int_points1_sorted: [],\n            int_points2_sorted: []\n        };\n        // intersect each edge of multiline with each edge of the polygon\n        // and create smart intersections\n        for (let edge1 of multiline.edges)for (let edge2 of newPoly.edges){\n            let ip = $2c7a62d6ab88e4d3$var$intersectEdge2Edge(edge1, edge2);\n            // for each intersection point\n            for (let pt of ip){\n                $2c7a62d6ab88e4d3$var$addToIntPoints(edge1, pt, intersections.int_points1);\n                $2c7a62d6ab88e4d3$var$addToIntPoints(edge2, pt, intersections.int_points2);\n            }\n        }\n        // No intersections - return a copy of the original polygon\n        if (intersections.int_points1.length === 0) return newPoly;\n        // sort smart intersections\n        intersections.int_points1_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points2);\n        // split by intersection points\n        $2c7a62d6ab88e4d3$var$splitByIntersections(multiline, intersections.int_points1_sorted);\n        $2c7a62d6ab88e4d3$var$splitByIntersections(newPoly, intersections.int_points2_sorted);\n        // filter duplicated intersection points\n        $2c7a62d6ab88e4d3$var$filterDuplicatedIntersections(intersections);\n        // sort intersection points again after filtering\n        intersections.int_points1_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points2);\n        // initialize inclusion flags for edges of multiline incident to intersections\n        $2c7a62d6ab88e4d3$var$initializeInclusionFlags(intersections.int_points1);\n        // calculate inclusion flag for edges of multiline incident to intersections\n        $2c7a62d6ab88e4d3$var$calculateInclusionFlags(intersections.int_points1, newPoly);\n        // filter intersections between two edges that got same inclusion flag\n        for (let int_point1 of intersections.int_points1_sorted)if (int_point1.edge_before && int_point1.edge_after && int_point1.edge_before.bv === int_point1.edge_after.bv) {\n            intersections.int_points2[int_point1.id] = -1; // to be filtered out\n            int_point1.id = -1; // to be filtered out\n        }\n        intersections.int_points1 = intersections.int_points1.filter((int_point)=>int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter((int_point)=>int_point.id >= 0);\n        intersections.int_points1.forEach((int_point, index)=>{\n            int_point.id = index;\n        });\n        intersections.int_points2.forEach((int_point, index)=>{\n            int_point.id = index;\n        });\n        // No intersections left after filtering - return a copy of the original polygon\n        if (intersections.int_points1.length === 0) return newPoly;\n        // sort intersection points 3d time after filtering\n        intersections.int_points1_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = $2c7a62d6ab88e4d3$var$getSortedArray(intersections.int_points2);\n        // Add new inner edges between intersection points\n        let int_point1_prev;\n        let int_point1_curr;\n        for(let i = 1; i < intersections.int_points1_sorted.length; i++){\n            int_point1_curr = intersections.int_points1_sorted[i];\n            int_point1_prev = intersections.int_points1_sorted[i - 1];\n            if (int_point1_curr.edge_before && int_point1_curr.edge_before.bv === $2c7a62d6ab88e4d3$export$48ea0cac79c83ca8) {\n                let edgeFrom = int_point1_prev.edge_after;\n                let edgeTo = int_point1_curr.edge_before;\n                let newEdges = multiline.getChain(edgeFrom, edgeTo);\n                $2c7a62d6ab88e4d3$var$insertBetweenIntPoints(intersections.int_points2[int_point1_prev.id], intersections.int_points2[int_point1_curr.id], newEdges);\n                newEdges.forEach((edge)=>newPoly.edges.add(edge));\n                newEdges = newEdges.reverse().map((edge)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge(edge.shape.reverse()));\n                for(let k = 0; k < newEdges.length - 1; k++){\n                    newEdges[k].next = newEdges[k + 1];\n                    newEdges[k + 1].prev = newEdges[k];\n                }\n                $2c7a62d6ab88e4d3$var$insertBetweenIntPoints(intersections.int_points2[int_point1_curr.id], intersections.int_points2[int_point1_prev.id], newEdges);\n                newEdges.forEach((edge)=>newPoly.edges.add(edge));\n            }\n        }\n        // Recreate faces\n        newPoly.recreateFaces();\n        return newPoly;\n    }\n    /**\n     * A special case of cut() function\n     * The return is a polygon cut with line\n     * @param {Line} line - cutting line\n     * @returns {Polygon} newPoly - resulted polygon\n     */ cutWithLine(line) {\n        let multiline = new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29([\n            line\n        ]);\n        return this.cut(multiline);\n    }\n    /**\n     * Returns the first found edge of polygon that contains given point\n     * If point is a vertex, return the edge where the point is an end vertex, not a start one\n     * @param {Point} pt\n     * @returns {Edge}\n     */ findEdgeByPoint(pt) {\n        let edge;\n        for (let face of this.faces){\n            edge = face.findEdgeByPoint(pt);\n            if (edge !== undefined) break;\n        }\n        return edge;\n    }\n    /**\n     * Split polygon into array of polygons, where each polygon is an outer face with all\n     * containing inner faces\n     * @returns {Flatten.Polygon[]}\n     */ splitToIslands() {\n        if (this.isEmpty()) return []; // return empty array if polygon is empty\n        let polygons = this.toArray(); // split into array of one-loop polygons\n        /* Sort polygons by area in descending order */ polygons.sort((polygon1, polygon2)=>polygon2.area() - polygon1.area());\n        /* define orientation of the island by orientation of the first polygon in array */ let orientation = [\n            ...polygons[0].faces\n        ][0].orientation();\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */ let newPolygons = polygons.filter((polygon)=>[\n                ...polygon.faces\n            ][0].orientation() === orientation);\n        for (let polygon of polygons){\n            let face = [\n                ...polygon.faces\n            ][0];\n            if (face.orientation() === orientation) continue; // skip same orientation\n            /* Proceed with opposite orientation */ /* Look if any of island polygons contains tested polygon as a hole */ for (let islandPolygon of newPolygons)if (face.shapes.every((shape)=>islandPolygon.contains(shape))) {\n                islandPolygon.addFace(face.shapes); // add polygon as a hole in islandPolygon\n                break;\n            }\n        }\n        // TODO: assert if not all polygons added into output\n        return newPolygons;\n    }\n    /**\n     * Reverse orientation of all faces to opposite\n     * @returns {Polygon}\n     */ reverse() {\n        for (let face of this.faces)face.reverse();\n        return this;\n    }\n    /**\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\n     * false otherwise\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */ contains(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            let rel = $2c7a62d6ab88e4d3$export$3adad403c78dc9b2(this, shape);\n            return rel === $2c7a62d6ab88e4d3$export$48ea0cac79c83ca8 || rel === $2c7a62d6ab88e4d3$export$a523954c60dca5e4;\n        } else return $2c7a62d6ab88e4d3$var$cover(this, shape);\n    }\n    /**\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\n     * @returns {Number | Segment}\n     */ distanceTo(shape) {\n        // let {Distance} = Flatten;\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.point2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment || shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) {\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [\n                dist,\n                shortest_segment\n            ];\n        }\n        /* this method is bit faster */ if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) {\n            let min_dist_and_segment = [\n                Number.POSITIVE_INFINITY,\n                new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment()\n            ];\n            let dist, shortest_segment;\n            for (let edge of this.edges){\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\n                let min_stop = min_dist_and_segment[0];\n                [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\n                if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist, min_stop)) min_dist_and_segment = [\n                    dist,\n                    shortest_segment\n                ];\n            }\n            return min_dist_and_segment;\n        }\n    }\n    /**\n     * Return array of intersection points between polygon and other shape\n     * @param shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */ intersect(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point) return this.contains(shape) ? [\n            shape\n        ] : [];\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line) return $2c7a62d6ab88e4d3$var$intersectLine2Polygon(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Ray) return $2c7a62d6ab88e4d3$var$intersectRay2Polygon(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle) return $2c7a62d6ab88e4d3$var$intersectCircle2Polygon(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment) return $2c7a62d6ab88e4d3$var$intersectSegment2Polygon(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Arc) return $2c7a62d6ab88e4d3$var$intersectArc2Polygon(shape, this);\n        if (shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon) return $2c7a62d6ab88e4d3$var$intersectPolygon2Polygon(shape, this);\n    }\n    /**\n     * Returns new polygon translated by vector vec\n     * @param {Vector} vec\n     * @returns {Polygon}\n     */ translate(vec) {\n        let newPolygon = new $2c7a62d6ab88e4d3$export$7d31b617c820d435();\n        for (let face of this.faces)newPolygon.addFace(face.shapes.map((shape)=>shape.translate(vec)));\n        return newPolygon;\n    }\n    /**\n     * Return new polygon rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Polygon} - new rotated polygon\n     */ rotate(angle = 0, center = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Point()) {\n        let newPolygon = new $2c7a62d6ab88e4d3$export$7d31b617c820d435();\n        for (let face of this.faces)newPolygon.addFace(face.shapes.map((shape)=>shape.rotate(angle, center)));\n        return newPolygon;\n    }\n    /**\n     * Return new polygon with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Polygon}\n     */ scale(sx, sy) {\n        let newPolygon = new $2c7a62d6ab88e4d3$export$7d31b617c820d435();\n        for (let face of this.faces)newPolygon.addFace(face.shapes.map((shape)=>shape.scale(sx, sy)));\n        return newPolygon;\n    }\n    /**\n     * Return new polygon transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Polygon} - new polygon\n     */ transform(matrix = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Matrix()) {\n        let newPolygon = new $2c7a62d6ab88e4d3$export$7d31b617c820d435();\n        for (let face of this.faces)newPolygon.addFace(face.shapes.map((shape)=>shape.transform(matrix)));\n        return newPolygon;\n    }\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */ toJSON() {\n        return [\n            ...this.faces\n        ].map((face)=>face.toJSON());\n    }\n    /**\n     * Transform all faces into array of polygons\n     * @returns {Flatten.Polygon[]}\n     */ toArray() {\n        return [\n            ...this.faces\n        ].map((face)=>face.toPolygon());\n    }\n    /**\n     * Return string to be assigned to 'd' attribute of <path> element\n     * @returns {*}\n     */ dpath() {\n        return [\n            ...this.faces\n        ].reduce((acc, face)=>acc + face.svg(), \"\");\n    }\n    /**\n     * Return string to draw polygon in svg\n     * @param attrs  - an object with attributes for svg path element\n     * @returns {string}\n     */ svg(attrs = {}) {\n        let svgStr = `\\n<path ${$2c7a62d6ab88e4d3$var$convertToString({\n            fillRule: \"evenodd\",\n            fill: \"lightcyan\",\n            ...attrs\n        })} d=\"`;\n        for (let face of this.faces)svgStr += `\\n${face.svg()}`;\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon = $2c7a62d6ab88e4d3$export$7d31b617c820d435;\n/**\n * Shortcut method to create new polygon\n */ const $2c7a62d6ab88e4d3$export$b7b19aa0ee06c73 = (...args)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Polygon(...args);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.polygon = $2c7a62d6ab88e4d3$export$b7b19aa0ee06c73;\nconst { Circle: $2c7a62d6ab88e4d3$var$Circle, Line: $2c7a62d6ab88e4d3$var$Line, Point: $2c7a62d6ab88e4d3$var$Point, Vector: $2c7a62d6ab88e4d3$var$Vector, Utils: $2c7a62d6ab88e4d3$var$Utils } = $2c7a62d6ab88e4d3$export$2e2bcd8739ae039;\n/**\n * Class Inversion represent operator of inversion in circle\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\n * (where line is considered as a circle with infinite radius) into generalized circles\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\n * http://mathworld.wolfram.com/Inversion.html <br/>\n * @type {Inversion}\n */ class $2c7a62d6ab88e4d3$export$ff40fcfb940069c {\n    /**\n     * Inversion constructor\n     * @param {Circle} inversion_circle inversion circle\n     */ constructor(inversion_circle){\n        this.circle = inversion_circle;\n    }\n    get inversion_circle() {\n        return this.circle;\n    }\n    static inversePoint(inversion_circle, point) {\n        const v = new $2c7a62d6ab88e4d3$var$Vector(inversion_circle.pc, point);\n        const k2 = inversion_circle.r * inversion_circle.r;\n        const len2 = v.dot(v);\n        const reflected_point = $2c7a62d6ab88e4d3$var$Utils.EQ_0(len2) ? new $2c7a62d6ab88e4d3$var$Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) : inversion_circle.pc.translate(v.multiply(k2 / len2));\n        return reflected_point;\n    }\n    static inverseCircle(inversion_circle, circle) {\n        const dist = inversion_circle.pc.distanceTo(circle.pc)[0];\n        if ($2c7a62d6ab88e4d3$var$Utils.EQ(dist, circle.r)) {\n            let d = inversion_circle.r * inversion_circle.r / (2 * circle.r);\n            let v = new $2c7a62d6ab88e4d3$var$Vector(inversion_circle.pc, circle.pc);\n            v = v.normalize();\n            let pt = inversion_circle.pc.translate(v.multiply(d));\n            return new $2c7a62d6ab88e4d3$var$Line(pt, v);\n        } else {\n            /* Taken from http://mathworld.wolfram.com */ let v = new $2c7a62d6ab88e4d3$var$Vector(inversion_circle.pc, circle.pc);\n            let s = inversion_circle.r * inversion_circle.r / (v.dot(v) - circle.r * circle.r);\n            let pc = inversion_circle.pc.translate(v.multiply(s));\n            let r = Math.abs(s) * circle.r;\n            return new $2c7a62d6ab88e4d3$var$Circle(pc, r);\n        }\n    }\n    static inverseLine(inversion_circle, line) {\n        const [dist, shortest_segment] = inversion_circle.pc.distanceTo(line);\n        if ($2c7a62d6ab88e4d3$var$Utils.EQ_0(dist)) return line.clone();\n        else {\n            let r = inversion_circle.r * inversion_circle.r / (2 * dist);\n            let v = new $2c7a62d6ab88e4d3$var$Vector(inversion_circle.pc, shortest_segment.end);\n            v = v.multiply(r / dist);\n            return new $2c7a62d6ab88e4d3$var$Circle(inversion_circle.pc.translate(v), r);\n        }\n    }\n    inverse(shape) {\n        if (shape instanceof $2c7a62d6ab88e4d3$var$Point) return $2c7a62d6ab88e4d3$export$ff40fcfb940069c.inversePoint(this.circle, shape);\n        else if (shape instanceof $2c7a62d6ab88e4d3$var$Circle) return $2c7a62d6ab88e4d3$export$ff40fcfb940069c.inverseCircle(this.circle, shape);\n        else if (shape instanceof $2c7a62d6ab88e4d3$var$Line) return $2c7a62d6ab88e4d3$export$ff40fcfb940069c.inverseLine(this.circle, shape);\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Inversion = $2c7a62d6ab88e4d3$export$ff40fcfb940069c;\n/**\n * Shortcut to create inversion operator\n * @param circle\n * @returns {Inversion}\n */ const $2c7a62d6ab88e4d3$export$2bb0f59743968e2d = (circle)=>new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Inversion(circle);\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.inversion = $2c7a62d6ab88e4d3$export$2bb0f59743968e2d;\nclass $2c7a62d6ab88e4d3$export$3081247862d57e3d {\n    /**\n     * Calculate distance and shortest segment between points\n     * @param pt1\n     * @param pt2\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static point2point(pt1, pt2) {\n        return pt1.distanceTo(pt2);\n    }\n    /**\n     * Calculate distance and shortest segment between point and line\n     * @param pt\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static point2line(pt, line) {\n        let closest_point = pt.projectionOn(line);\n        let vec = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(pt, closest_point);\n        return [\n            vec.length,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pt, closest_point)\n        ];\n    }\n    /**\n     * Calculate distance and shortest segment between point and circle\n     * @param pt\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static point2circle(pt, circle) {\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.EQ_0(dist2center)) return [\n            circle.r,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pt, circle.toArc().start)\n        ];\n        else {\n            let dist = Math.abs(dist2center - circle.r);\n            let v = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(circle.pc, pt).normalize().multiply(circle.r);\n            let closest_point = circle.pc.translate(v);\n            return [\n                dist,\n                new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pt, closest_point)\n            ];\n        }\n    }\n    /**\n     * Calculate distance and shortest segment between point and segment\n     * @param pt\n     * @param segment\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static point2segment(pt, segment) {\n        /* Degenerated case of zero-length segment */ if (segment.start.equalTo(segment.end)) return $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(pt, segment.start);\n        let v_seg = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(segment.start, segment.end);\n        let v_ps2pt = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(segment.start, pt);\n        let v_pe2pt = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Vector(segment.end, pt);\n        let start_sp = v_seg.dot(v_ps2pt);\n        /* dot product v_seg * v_ps2pt */ let end_sp = -v_seg.dot(v_pe2pt);\n        /* minus dot product v_seg * v_pe2pt */ let dist;\n        let closest_point;\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(start_sp, 0) && $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(end_sp, 0)) {\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\n            /* unit vector ||v_unit|| = 1 */ dist = Math.abs(v_unit.cross(v_ps2pt));\n            /* dist = abs(v_unit x v_ps2pt) */ closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\n            return [\n                dist,\n                new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(pt, closest_point)\n            ];\n        } else if (start_sp < 0) return pt.distanceTo(segment.start);\n        else return pt.distanceTo(segment.end);\n    }\n    /**\n     * Calculate distance and shortest segment between point and arc\n     * @param pt\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static point2arc(pt, arc) {\n        let circle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc.pc, arc.r);\n        let dist_and_segment = [];\n        let dist, shortest_segment;\n        [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(pt, circle);\n        if (shortest_segment.end.on(arc)) dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(pt, circle));\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(pt, arc.start));\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(pt, arc.end));\n        $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n    /**\n     * Calculate distance and shortest segment between segment and line\n     * @param seg\n     * @param line\n     * @returns {Number | Segment}\n     */ static segment2line(seg, line) {\n        let ip = seg.intersect(line);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ]; // distance = 0, closest point is the first point\n        let dist_and_segment = [];\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(seg.start, line));\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(seg.end, line));\n        $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n    /**\n     * Calculate distance and shortest segment between two segments\n     * @param seg1\n     * @param seg2\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static segment2segment(seg1, seg2) {\n        let ip = $2c7a62d6ab88e4d3$var$intersectSegment2Segment(seg1, seg2);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ]; // distance = 0, closest point is the first point\n        // Seg1 and seg2 not intersected\n        let dist_and_segment = [];\n        let dist_tmp, shortest_segment_tmp;\n        [dist_tmp, shortest_segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2segment(seg2.start, seg1);\n        dist_and_segment.push([\n            dist_tmp,\n            shortest_segment_tmp.reverse()\n        ]);\n        [dist_tmp, shortest_segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2segment(seg2.end, seg1);\n        dist_and_segment.push([\n            dist_tmp,\n            shortest_segment_tmp.reverse()\n        ]);\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2segment(seg1.start, seg2));\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2segment(seg1.end, seg2));\n        $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n    /**\n     * Calculate distance and shortest segment between segment and circle\n     * @param seg\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static segment2circle(seg, circle) {\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */ let ip = seg.intersect(circle);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ];\n        // No intersection between segment and circle\n        /* Case 2. Distance to projection of center point to line bigger than radius\n         * And projection point belong to segment\n          * Then measure again distance from projection to circle and return it */ let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(seg.ps, seg.pe);\n        let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(circle.center, line);\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) return $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(shortest_segment.end, circle);\n        else {\n            let [dist_from_start, shortest_segment_from_start] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(seg.start, circle);\n            let [dist_from_end, shortest_segment_from_end] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(seg.end, circle);\n            return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist_from_start, dist_from_end) ? [\n                dist_from_start,\n                shortest_segment_from_start\n            ] : [\n                dist_from_end,\n                shortest_segment_from_end\n            ];\n        }\n    }\n    /**\n     * Calculate distance and shortest segment between segment and arc\n     * @param seg\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static segment2arc(seg, arc) {\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */ let ip = seg.intersect(arc);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ];\n        // No intersection between segment and arc\n        let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(seg.ps, seg.pe);\n        let circle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc.pc, arc.r);\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */ let [dist_from_center, shortest_segment_from_center] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(circle.center, line);\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\n            let [dist_from_projection, shortest_segment_from_projection] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) return [\n                dist_from_projection,\n                shortest_segment_from_projection\n            ];\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */ let dist_and_segment = [];\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2arc(seg.start, arc));\n        dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2arc(seg.end, arc));\n        let dist_tmp, segment_tmp;\n        [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2segment(arc.start, seg);\n        dist_and_segment.push([\n            dist_tmp,\n            segment_tmp.reverse()\n        ]);\n        [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2segment(arc.end, seg);\n        dist_and_segment.push([\n            dist_tmp,\n            segment_tmp.reverse()\n        ]);\n        $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle1\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static circle2circle(circle1, circle2) {\n        let ip = circle1.intersect(circle2);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ];\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\n        if (circle1.center.equalTo(circle2.center)) {\n            let arc1 = circle1.toArc();\n            let arc2 = circle2.toArc();\n            return $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(arc1.start, arc2.start);\n        } else {\n            // Case 2. Not concentric circles\n            let line = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Line(circle1.center, circle2.center);\n            let ip1 = line.intersect(circle1);\n            let ip2 = line.intersect(circle2);\n            let dist_and_segment = [];\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(ip1[0], ip2[0]));\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(ip1[0], ip2[1]));\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(ip1[1], ip2[0]));\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(ip1[1], ip2[1]));\n            $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static circle2line(circle, line) {\n        let ip = circle.intersect(line);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ];\n        let [dist_from_center, shortest_segment_from_center] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(circle.center, line);\n        let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(shortest_segment_from_center.end, circle);\n        shortest_segment = shortest_segment.reverse();\n        return [\n            dist,\n            shortest_segment\n        ];\n    }\n    /**\n     * Calculate distance and shortest segment between arc and line\n     * @param arc\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static arc2line(arc, line) {\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */ let ip = line.intersect(arc);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ];\n        let circle = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc.center, arc.r);\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */ let [dist_from_center, shortest_segment_from_center] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(circle.center, line);\n        if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GE(dist_from_center, circle.r)) {\n            let [dist_from_projection, shortest_segment_from_projection] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) return [\n                dist_from_projection,\n                shortest_segment_from_projection\n            ];\n        } else {\n            let dist_and_segment = [];\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(arc.start, line));\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2line(arc.end, line));\n            $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n    /**\n     * Calculate distance and shortest segment between arc and circle\n     * @param arc\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static arc2circle(arc, circle2) {\n        let ip = arc.intersect(circle2);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ];\n        let circle1 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc.center, arc.r);\n        let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc)) return [\n            dist,\n            shortest_segment\n        ];\n        else {\n            let dist_and_segment = [];\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(arc.start, circle2));\n            dist_and_segment.push($2c7a62d6ab88e4d3$export$3081247862d57e3d.point2circle(arc.end, circle2));\n            $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n    /**\n     * Calculate distance and shortest segment between two arcs\n     * @param arc1\n     * @param arc2\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static arc2arc(arc1, arc2) {\n        let ip = arc1.intersect(arc2);\n        if (ip.length > 0) return [\n            0,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment(ip[0], ip[0])\n        ];\n        let circle1 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc1.center, arc1.r);\n        let circle2 = new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Circle(arc2.center, arc2.r);\n        let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) return [\n            dist,\n            shortest_segment\n        ];\n        else {\n            let dist_and_segment = [];\n            let dist_tmp, segment_tmp;\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2arc(arc1.start, arc2);\n            if (segment_tmp.end.on(arc2)) dist_and_segment.push([\n                dist_tmp,\n                segment_tmp\n            ]);\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2arc(arc1.end, arc2);\n            if (segment_tmp.end.on(arc2)) dist_and_segment.push([\n                dist_tmp,\n                segment_tmp\n            ]);\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2arc(arc2.start, arc1);\n            if (segment_tmp.end.on(arc1)) dist_and_segment.push([\n                dist_tmp,\n                segment_tmp.reverse()\n            ]);\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2arc(arc2.end, arc1);\n            if (segment_tmp.end.on(arc1)) dist_and_segment.push([\n                dist_tmp,\n                segment_tmp.reverse()\n            ]);\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(arc1.start, arc2.start);\n            dist_and_segment.push([\n                dist_tmp,\n                segment_tmp\n            ]);\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(arc1.start, arc2.end);\n            dist_and_segment.push([\n                dist_tmp,\n                segment_tmp\n            ]);\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(arc1.end, arc2.start);\n            dist_and_segment.push([\n                dist_tmp,\n                segment_tmp\n            ]);\n            [dist_tmp, segment_tmp] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2point(arc1.end, arc2.end);\n            dist_and_segment.push([\n                dist_tmp,\n                segment_tmp\n            ]);\n            $2c7a62d6ab88e4d3$export$3081247862d57e3d.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n    /**\n     * Calculate distance and shortest segment between point and polygon\n     * @param point\n     * @param polygon\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static point2polygon(point, polygon) {\n        let min_dist_and_segment = [\n            Number.POSITIVE_INFINITY,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment()\n        ];\n        for (let edge of polygon.edges){\n            let [dist, shortest_segment] = edge.shape instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment ? $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2segment(point, edge.shape) : $2c7a62d6ab88e4d3$export$3081247862d57e3d.point2arc(point, edge.shape);\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist, min_dist_and_segment[0])) min_dist_and_segment = [\n                dist,\n                shortest_segment\n            ];\n        }\n        return min_dist_and_segment;\n    }\n    static shape2polygon(shape, polygon) {\n        let min_dist_and_segment = [\n            Number.POSITIVE_INFINITY,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment()\n        ];\n        for (let edge of polygon.edges){\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist, min_dist_and_segment[0])) min_dist_and_segment = [\n                dist,\n                shortest_segment\n            ];\n        }\n        return min_dist_and_segment;\n    }\n    /**\n     * Calculate distance and shortest segment between two polygons\n     * @param polygon1\n     * @param polygon2\n     * @returns {Number | Segment} - distance and shortest segment\n     */ static polygon2polygon(polygon1, polygon2) {\n        let min_dist_and_segment = [\n            Number.POSITIVE_INFINITY,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment()\n        ];\n        for (let edge1 of polygon1.edges)for (let edge2 of polygon2.edges){\n            let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist, min_dist_and_segment[0])) min_dist_and_segment = [\n                dist,\n                shortest_segment\n            ];\n        }\n        return min_dist_and_segment;\n    }\n    /**\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\n     * Minimal distance by x is\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\n     *    0,                       if box1 and box2 are intersected by x\n     * Minimal distance by y is defined in the same way\n     *\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\n     *\n     * @param box1\n     * @param box2\n     * @returns {Number | Number} - minimal and maximal distance\n     */ static box2box_minmax(box1, box2) {\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\n        let box = box1.merge(box2);\n        let dx = box.xmax - box.xmin;\n        let dy = box.ymax - box.ymin;\n        let maxdist = dx * dx + dy * dy;\n        return [\n            mindist,\n            maxdist\n        ];\n    }\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\n        // Calculate minmax distance to each shape in current level\n        // Insert result into the interval tree for further processing\n        // update min_stop with maxdist, it will be the new stop distance\n        let mindist, maxdist;\n        for (let node of level){\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            // if (Flatten.Utils.GT(mindist, min_stop))\n            //     continue;\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\n            [mindist, maxdist] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.box2box_minmax(shape.box, node.item.key);\n            if (node.item.value instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Edge) tree.insert([\n                mindist,\n                maxdist\n            ], node.item.value.shape);\n            else tree.insert([\n                mindist,\n                maxdist\n            ], node.item.value);\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(maxdist, min_stop)) min_stop = maxdist; // this will be the new distance estimation\n        }\n        if (level.length === 0) return min_stop;\n        // Calculate new level from left and right children of the current\n        let new_level_left = level.map((node)=>node.left.isNil() ? undefined : node.left).filter((node)=>node !== undefined);\n        let new_level_right = level.map((node)=>node.right.isNil() ? undefined : node.right).filter((node)=>node !== undefined);\n        // Merge left and right subtrees and leave only relevant subtrees\n        let new_level = [\n            ...new_level_left,\n            ...new_level_right\n        ].filter((node)=>{\n            // Node subtree quick reject, node.max is a subtree box\n            let [mindist, maxdist] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.box2box_minmax(shape.box, node.max);\n            return $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LE(mindist, min_stop);\n        });\n        min_stop = $2c7a62d6ab88e4d3$export$3081247862d57e3d.minmax_tree_process_level(shape, new_level, min_stop, tree);\n        return min_stop;\n    }\n    /**\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\n     * and shapes of the planar set.\n     * @param shape\n     * @param set\n     */ static minmax_tree(shape, set, min_stop) {\n        let tree = new $2c7a62d6ab88e4d3$var$IntervalTree();\n        let level = [\n            set.index.root\n        ];\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\n        squared_min_stop = $2c7a62d6ab88e4d3$export$3081247862d57e3d.minmax_tree_process_level(shape, level, squared_min_stop, tree);\n        return tree;\n    }\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\n        let min_dist_and_segment_new, stop;\n        if (node != null && !node.isNil()) {\n            [min_dist_and_segment_new, stop] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\n            if (stop) return [\n                min_dist_and_segment_new,\n                stop\n            ];\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) return [\n                min_dist_and_segment_new,\n                true\n            ]; // stop condition\n            let [dist, shortest_segment] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.distance(shape, node.item.value);\n            // console.log(dist)\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(dist, min_dist_and_segment_new[0])) min_dist_and_segment_new = [\n                dist,\n                shortest_segment\n            ];\n            [min_dist_and_segment_new, stop] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\n            return [\n                min_dist_and_segment_new,\n                stop\n            ];\n        }\n        return [\n            min_dist_and_segment,\n            false\n        ];\n    }\n    /**\n     * Calculates distance between shape and Planar Set of shapes\n     * @param shape\n     * @param {PlanarSet} set\n     * @param {Number} min_stop\n     * @returns {*}\n     */ static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\n        let min_dist_and_segment = [\n            min_stop,\n            new $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Segment()\n        ];\n        let stop = false;\n        if (set instanceof $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.PlanarSet) {\n            let tree = $2c7a62d6ab88e4d3$export$3081247862d57e3d.minmax_tree(shape, set, min_stop);\n            [min_dist_and_segment, stop] = $2c7a62d6ab88e4d3$export$3081247862d57e3d.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\n        }\n        return min_dist_and_segment;\n    }\n    static sort(dist_and_segment) {\n        dist_and_segment.sort((d1, d2)=>{\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.LT(d1[0], d2[0])) return -1;\n            if ($2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Utils.GT(d1[0], d2[0])) return 1;\n            return 0;\n        });\n    }\n    static distance(shape1, shape2) {\n        return shape1.distanceTo(shape2);\n    }\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Distance = $2c7a62d6ab88e4d3$export$3081247862d57e3d;\n// POINT (30 10)\n// MULTIPOINT (10 40, 40 30, 20 20, 30 10)\n// LINESTRING (30 10, 10 30, 40 40)\n// MULTILINESTRING ((10 10, 20 20, 10 40), (40 40, 30 30, 40 20, 30 10))\n// MULTILINESTRING ((8503.732 4424.547, 8963.747 3964.532), (8963.747 3964.532, 8707.468 3708.253), (8707.468 3708.253, 8247.454 4168.268), (8247.454 4168.268, 8503.732 4424.547))\n// POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10), (20 30, 35 35, 30 20, 20 30))\n// MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)), ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35), (30 20, 20 15, 20 25, 30 20)))\nfunction $2c7a62d6ab88e4d3$var$parseSinglePoint(pointStr) {\n    return new $2c7a62d6ab88e4d3$export$baf26146a414f24a(pointStr.split(\" \").map(Number));\n}\nfunction $2c7a62d6ab88e4d3$var$parseMultiPoint(multipointStr) {\n    return multipointStr.split(\", \").map($2c7a62d6ab88e4d3$var$parseSinglePoint);\n}\nfunction $2c7a62d6ab88e4d3$var$parseLineString(lineStr) {\n    const points = $2c7a62d6ab88e4d3$var$parseMultiPoint(lineStr);\n    let segments = [];\n    for(let i = 0; i < points.length - 1; i++)segments.push(new $2c7a62d6ab88e4d3$export$d53aa5c5ab432700(points[i], points[i + 1]));\n    return new $2c7a62d6ab88e4d3$export$a5433e0f3b1dce29(segments);\n}\nfunction $2c7a62d6ab88e4d3$var$parseMultiLineString(multilineStr) {\n    const lineStrings = multilineStr.replace(/\\(\\(/, \"\").replace(/\\)\\)$/, \"\").split(\"), (\");\n    return lineStrings.map($2c7a62d6ab88e4d3$var$parseLineString);\n}\nfunction $2c7a62d6ab88e4d3$var$parseSinglePolygon(polygonStr) {\n    const facesStr = polygonStr.replace(/\\(\\(/, \"\").replace(/\\)\\)$/, \"\").split(\"), (\");\n    const polygon = new $2c7a62d6ab88e4d3$export$7d31b617c820d435();\n    let orientation;\n    facesStr.forEach((facesStr, idx)=>{\n        let points = facesStr.split(\", \").map((coordStr)=>{\n            return new $2c7a62d6ab88e4d3$export$baf26146a414f24a(coordStr.split(\" \").map(Number));\n        });\n        const face = polygon.addFace(points);\n        if (idx === 0) orientation = face.orientation();\n        else if (face.orientation() === orientation) face.reverse();\n    });\n    return polygon;\n}\nfunction $2c7a62d6ab88e4d3$var$parseMutliPolygon(multiPolygonString) {\n    const polygonStrings = multiPolygonString.split(\"?\");\n    const polygons = polygonStrings.map($2c7a62d6ab88e4d3$var$parseSinglePolygon);\n    const polygon = new $2c7a62d6ab88e4d3$export$7d31b617c820d435();\n    const faces = polygons.reduce((acc, polygon)=>[\n            ...acc,\n            ...polygon?.faces\n        ], []);\n    faces.forEach((face)=>polygon.addFace([\n            ...face?.shapes\n        ]));\n    return polygon;\n}\nfunction $2c7a62d6ab88e4d3$var$parsePolygon(wkt) {\n    if (wkt.startsWith(\"POLYGON\")) {\n        const polygonStr = wkt.replace(/^POLYGON /, \"\");\n        return $2c7a62d6ab88e4d3$var$parseSinglePolygon(polygonStr);\n    } else {\n        const multiPolygonString = wkt.replace(/^MULTIPOLYGON \\(/, \"\").replace(/\\)$/, \"\").replace(/\\)\\), \\(\\(/, \"))?((\");\n        return $2c7a62d6ab88e4d3$var$parseMutliPolygon(multiPolygonString);\n    }\n}\nfunction $2c7a62d6ab88e4d3$var$parseArrayOfPoints(str) {\n    const arr = str.split(\"\\n\").map((x)=>x.match(/\\(([^)]+)\\)/)[1]);\n    return arr.map($2c7a62d6ab88e4d3$var$parseSinglePoint);\n}\nfunction $2c7a62d6ab88e4d3$var$parseArrayOfLineStrings(str) {\n    const arr = str.split(\"\\n\").map((x)=>x.match(/\\(([^)]+)\\)/)[1]);\n    return arr.map($2c7a62d6ab88e4d3$var$parseLineString).reduce((acc, x)=>[\n            ...acc,\n            ...x\n        ], []);\n}\n/**\n * Convert WKT string to array of Flatten shapes.\n * @param str\n * @returns {Point | Point[] | Multiline | Multiline[] | Polygon | Shape[] | null}\n */ function $2c7a62d6ab88e4d3$export$86c11aa368fb2b9f(str) {\n    if (str.startsWith(\"POINT\")) {\n        const pointStr = str.replace(/^POINT \\(/, \"\").replace(/\\)$/, \"\");\n        return $2c7a62d6ab88e4d3$var$parseSinglePoint(pointStr);\n    } else if (str.startsWith(\"MULTIPOINT\")) {\n        const multiPointStr = str.replace(/^MULTIPOINT \\(/, \"\").replace(/\\)$/, \"\");\n        return $2c7a62d6ab88e4d3$var$parseMultiPoint(multiPointStr);\n    } else if (str.startsWith(\"LINESTRING\")) {\n        const lineStr = str.replace(/^LINESTRING \\(/, \"\").replace(/\\)$/, \"\");\n        return $2c7a62d6ab88e4d3$var$parseLineString(lineStr);\n    } else if (str.startsWith(\"MULTILINESTRING\")) {\n        const multilineStr = str.replace(/^MULTILINESTRING /, \"\");\n        return $2c7a62d6ab88e4d3$var$parseMultiLineString(multilineStr);\n    } else if (str.startsWith(\"POLYGON\") || str.startsWith(\"MULTIPOLYGON\")) return $2c7a62d6ab88e4d3$var$parsePolygon(str);\n    else if (str.startsWith(\"GEOMETRYCOLLECTION\")) {\n        const regex = /(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION) \\([^\\)]+\\)/g;\n        const wktArray = str.match(regex);\n        if (wktArray[0].startsWith(\"GEOMETRYCOLLECTION\")) wktArray[0] = wktArray[0].replace(\"GEOMETRYCOLLECTION (\", \"\");\n        const flArray = wktArray.map($2c7a62d6ab88e4d3$export$86c11aa368fb2b9f).map((x)=>x instanceof Array ? x : [\n                x\n            ]);\n        return flArray.reduce((acc, x)=>[\n                ...acc,\n                ...x\n            ], []);\n    } else if ($2c7a62d6ab88e4d3$var$isArrayOfPoints(str)) return $2c7a62d6ab88e4d3$var$parseArrayOfPoints(str);\n    else if ($2c7a62d6ab88e4d3$var$isArrayOfLines(str)) return $2c7a62d6ab88e4d3$var$parseArrayOfLineStrings(str);\n    return [];\n}\nfunction $2c7a62d6ab88e4d3$var$isArrayOfPoints(str) {\n    return str.split(\"\\n\")?.every((str)=>str.includes(\"POINT\"));\n}\nfunction $2c7a62d6ab88e4d3$var$isArrayOfLines(str) {\n    return str.split(\"\\n\")?.every((str)=>str.includes(\"LINESTRING\"));\n}\n/**\n * Return true if given string starts with one of WKT tags and possibly contains WKT string,\n * @param str\n * @returns {boolean}\n */ function $2c7a62d6ab88e4d3$export$20801799df1b655f(str) {\n    return str.startsWith(\"POINT\") || $2c7a62d6ab88e4d3$var$isArrayOfPoints(str) || str.startsWith(\"LINESTRING\") || $2c7a62d6ab88e4d3$var$isArrayOfLines(str) || str.startsWith(\"MULTILINESTRING\") || str.startsWith(\"POLYGON\") || str.startsWith(\"MULTIPOINT\") || str.startsWith(\"MULTIPOLYGON\") || str.startsWith(\"GEOMETRYCOLLECTION\");\n}\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.isWktString = $2c7a62d6ab88e4d3$export$20801799df1b655f;\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.parseWKT = $2c7a62d6ab88e4d3$export$86c11aa368fb2b9f;\n/**\n * Created by Alex Bol on 2/18/2017.\n */ $2c7a62d6ab88e4d3$export$2e2bcd8739ae039.BooleanOperations = $2c7a62d6ab88e4d3$export$7810ed04e2e13fba;\n$2c7a62d6ab88e4d3$export$2e2bcd8739ae039.Relations = $2c7a62d6ab88e4d3$export$932c2897ef8e4e8e;\n\n\nconst { point: $66bd0219ab6a9102$var$point, Polygon: $66bd0219ab6a9102$var$Polygon } = (0, $2c7a62d6ab88e4d3$export$2e2bcd8739ae039);\nconst { subtract: $66bd0219ab6a9102$var$subtract } = (0, $2c7a62d6ab88e4d3$export$2e2bcd8739ae039).BooleanOperations;\nfunction $66bd0219ab6a9102$export$acaf96a27438246b(path0, path1) {\n    let path = [];\n    let points0 = [];\n    let points1 = [];\n    let layers = new Set();\n    for(let i = 3; i <= path0.length; i += 4)points0.push(path0.slice(i - 3, i + 1));\n    for(let i = 3; i <= path1.length; i += 4)points1.push(path1.slice(i - 3, i + 1));\n    points0.sort((a, b)=>a[2] - b[2]);\n    points1.sort((a, b)=>a[2] - b[2]);\n    points0.forEach((point)=>layers.add(point[2]));\n    points1.forEach((point)=>layers.add(point[2]));\n    let shapes = new Array();\n    let total_num_points = 0;\n    for (let layer of layers){\n        let layer_points0 = points0.filter((p)=>p[2] == layer).map((p)=>$66bd0219ab6a9102$var$point([\n                p[0],\n                p[1]\n            ]));\n        let layer_points1 = points1.filter((p)=>p[2] == layer).map((p)=>$66bd0219ab6a9102$var$point([\n                p[0],\n                p[1]\n            ]));\n        let polygon0 = new $66bd0219ab6a9102$var$Polygon(layer_points0);\n        let polygon1 = new $66bd0219ab6a9102$var$Polygon(layer_points1);\n        let thicknesses = new Map(); //store thickness in external data structure\n        for(let i = 0; i < points0.length / 4; i += 4)if (points0[i][2] == layer) thicknesses.set([\n            points0[i][0],\n            points0[i][1]\n        ], points0[i][3]);\n        for(let i = 0; i < points1.length / 4; i += 4)if (points1[i][2] == layer) thicknesses.set([\n            [\n                points1[i][0]\n            ],\n            points1[i][1]\n        ], points1[i][3]);\n        if (polygon1.contains(polygon0)) continue;\n        else {\n            let combinedPolygon = $66bd0219ab6a9102$var$subtract(polygon0, polygon1);\n            let polygonSVG = combinedPolygon.svg(); //convert to svg to rely on flatten-js's even-odd algorithm\n            const shapesString = polygonSVG.match(/(M[^M]+z)/g); //separate svg into just the section containing points\n            let shapeidx = 0;\n            for (let shape of shapesString){\n                let pairs = shape.match(/L-?\\d+(\\.\\d+)?,-?\\d+(\\.\\d+)?/g); //get pairs of points (not starting with M)\n                for (let pair of pairs){\n                    var thickness = thicknesses.has(pair.match(/-?\\d+(\\.\\d+)?/g)); //todo: fix thickness (right now it's defaulting to \"false\" = 0)\n                    if (shapes.length < shapeidx + 1) shapes.push([]);\n                    shapes[shapeidx].push(...pair.match(/-?\\d+(\\.\\d+)?/g).map(parseFloat)); //push each pair as a float to the shapes arr\n                    shapes[shapeidx].push(layer);\n                    shapes[shapeidx].push(thickness);\n                }\n                shapeidx += 1;\n            }\n        }\n    }\n    path = shapes.flat();\n    return path;\n} // window.difference = difference;\n\n\n// /* eslint-disable no-unused-vars */\n// import Flatten from 'https://unpkg.com/@flatten-js/core/dist/main.mjs';\n\nconst { point: $ca82cb4564517254$var$point, Polygon: $ca82cb4564517254$var$Polygon } = (0, $2c7a62d6ab88e4d3$export$2e2bcd8739ae039);\nconst { unify: $ca82cb4564517254$var$unify } = (0, $2c7a62d6ab88e4d3$export$2e2bcd8739ae039).BooleanOperations;\nfunction $ca82cb4564517254$export$971dd5b0dfd021b6(path0, path1, by_layer = true) {\n    let path = [];\n    let points0 = [];\n    let points1 = [];\n    let layers = new Set();\n    for(let i = 3; i <= path0.length; i += 4)points0.push(path0.slice(i - 3, i + 1));\n    for(let i = 3; i <= path1.length; i += 4)points1.push(path1.slice(i - 3, i + 1));\n    points0.sort((a, b)=>a[2] - b[2]);\n    points1.sort((a, b)=>a[2] - b[2]);\n    points0.forEach((point)=>layers.add(point[2]));\n    points1.forEach((point)=>layers.add(point[2]));\n    let shapes = new Array();\n    let total_num_points = 0;\n    for (let layer of layers){\n        let layer_points0 = points0.filter((p)=>p[2] == layer).map((p)=>$ca82cb4564517254$var$point([\n                p[0],\n                p[1]\n            ]));\n        let layer_points1 = points1.filter((p)=>p[2] == layer).map((p)=>$ca82cb4564517254$var$point([\n                p[0],\n                p[1]\n            ]));\n        let polygon0 = new $ca82cb4564517254$var$Polygon(layer_points0);\n        let polygon1 = new $ca82cb4564517254$var$Polygon(layer_points1);\n        let thicknesses = new Map(); //store thickness in external data structure\n        for(let i = 0; i < points0.length; i++)if (points0[i][2] == layer) thicknesses.set([\n            points0[i][0],\n            points0[i][1]\n        ], points0[i][3]);\n        for(let i = 0; i < points1.length / 4; i += 4)if (points1[i][2] == layer) thicknesses.set([\n            [\n                points1[i][0]\n            ],\n            points1[i][1]\n        ], points1[i][3]);\n        console.log([\n            ...thicknesses.entries()\n        ]);\n        //to add: tolerance\n        let combinedPolygon = $ca82cb4564517254$var$unify(polygon0, polygon1);\n        let polygonSVG = combinedPolygon.svg(); //convert to svg to rely on flatten-js's even-odd algorithm\n        const shapesString = polygonSVG.match(/(M[^M]+z)/g); //separate svg into just the section containing points\n        let shapeidx = 0;\n        for (let shape of shapesString){\n            let pairs = shape.match(/L-?\\d+(\\.\\d+)?,-?\\d+(\\.\\d+)?/g); //get pairs of points (not starting with M)\n            for (let pair of pairs){\n                var thickness = thicknesses.has(pair.match(/-?\\d+(\\.\\d+)?/g)); //todo: fix thickness (right now it's defaulting to \"false\" = 0)\n                if (shapes.length < shapeidx + 1) shapes.push([]);\n                if (!by_layer) {\n                    shapes[shapeidx].push(...pair.match(/-?\\d+(\\.\\d+)?/g).map(parseFloat)); //push each pair as a float to the shapes arr\n                    shapes[shapeidx].push(layer);\n                    shapes[shapeidx].push(thickness);\n                } else {\n                    shapes[0].push(...pair.match(/-?\\d+(\\.\\d+)?/g).map(parseFloat));\n                    shapes[0].push(layer);\n                    shapes[0].push(thickness);\n                }\n            }\n            if (by_layer) {\n                shapes[0].push(shapes[0][total_num_points], shapes[0][total_num_points + 1], layer, thickness);\n                let num_points = (pairs.length + 1) * 4;\n                total_num_points += num_points;\n            } else shapeidx += 1;\n        }\n    }\n    path = shapes.flat();\n    return path;\n} // export function unionAll(paths, by_layer = True){\n //   let union_path = new Array();\n //   for(let i = 1; i < paths.length; i++){\n //     let new_path = union(paths[0], paths[i], by_layer);\n //   }\n // }\n // window.union = union;\n\n\n\n\n\n})();\n//# sourceMappingURL=index.js.map\n","import * as functions1D from './coilCAM/function-operators/1D-functions/index.js';\nimport * as functions2D from './coilCAM/function-operators/2D-functions/index.js';\nimport * as complexFunctions from './coilCAM/function-operators/complex-functions/index.js';\n// import * as setup from './coilCAM/setup/index.js';\n\nexport {\n    functions1D,\n    functions2D,\n    complexFunctions\n    // setup\n};","import sinusoidal from \"./Sinusoidal.js\";\nimport linear from \"./Linear.js\";\nimport exponential from \"./Exponential.js\";\nimport square from \"./Square.js\";\nimport staircase from \"./Staircase.js\";\n\nexport {sinusoidal, linear, staircase, square, exponential};","import { setParams1D } from '../function-helpers.js'\n// import {CoilCAM} from \"../../CoilCAM.js\"\n\n// Sinusoidal\nexport function sinusoidal(amplitude, offset, nbPoints, values0, mode) {\n    let values = [];\n    [offset, values0] = setParams1D(\"Sinusoidal\", offset, values0, nbPoints, mode);\n\n    for(let i = 0; i < nbPoints; i++){\n        if(mode == \"additive\" || mode == null){\n            values.push(amplitude * Math.sin((2*Math.PI/period)*i + offset[i]) + values0[i]);\n        } else if(mode == \"multiplicative\"){\n            values.push(amplitude * Math.pow(base, ampExp*i + offset[i]) * (values0[i]));\n        }\n    }\n    console.log(\"SINUSOIDAL VALUES:\", values);\n    return values;\n}\n\nwindow.sinusoidal = sinusoidal;\n","// Helper Functions\nfunction setParams(paramType, value, nbPoints, mode){\n    if (value == null){\n        if(mode == \"multiplicative\" && paramType == \"values\"){\n            return new Array(nbPoints).fill(1);\n        } else return new Array(nbPoints).fill(0);\n    } else if(!Array.isArray(value)){\n        return new Array(nbPoints).fill(value);\n    } else if(value.length == nbPoints){\n        return value;   \n    }\n    return null;\n}\n\nexport function setParams1D(functionType, offset, values0, nbPoints, mode){\n    offset = setParams(\"offset\", offset, nbPoints, mode);\n    values0 = setParams(\"values\", values0, nbPoints, mode);\n\n    if(offset == null){ throw new Error(\"Length of offset in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints); }\n    if(values0 == null){ throw new Error(\"Length of values0 in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints); } \n    return [offset, values0];\n}\n\nexport function setParams2D(functionType, offset0x, offset0y, values0x, values0y, nbPoints, mode){\n    offset0x = setParams(\"offset0x\", offset0x, nbPoints, mode);\n    offset0y = setParams(\"offset0y\", offset0y, nbPoints, mode);\n    values0x = setParams(\"values0x\", values0x, nbPoints, mode);\n    values0y = setParams(\"values0y\", values0y, nbPoints, mode);\n\n    if(offset0x == null){ throw new Error(\"Length of offset in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints); }\n    if(offset0y == null){ throw new Error(\"Length of offset in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints); }\n    if(values0x == null){ throw new Error(\"Length of values0 in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints); } \n    if(values0y == null){ throw new Error(\"Length of values0 in \" + functionType + \" must be 0 or 1 or equal to nbPoints:\" + nbPoints); } \n    \n    \n    return [offset0x, offset0y, values0x, values0y];\n}","import { setParams1D } from '../function-helpers.js'\n\n// Linear\nexport function linear(amplitude, offset, nbPoints, values0, mode) {\n    let values = [];\n    [offset, values0] = setParams1D(\"Linear\", offset, values0, nbPoints, mode);\n\n    for (let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\"){\n            values.push(((amplitude * i) + offset[i]) + values0[i]);\n        } else if (mode == \"multiplicative\"){\n            values.push(((amplitude * i) + offset[i]) * values0[i]);\n        }\n    }\n    return values;\n}\n\nwindow.linear = linear;","import { setParams1D } from '../function-helpers.js'\n\n// Exponential\nexport function exponential(amplitude, base, ampExp, offset, nbPoints, values0, mode){\n    let values = [];\n    [offset, values0] = setParams1D(\"Exponential\", offset, values0, nbPoints, mode);\n\n    for(let i = 0; i < nbPoints; i++){\n        if(mode == \"additive\" || mode == null){\n            values.push(amplitude * Math.pow(base, ampExp*i + offset[i]) + values0[i]);\n        } else if(mode == \"multiplicative\"){\n            values.push(amplitude * Math.pow(base, ampExp*i + offset[i]) * values0[i]);\n        }\n    }\n    return values;\n}\n\nwindow.exponential = exponential;","import { setParams1D } from '../function-helpers.js'\n// import {CoilCAM} from \"../../CoilCAM.js\"\n\n// Square\nexport function square(amplitude, period, offset, bumps, nbPoints, values0, mode){\n    let values = [];\n    [offset, values0] = setParams1D(\"Square\", offset, values0, nbPoints, mode);\n\n    for (let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == null){\n            if (bumps && bumps <= (i + offset[i])%period){\n                values.push((amplitude * 0) + values0[i]);\n            } else {\n                values.push((amplitude * 1) + values0[i]);\n            }\n        } else if (mode == \"multiplicative\"){\n            if (bumps && bumps <= (i + offset[i])%period){\n                values.push((amplitude * 0) * values0[i]);\n            } else {\n                values.push((amplitude * 1) * values0[i]);\n            }\n        }\n    }\n    return values;\n}\n\nwindow.square = square;\n\n","import { setParams1D } from '../function-helpers.js'\n\n// Staircase\nexport function staircase(stepWidth, stepHeight, offset, nbPoints, values0, mode){\n    let values = [];\n    let index = 0;\n    [offset, values0] = setParams1D(\"Staircase\", offset, values0, nbPoints, mode);\n\n    for (let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == null ){\n            if (i % stepWidth == 0 && i != 0){\n                index += stepHeight;\n            }\n            values.push(index + offset[i] + values0[i]);\n        }\n        if (mode == \"multiplicative\"){\n            if (i % stepWidth == 0 && i != 0){\n                index += stepHeight;\n            }\n            values.push((index + offset[i]) * values0[i]);\n        }\n    }\n    return values;\n}\n","import sinusoidal2D from \"./Sinusoidal2D.js\";\nimport linear2D from \"./Linear2D.js\";\n\nexport {sinusoidal2D, linear2D};","import { setParams2D } from '../function-helpers.js'\n\nexport function sinusoidal2D(amplitudeX1, periodX1, amplitudeX2, periodX2, offset0x, offset0y, nbPoints, values0x, values0y, mode) {\n    let pointsX = [];\n    let pointsY = [];\n    [offset0x, offset0y, values0x, values0y] = setParams2D(\"Sinusoidal2D\", offset0x, offset0y, values0x, values0y, nbPoints, mode);\n    \n    for (let i = 0; i < nbPoints; i++) {\n        if (mode == \"additive\" || mode == null) {\n            pointsX.push(amplitudeX1 * Math.cos(2 * Math.PI * i / periodX1 + offset0x[i]) + values0x[i]);\n            pointsY.push(amplitudeX2 * Math.sin(2 * Math.PI * i / periodX2 + offset0y[i]) + values0y[i]);\n        } else if (mode == \"multiplicative\") {\n            pointsX.push(amplitudeX1 * Math.cos(2 * Math.PI * i / periodX1 + offset0x[i]) * values0x[i]);\n            pointsY.push(amplitudeX2 * Math.sin(2 * Math.PI * i / periodX2 + offset0y[i]) * values0y[i]);\n        }\n    }\n    return new Array(pointsX, pointsY);\n}\n\n","import { setParams2D } from '../function-helpers.js'\n\nexport function linear2D(amplitudeX1, offsetX1, amplitudeX2, offsetX2, nbPoints, values0x, values0y, mode){\n    let pointsX = [];\n    let pointsY = [];\n    [offsetX1, offsetX2, values0x, values0y] = setParams2D(\"Linear2D\", offsetX1, offsetX2, values0x, values0y, nbPoints, mode);\n    \n    for (let i = 0; i < nbPoints; i++){\n        if (mode == \"additive\" || mode == \"\"){\n            pointsX.push((amplitudeX1 * i + offsetX1[i]) + values0x[i]);\n            pointsY.push((amplitudeX2 * i + offsetX2[i]) + values0y[i]);\n        } else if (mode == \"multiplicative\"){\n            pointsX.push((amplitudeX1 * i + offsetX1[i]) * values0x[i]);\n            pointsY.push((amplitudeX2 * i + offsetX2[i]) * values0y[i]);\n        }\n    }\n    return new Array(pointsX, pointsY);\n}","import difference from \"./Difference.js\";\nimport union from \"./Union.js\";\n\nexport {difference, union};","// /* eslint-disable no-unused-vars */\n// import Flatten from 'https://unpkg.com/@flatten-js/core/dist/main.mjs';\nimport Flatten from '@flatten-js/core';\nconst {point, Polygon} = Flatten;\nconst {subtract} = Flatten.BooleanOperations;\n\nexport function difference(path0, path1){ //revise\n  let path = [];\n  let points0 = [];\n  let points1 = [];\n  let layers = new Set();\n  for(let i = 3; i <= path0.length; i+=4){\n    points0.push(path0.slice(i-3, i+1))\n  }\n  for(let i = 3; i <= path1.length; i+=4){\n    points1.push(path1.slice(i-3, i+1))\n  }\n  points0.sort((a, b) => a[2] - b[2]);\n  points1.sort((a, b) => a[2] - b[2]);\n  points0.forEach(point => layers.add(point[2]));\n  points1.forEach(point => layers.add(point[2]));\n  let shapes = new Array();\n  let total_num_points = 0;\n\n  for(let layer of layers){\n    let layer_points0 = points0.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n    let layer_points1 = points1.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n    let polygon0 = new Polygon(layer_points0);\n    let polygon1 = new Polygon(layer_points1);\n\n    let thicknesses = new Map(); //store thickness in external data structure\n    for(let i = 0; i < points0.length/4; i+=4){\n      if (points0[i][2] == layer){\n        thicknesses.set([points0[i][0], points0[i][1]], points0[i][3]);\n      }\n    }\n    for(let i = 0; i < points1.length/4; i+=4){\n      if (points1[i][2] == layer){\n        thicknesses.set([[points1[i][0]], points1[i][1]], points1[i][3]);\n      }\n    }\n    \n    if(polygon1.contains(polygon0)){ //skip layer\n      continue;\n    } else{\n      let combinedPolygon = subtract(polygon0, polygon1);\n      let polygonSVG = combinedPolygon.svg(); //convert to svg to rely on flatten-js's even-odd algorithm\n      const shapesString = polygonSVG.match(/(M[^M]+z)/g); //separate svg into just the section containing points\n      let shapeidx = 0;\n\n      for (let shape of shapesString){\n        let pairs = shape.match(/L-?\\d+(\\.\\d+)?,-?\\d+(\\.\\d+)?/g); //get pairs of points (not starting with M)\n        for (let pair of pairs){\n          var thickness = thicknesses.has(pair.match(/-?\\d+(\\.\\d+)?/g)); //todo: fix thickness (right now it's defaulting to \"false\" = 0)\n        \n          if(shapes.length < shapeidx + 1){\n            shapes.push([]);\n          }\n          shapes[shapeidx].push(...pair.match(/-?\\d+(\\.\\d+)?/g).map(parseFloat)); //push each pair as a float to the shapes arr\n          shapes[shapeidx].push(layer);\n          shapes[shapeidx].push(thickness);\n        }\n        shapeidx += 1;\n      }\n    }\n  }\n  path = shapes.flat();\n  return path;\n}\n\n// window.difference = difference;","/**\n * Global constant CCW defines counterclockwise direction of arc\n * @type {boolean}\n */\nconst CCW = true;\n\n/**\n * Global constant CW defines clockwise direction of arc\n * @type {boolean}\n */\nconst CW = false;\n\n/**\n * Defines orientation for face of the polygon: clockwise, counterclockwise\n * or not orientable in the case of self-intersection\n * @type {{CW: number, CCW: number, NOT_ORIENTABLE: number}}\n */\nconst ORIENTATION = {CCW:-1, CW:1, NOT_ORIENTABLE: 0};\n\nconst PIx2 = 2 * Math.PI;\n\nconst INSIDE$2 = 1;\nconst OUTSIDE$1 = 0;\nconst BOUNDARY$1 = 2;\nconst CONTAINS = 3;\nconst INTERLACE = 4;\n\nconst OVERLAP_SAME$1 = 1;\nconst OVERLAP_OPPOSITE$1 = 2;\n\nconst NOT_VERTEX$1 = 0;\nconst START_VERTEX$1 = 1;\nconst END_VERTEX$1 = 2;\n\nvar Constants = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BOUNDARY: BOUNDARY$1,\n    CCW: CCW,\n    CONTAINS: CONTAINS,\n    CW: CW,\n    END_VERTEX: END_VERTEX$1,\n    INSIDE: INSIDE$2,\n    INTERLACE: INTERLACE,\n    NOT_VERTEX: NOT_VERTEX$1,\n    ORIENTATION: ORIENTATION,\n    OUTSIDE: OUTSIDE$1,\n    OVERLAP_OPPOSITE: OVERLAP_OPPOSITE$1,\n    OVERLAP_SAME: OVERLAP_SAME$1,\n    PIx2: PIx2,\n    START_VERTEX: START_VERTEX$1\n});\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n/**\n * Floating point comparison tolerance.\n * Default value is 0.000001 (10e-6)\n * @type {number}\n */\nlet DP_TOL = 0.000001;\n\n/**\n * Set new floating point comparison tolerance\n * @param {number} tolerance\n */\nfunction setTolerance(tolerance) {DP_TOL = tolerance;}\n\n/**\n * Get floating point comparison tolerance\n * @returns {number}\n */\nfunction getTolerance() {return DP_TOL;}\n\nconst DECIMALS = 3;\n\n/**\n * Returns *true* if value comparable to zero\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ_0(x) {\n    return (x < DP_TOL && x > -DP_TOL);\n}\n\n/**\n * Returns *true* if two values are equal up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction EQ(x, y) {\n    return (x - y < DP_TOL && x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction GT(x, y) {\n    return (x - y > DP_TOL);\n}\n\n/**\n * Returns *true* if first argument greater than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @returns {boolean}\n */\nfunction GE(x, y) {\n    return (x - y > -DP_TOL);\n}\n\n/**\n * Returns *true* if first argument less than second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LT(x, y) {\n    return (x - y < -DP_TOL)\n}\n\n/**\n * Returns *true* if first argument less than or equal to second argument up to DP_TOL\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nfunction LE(x, y) {\n    return (x - y < DP_TOL);\n}\n\nvar Utils$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    DECIMALS: DECIMALS,\n    EQ: EQ,\n    EQ_0: EQ_0,\n    GE: GE,\n    GT: GT,\n    LE: LE,\n    LT: LT,\n    getTolerance: getTolerance,\n    setTolerance: setTolerance\n});\n\nlet Flatten = {\n    Utils: Utils$1,\n    Errors: undefined,\n    Matrix: undefined,\n    Planar_set: undefined,\n    Point: undefined,\n    Vector: undefined,\n    Line: undefined,\n    Circle: undefined,\n    Segment: undefined,\n    Arc: undefined,\n    Box: undefined,\n    Edge: undefined,\n    Face: undefined,\n    Ray: undefined,\n    Ray_shooting: undefined,\n    Multiline: undefined,\n    Polygon: undefined,\n    Distance: undefined,\n    Inversion: undefined\n};\n\nfor (let c in Constants) {Flatten[c] = Constants[c];}\n\nObject.defineProperty(Flatten, 'DP_TOL', {\n    get:function(){return getTolerance()}, \n    set:function(value){setTolerance(value);}\n});\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n\n/**\n * Class of system errors\n */\nclass Errors {\n    /**\n     * Throw error ILLEGAL_PARAMETERS when cannot instantiate from given parameter\n     * @returns {ReferenceError}\n     */\n    static get ILLEGAL_PARAMETERS() {\n        return new ReferenceError('Illegal Parameters');\n    }\n\n    /**\n     * Throw error ZERO_DIVISION to catch situation of zero division\n     * @returns {Error}\n     */\n    static get ZERO_DIVISION() {\n        return new Error('Zero division');\n    }\n\n    /**\n     * Error to throw from BooleanOperations module in case when fixBoundaryConflicts not capable to fix it\n     * @returns {Error}\n     */\n    static get UNRESOLVED_BOUNDARY_CONFLICT() {\n        return new Error('Unresolved boundary conflict in boolean operation');\n    }\n\n    /**\n     * Error to throw from LinkedList:testInfiniteLoop static method\n     * in case when circular loop detected in linked list\n     * @returns {Error}\n     */\n    static get INFINITE_LOOP() {\n        return new Error('Infinite loop');\n    }\n\n    static get CANNOT_COMPLETE_BOOLEAN_OPERATION() {\n        return new Error('Cannot complete boolean operation')\n    }\n\n    static get CANNOT_INVOKE_ABSTRACT_METHOD() {\n        return new Error('Abstract method cannot be invoked');\n    }\n\n    static get OPERATION_IS_NOT_SUPPORTED() {\n        return new Error('Operation is not supported')\n    }\n}\n\nFlatten.Errors = Errors;\n\n/**\n * Class implements bidirectional non-circular linked list. <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass LinkedList {\n    constructor(first, last) {\n        this.first = first;\n        this.last = last || this.first;\n    }\n\n    [Symbol.iterator]() {\n        let value = undefined;\n        return {\n            next: () => {\n                value = value ? value.next : this.first;\n                return {value: value, done: value === undefined};\n            }\n        };\n    };\n\n    /**\n     * Return number of elements in the list\n     * @returns {number}\n     */\n    get size() {\n        let counter = 0;\n        for (let edge of this) {\n            counter++;\n        }\n        return counter;\n    }\n\n    /**\n     * Return array of elements from start to end,\n     * If start or end not defined, take first as start, last as end\n     * @returns {Array}\n     */\n    toArray(start=undefined, end=undefined) {\n        let elements = [];\n        let from = start || this.first;\n        let to = end || this.last;\n        let element = from;\n        if (element === undefined) return elements;\n        do {\n            elements.push(element);\n            element = element.next;\n        } while (element !== to.next);\n        return elements;\n    }\n\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    append(element) {\n        if (this.isEmpty()) {\n            this.first = element;\n        } else {\n            element.prev = this.last;\n            this.last.next = element;\n        }\n\n        // update edge to be last\n        this.last = element;\n\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement\n     * @param {LinkedListElement} elementBefore\n     * @returns {LinkedList}\n     */\n    insert(newElement, elementBefore) {\n        if (this.isEmpty()) {\n            this.first = newElement;\n            this.last = newElement;\n        }\n        else if (elementBefore === null || elementBefore === undefined) {\n            newElement.next = this.first;\n            this.first.prev = newElement;\n            this.first = newElement;\n        }\n        else {\n            /* set links to new element */\n            let elementAfter = elementBefore.next;\n            elementBefore.next = newElement;\n            if (elementAfter) elementAfter.prev = newElement;\n\n            /* set links from new element */\n            newElement.prev = elementBefore;\n            newElement.next = elementAfter;\n\n            /* extend list if new element added after the last element */\n            if (this.last === elementBefore)\n                this.last = newElement;\n        }\n        // nullify non-circular links\n        this.last.next = undefined;\n        this.first.prev = undefined;\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element\n     * @returns {LinkedList}\n     */\n    remove(element) {\n        // special case if last edge removed\n        if (element === this.first && element === this.last) {\n            this.first = undefined;\n            this.last = undefined;\n        } else {\n            // update linked list\n            if (element.prev) element.prev.next = element.next;\n            if (element.next) element.next.prev = element.prev;\n            // update first if need\n            if (element === this.first) {\n                this.first = element.next;\n            }\n            // update last if need\n            if (element === this.last) {\n                this.last = element.prev;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Return true if list is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.first === undefined;\n    }\n\n    /**\n     * Throw an error if circular loop detected in the linked list\n     * @param {LinkedListElement} first element to start iteration\n     * @throws {Errors.INFINITE_LOOP}\n     */\n    static testInfiniteLoop(first) {\n        let edge = first;\n        let controlEdge = first;\n        do {\n            if (edge != first && edge === controlEdge) {\n                throw Errors.INFINITE_LOOP;  // new Error(\"Infinite loop\")\n            }\n            edge = edge.next;\n            controlEdge = controlEdge.next.next;\n        } while (edge != first)\n    }\n}\n\nconst defaultAttributes = {\n    stroke: \"black\"\n};\n\nclass SVGAttributes {\n    constructor(args = defaultAttributes) {\n        for(const property in args) {\n            this[property] = args[property];\n        }\n        this.stroke = args.stroke ?? defaultAttributes.stroke;\n    }\n\n    toAttributesString() {\n        return Object.keys(this)\n            .reduce( (acc, key) =>\n                    acc + (this[key] !== undefined ? this.toAttrString(key, this[key]) : \"\")\n            , ``)\n    }\n\n    toAttrString(key, value) {\n        const SVGKey = key === \"className\" ? \"class\" : this.convertCamelToKebabCase(key);\n        return value === null ? `${SVGKey} ` : `${SVGKey}=\"${value.toString()}\" `\n    }\n\n    convertCamelToKebabCase(str) {\n        return str\n            .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)\n            .join('-')\n            .toLowerCase();\n    }\n}\n\nfunction convertToString(attrs) {\n    return new SVGAttributes(attrs).toAttributesString()\n}\n\n/**\n * Class Multiline represent connected path of [edges]{@link Flatten.Edge}, where each edge may be\n * [segment]{@link Flatten.Segment}, [arc]{@link Flatten.Arc}, [line]{@link Flatten.Line} or [ray]{@link Flatten.Ray}\n */\nclass Multiline extends LinkedList {\n    constructor(...args) {\n        super();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                let shapes = args[0];\n                if (shapes.length === 0)\n                    return;\n\n                // TODO: more strict validation:\n                // there may be only one line\n                // only first and last may be rays\n                shapes.every((shape) => {\n                    return shape instanceof Flatten.Segment ||\n                        shape instanceof Flatten.Arc ||\n                        shape instanceof Flatten.Ray ||\n                        shape instanceof Flatten.Line\n                });\n\n                for (let shape of shapes) {\n                    let edge = new Flatten.Edge(shape);\n                    this.append(edge);\n                }\n\n                this.setArcLength();\n            }\n        }\n    }\n\n    /**\n     * (Getter) Return array of edges\n     * @returns {Edge[]}\n     */\n    get edges() {\n        return [...this];\n    }\n\n    /**\n     * (Getter) Return bounding box of the multiline\n     * @returns {Box}\n     */\n    get box() {\n        return this.edges.reduce( (acc,edge) => acc.merge(edge.box), new Flatten.Box() );\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Point[]}\n     */\n    get vertices() {\n        let v = this.edges.map(edge => edge.start);\n        v.push(this.last.end);\n        return v;\n    }\n\n    /**\n     * Return new cloned instance of Multiline\n     * @returns {Multiline}\n     */\n    clone() {\n        return new Multiline(this.toShapes());\n    }\n\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */\n    setArcLength() {\n        for (let edge of this) {\n            this.setOneEdgeArcLength(edge);\n        }\n    }\n\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) {\n            edge.arc_length = 0.0;\n        } else {\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\n        }\n    }\n\n    /**\n     * Split edge and add new vertex, return new edge inserted\n     * @param {Point} pt - point on edge that will be added as new vertex\n     * @param {Edge} edge - edge to split\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n           return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n           return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        this.insert(newEdge, edgeBefore);     // edge.face ?\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        return newEdge;\n    }\n\n    getChain(edgeFrom, edgeTo) {\n        let edges = [];\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n            edges.push(edge);\n        }\n        return edges\n    }\n\n    /**\n     * Split edges of multiline with intersection points and return mutated multiline\n     * @param {Point[]} ip - array of points to be added as new vertices\n     * @returns {Multiline}\n     */\n    split(ip) {\n        for (let pt of ip) {\n            let edge = this.findEdgeByPoint(pt);\n            this.addVertex(pt, edge);\n        }\n        return this;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new multiline translated by vector vec\n     * @param {Vector} vec\n     * @returns {Multiline}\n     */\n    translate(vec) {\n        return new Multiline(this.edges.map( edge => edge.shape.translate(vec)));\n    }\n\n    /**\n     * Return new multiline rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Multiline} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        return new Multiline(this.edges.map( edge => edge.shape.rotate(angle, center) ));\n    }\n\n    /**\n     * Return new multiline transformed using affine transformation matrix\n     * Method does not support unbounded shapes\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Multiline} - new multiline\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Multiline(this.edges.map( edge => edge.shape.transform(matrix)));\n    }\n\n    /**\n     * Transform multiline into array of shapes\n     * @returns {Shape[]}\n     */\n    toShapes() {\n        return this.edges.map(edge => edge.shape.clone())\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Return string to be inserted into 'points' attribute of <polyline> element\n     * @returns {string}\n     */\n    svgPoints() {\n        return this.vertices.map(p => `${p.x},${p.y}`).join(' ')\n    }\n\n    /**\n     * Return string to be assigned to 'd' attribute of <path> element\n     * @returns {*}\n     */\n    dpath() {\n        let dPathStr = `M${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            dPathStr += edge.svg();\n        }\n        return dPathStr\n    }\n\n    /**\n     * Return string to draw multiline in svg\n     * @param attrs  - an object with attributes for svg path element\n     * TODO: support semi-infinite Ray and infinite Line\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let svgStr = `\\n<path ${convertToString({fill: \"none\", ...attrs})} d=\"`;\n        svgStr += `\\nM${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n\nFlatten.Multiline = Multiline;\n\n/**\n * Shortcut function to create multiline\n * @param args\n */\nconst multiline = (...args) => new Flatten.Multiline(...args);\nFlatten.multiline = multiline;\n\n/*\n    Smart intersections describe intersection points that refers to the edges they intersect\n    This function are supposed for internal usage by morphing and relation methods between\n */\n\nfunction addToIntPoints(edge, pt, int_points)\n{\n    let id = int_points.length;\n    let shapes = edge.shape.split(pt);\n\n    // if (shapes.length < 2) return;\n    if (shapes.length === 0) return;     // Point does not belong to edge ?\n\n    let len = 0;\n    if (shapes[0] === null) {   // point incident to edge start vertex\n        len = 0;\n    }\n    else if (shapes[1] === null) {   // point incident to edge end vertex\n        len = edge.shape.length;\n    }\n    else {                             // Edge was split into to edges\n        len = shapes[0].length;\n    }\n\n    let is_vertex = NOT_VERTEX$1;\n    if (EQ(len, 0)) {\n        is_vertex |= START_VERTEX$1;\n    }\n    if (EQ(len, edge.shape.length)) {\n        is_vertex |= END_VERTEX$1;\n    }\n    // Fix intersection point which is end point of the last edge\n    let arc_length;\n    if (len === Infinity) {\n        arc_length = shapes[0].coord(pt);\n    }\n    else {\n        arc_length = (is_vertex & END_VERTEX$1) && edge.next && edge.next.arc_length === 0 ?\n            0 :\n            edge.arc_length + len;\n    }\n\n    int_points.push({\n        id: id,\n        pt: pt,\n        arc_length: arc_length,\n        edge_before: edge,\n        edge_after: undefined,\n        face: edge.face,\n        is_vertex: is_vertex\n    });\n}\n\nfunction sortIntersections(intersections)\n{\n    // augment intersections with new sorted arrays\n    intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n    intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n}\n\nfunction getSortedArray(int_points)\n{\n    let faceMap = new Map;\n    let id = 0;\n    // Create integer id's for faces\n    for (let ip of int_points) {\n        if (!faceMap.has(ip.face)) {\n            faceMap.set(ip.face, id);\n            id++;\n        }\n    }\n    // Augment intersection points with face id's\n    for (let ip of int_points) {\n        ip.faceId = faceMap.get(ip.face);\n    }\n    // Clone and sort\n    let int_points_sorted = int_points.slice().sort(compareFn);\n    return int_points_sorted;\n}\n\nfunction compareFn(ip1, ip2)\n{\n    // compare face id's\n    if (ip1.faceId < ip2.faceId) {\n        return -1;\n    }\n    if (ip1.faceId > ip2.faceId) {\n        return 1;\n    }\n    // same face - compare arc_length\n    if (ip1.arc_length < ip2.arc_length) {\n        return -1;\n    }\n    if (ip1.arc_length > ip2.arc_length) {\n        return 1;\n    }\n    return 0;\n}\n\nfunction filterDuplicatedIntersections(intersections)\n{\n    if (intersections.int_points1.length < 2) return;\n\n    let do_squeeze = false;\n\n    let int_point_ref1;\n    let int_point_ref2;\n    let int_point_cur1;\n    let int_point_cur2;\n    for (let i = 0; i < intersections.int_points1_sorted.length; i++) {\n\n        if (intersections.int_points1_sorted[i].id === -1)\n            continue;\n\n        int_point_ref1 = intersections.int_points1_sorted[i];\n        int_point_ref2 = intersections.int_points2[int_point_ref1.id];\n\n        for (let j=i+1; j < intersections.int_points1_sorted.length; j++) {\n            int_point_cur1 = intersections.int_points1_sorted[j];\n            if (!EQ(int_point_cur1.arc_length, int_point_ref1.arc_length)) {\n                break;\n            }\n            if (int_point_cur1.id === -1)\n                continue;\n            int_point_cur2 = intersections.int_points2[int_point_cur1.id];\n            if (int_point_cur2.id === -1)\n                continue;\n            if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n                int_point_cur1.edge_after === int_point_ref1.edge_after &&\n                int_point_cur2.edge_before === int_point_ref2.edge_before &&\n                int_point_cur2.edge_after === int_point_ref2.edge_after) {\n                int_point_cur1.id = -1;\n                /* to be deleted */\n                int_point_cur2.id = -1;\n                /* to be deleted */\n                do_squeeze = true;\n            }\n        }\n    }\n\n    int_point_ref2 = intersections.int_points2_sorted[0];\n    int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n    for (let i = 1; i < intersections.int_points2_sorted.length; i++) {\n        let int_point_cur2 = intersections.int_points2_sorted[i];\n\n        if (int_point_cur2.id === -1) continue;\n        /* already deleted */\n\n        if (int_point_ref2.id === -1 || /* can't be reference if already deleted */\n            !(EQ(int_point_cur2.arc_length, int_point_ref2.arc_length))) {\n            int_point_ref2 = int_point_cur2;\n            int_point_ref1 = intersections.int_points1[int_point_ref2.id];\n            continue;\n        }\n\n        let int_point_cur1 = intersections.int_points1[int_point_cur2.id];\n        if (int_point_cur1.edge_before === int_point_ref1.edge_before &&\n            int_point_cur1.edge_after === int_point_ref1.edge_after &&\n            int_point_cur2.edge_before === int_point_ref2.edge_before &&\n            int_point_cur2.edge_after === int_point_ref2.edge_after) {\n            int_point_cur1.id = -1;\n            /* to be deleted */\n            int_point_cur2.id = -1;\n            /* to be deleted */\n            do_squeeze = true;\n        }\n    }\n\n    if (do_squeeze) {\n        intersections.int_points1 = intersections.int_points1.filter((int_point) => int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter((int_point) => int_point.id >= 0);\n\n        // update id's\n        intersections.int_points1.forEach((int_point, index) => int_point.id = index);\n        intersections.int_points2.forEach((int_point, index) => int_point.id = index);\n    }\n}\n\nfunction initializeInclusionFlags(int_points)\n{\n    for (let int_point of int_points) {\n        if (int_point.edge_before) {\n            int_point.edge_before.bvStart = undefined;\n            int_point.edge_before.bvEnd = undefined;\n            int_point.edge_before.bv = undefined;\n            int_point.edge_before.overlap = undefined;\n        }\n\n        if (int_point.edge_after) {\n            int_point.edge_after.bvStart = undefined;\n            int_point.edge_after.bvEnd = undefined;\n            int_point.edge_after.bv = undefined;\n            int_point.edge_after.overlap = undefined;\n        }\n    }\n\n    for (let int_point of int_points) {\n        if (int_point.edge_before) int_point.edge_before.bvEnd = BOUNDARY$1;\n        if (int_point.edge_after) int_point.edge_after.bvStart = BOUNDARY$1;\n    }\n}\n\nfunction calculateInclusionFlags(int_points, polygon)\n{\n    for (let int_point of int_points) {\n        if (int_point.edge_before) int_point.edge_before.setInclusion(polygon);\n        if (int_point.edge_after) int_point.edge_after.setInclusion(polygon);\n    }\n}\n\nfunction setOverlappingFlags(intersections)\n{\n    let cur_face = undefined;\n    let first_int_point_in_face_id = undefined;\n    let next_int_point1 = undefined;\n    let num_int_points = intersections.int_points1.length;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = intersections.int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(intersections.int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            intersections.int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(intersections.int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = intersections.int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                intersections.int_points2[next_int_point1_tmp.id].face === intersections.int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        if (!(edge_from1.bv === BOUNDARY$1 && edge_to1.bv === BOUNDARY$1))      // not a boundary chain - skip\n            continue;\n\n        if (edge_from1 !== edge_to1)                    //  one edge chain    TODO: support complex case\n            continue;\n\n        /* Find boundary chain in polygon2 between same intersection points */\n        let cur_int_point2 = intersections.int_points2[cur_int_point1.id];\n        let next_int_point2 = intersections.int_points2[next_int_point1.id];\n\n        let edge_from2 = cur_int_point2.edge_after;\n        let edge_to2 = next_int_point2.edge_before;\n\n        /* if [edge_from2..edge_to2] is not a boundary chain, invert it */\n        /* check also that chain consist of one or two edges */\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2)) {\n            cur_int_point2 = intersections.int_points2[next_int_point1.id];\n            next_int_point2 = intersections.int_points2[cur_int_point1.id];\n\n            edge_from2 = cur_int_point2.edge_after;\n            edge_to2 = next_int_point2.edge_before;\n        }\n\n        if (!(edge_from2.bv === BOUNDARY$1 && edge_to2.bv === BOUNDARY$1 && edge_from2 === edge_to2))\n            continue;                           // not an overlapping chain - skip   TODO: fix boundary conflict\n\n        // Set overlapping flag - one-to-one case\n        edge_from1.setOverlap(edge_from2);\n    }\n}\n\nfunction intPointsPoolCount(int_points, cur_int_point_num, cur_face)\n{\n    let int_point_current;\n    let int_point_next;\n\n    let int_points_pool_num = 1;\n\n    if (int_points.length === 1) return 1;\n\n    int_point_current = int_points[cur_int_point_num];\n\n    for (let i = cur_int_point_num + 1; i < int_points.length; i++) {\n        if (int_point_current.face !== cur_face) {      /* next face started */\n            break;\n        }\n\n        int_point_next = int_points[i];\n\n        if (!(int_point_next.pt.equalTo(int_point_current.pt) &&\n            int_point_next.edge_before === int_point_current.edge_before &&\n            int_point_next.edge_after === int_point_current.edge_after)) {\n            break;         /* next point is different - break and exit */\n        }\n\n        int_points_pool_num++;     /* duplicated intersection point - increase counter */\n    }\n    return int_points_pool_num;\n}\n\nfunction splitByIntersections(polygon, int_points)\n{\n    if (!int_points) return;\n    for (let int_point of int_points) {\n        let edge = int_point.edge_before;\n\n        // recalculate vertex flag: it may be changed after previous split\n        int_point.is_vertex = NOT_VERTEX$1;\n        if (edge.shape.start && edge.shape.start.equalTo(int_point.pt)) {\n            int_point.is_vertex |= START_VERTEX$1;\n        }\n        if (edge.shape.end && edge.shape.end.equalTo(int_point.pt)) {\n            int_point.is_vertex |= END_VERTEX$1;\n        }\n\n        if (int_point.is_vertex & START_VERTEX$1) {    // nothing to split\n            int_point.edge_before = edge.prev;\n            if (edge.prev) {\n                int_point.is_vertex = END_VERTEX$1;   // polygon\n            }\n            continue;\n        }\n        if (int_point.is_vertex & END_VERTEX$1) {    // nothing to split\n            continue;\n        }\n\n        let newEdge = polygon.addVertex(int_point.pt, edge);\n        int_point.edge_before = newEdge;\n    }\n\n    for (let int_point of int_points) {\n        if (int_point.edge_before) {\n            int_point.edge_after = int_point.edge_before.next;\n        }\n        else {\n            if (polygon instanceof Multiline && int_point.is_vertex & START_VERTEX$1) {\n                int_point.edge_after = polygon.first;\n            }\n        }\n    }\n}\n\nfunction insertBetweenIntPoints(int_point1, int_point2, new_edges) {\n    const edge_before = int_point1.edge_before;\n    const edge_after = int_point2.edge_after;\n    const len = new_edges.length;\n    edge_before.next = new_edges[0];\n    new_edges[0].prev = edge_before;\n\n    new_edges[len-1].next = edge_after;\n    edge_after.prev = new_edges[len-1];\n}\n\nvar smart_intersections = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    addToIntPoints: addToIntPoints,\n    calculateInclusionFlags: calculateInclusionFlags,\n    filterDuplicatedIntersections: filterDuplicatedIntersections,\n    getSortedArray: getSortedArray,\n    initializeInclusionFlags: initializeInclusionFlags,\n    insertBetweenIntPoints: insertBetweenIntPoints,\n    intPointsPoolCount: intPointsPoolCount,\n    setOverlappingFlags: setOverlappingFlags,\n    sortIntersections: sortIntersections,\n    splitByIntersections: splitByIntersections\n});\n\n/**\n * Created by Alex Bol on 12/02/2018.\n */\n/**\n * @module BooleanOperations\n */\n\nconst {INSIDE: INSIDE$1, OUTSIDE, BOUNDARY, OVERLAP_SAME, OVERLAP_OPPOSITE} = Constants;\nconst {NOT_VERTEX, START_VERTEX, END_VERTEX} = Constants;\n\nconst BOOLEAN_UNION = 1;\nconst BOOLEAN_INTERSECT = 2;\nconst BOOLEAN_SUBTRACT = 3;\n\n\n/**\n * Unify two polygons polygons and returns new polygon. <br/>\n * Point belongs to the resulted polygon if it belongs to the first OR to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction unify(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_UNION, true);\n    return res_poly;\n}\n\n/**\n * Subtract second polygon from the first and returns new polygon\n * Point belongs to the resulted polygon if it belongs to the first polygon AND NOT to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction subtract(polygon1, polygon2) {\n    let polygon2_tmp = polygon2.clone();\n    let polygon2_reversed = polygon2_tmp.reverse();\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2_reversed, BOOLEAN_SUBTRACT, true);\n    return res_poly;\n}\n\n/**\n * Intersect two polygons and returns new polygon\n * Point belongs to the resulted polygon is it belongs to the first AND to the second polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Polygon}\n */\nfunction intersect$1(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, true);\n    return res_poly;\n}\n\n/**\n * Returns boundary of intersection between two polygons as two arrays of shapes (Segments/Arcs) <br/>\n * The first array are shapes from the first polygon, the second array are shapes from the second\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[][]}\n */\nfunction innerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_INTERSECT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n    let clip_shapes2 = [];\n    for (let face of wrk_poly.faces) {\n        clip_shapes2 = [...clip_shapes2, ...[...face.edges].map(edge => edge.shape)];\n    }\n    return [clip_shapes1, clip_shapes2];\n}\n\n/**\n * Returns boundary of subtraction of the second polygon from first polygon as array of shapes\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Shape[]}\n */\nfunction outerClip(polygon1, polygon2) {\n    let [res_poly, wrk_poly] = booleanOpBinary(polygon1, polygon2, BOOLEAN_SUBTRACT, false);\n\n    let clip_shapes1 = [];\n    for (let face of res_poly.faces) {\n        clip_shapes1 = [...clip_shapes1, ...[...face.edges].map(edge => edge.shape)];\n    }\n\n    return clip_shapes1;\n}\n\n/**\n * Returns intersection points between boundaries of two polygons as two array of points <br/>\n * Points in the first array belong to first polygon, points from the second - to the second.\n * Points in each array are ordered according to the direction of the correspondent polygon\n * @param {Polygon} polygon1 - first operand\n * @param {Polygon} polygon2 - second operand\n * @returns {Point[][]}\n */\nfunction calculateIntersections(polygon1, polygon2) {\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    // sort intersection points again after filtering\n    sortIntersections(intersections);\n\n    let ip_sorted1 = intersections.int_points1_sorted.map( int_point => int_point.pt);\n    let ip_sorted2 = intersections.int_points2_sorted.map( int_point => int_point.pt);\n    return [ip_sorted1, ip_sorted2];\n}\n\nfunction filterNotRelevantEdges(res_poly, wrk_poly, intersections, op) {\n    // keep not intersected faces for further remove and merge\n    let notIntersectedFacesRes = getNotIntersectedFaces(res_poly, intersections.int_points1);\n    let notIntersectedFacesWrk = getNotIntersectedFaces(wrk_poly, intersections.int_points2);\n\n    // calculate inclusion flag for not intersected faces\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesRes, wrk_poly);\n    calcInclusionForNotIntersectedFaces(notIntersectedFacesWrk, res_poly);\n\n    // initialize inclusion flags for edges incident to intersections\n    initializeInclusionFlags(intersections.int_points1);\n    initializeInclusionFlags(intersections.int_points2);\n\n    // calculate inclusion flags only for edges incident to intersections\n    calculateInclusionFlags(intersections.int_points1, wrk_poly);\n    calculateInclusionFlags(intersections.int_points2, res_poly);\n\n    // fix boundary conflicts\n    while (fixBoundaryConflicts(res_poly, wrk_poly, intersections.int_points1, intersections.int_points1_sorted, intersections.int_points2, intersections));\n    // while (fixBoundaryConflicts(wrk_poly, res_poly, intersections.int_points2, intersections.int_points2_sorted, intersections.int_points1, intersections));\n\n    // Set overlapping flags for boundary chains: SAME or OPPOSITE\n    setOverlappingFlags(intersections);\n\n    // remove not relevant chains between intersection points\n    removeNotRelevantChains(res_poly, op, intersections.int_points1_sorted, true);\n    removeNotRelevantChains(wrk_poly, op, intersections.int_points2_sorted, false);\n\n    // remove not relevant not intersected faces from res_polygon and wrk_polygon\n    // if op == UNION, remove faces that are included in wrk_polygon without intersection\n    // if op == INTERSECT, remove faces that are not included into wrk_polygon\n    removeNotRelevantNotIntersectedFaces(res_poly, notIntersectedFacesRes, op, true);\n    removeNotRelevantNotIntersectedFaces(wrk_poly, notIntersectedFacesWrk, op, false);\n}\n\nfunction swapLinksAndRestore(res_poly, wrk_poly, intersections, op) {\n\n    // add edges of wrk_poly into the edge container of res_poly\n    copyWrkToRes(res_poly, wrk_poly, op, intersections.int_points2);\n\n    // swap links from res_poly to wrk_poly and vice versa\n    swapLinks(res_poly, wrk_poly, intersections);\n\n    // remove old faces\n    removeOldFaces(res_poly, intersections.int_points1);\n    removeOldFaces(wrk_poly, intersections.int_points2);\n\n    // restore faces\n    restoreFaces(res_poly, intersections.int_points1, intersections.int_points2);\n    restoreFaces(res_poly, intersections.int_points2, intersections.int_points1);\n\n    // merge relevant not intersected faces from wrk_polygon to res_polygon\n    // mergeRelevantNotIntersectedFaces(res_poly, wrk_poly);\n}\n\n\nfunction booleanOpBinary(polygon1, polygon2, op, restore)\n{\n    let res_poly = polygon1.clone();\n    let wrk_poly = polygon2.clone();\n\n    // get intersection points\n    let intersections = getIntersections(res_poly, wrk_poly);\n\n    // sort intersection points\n    sortIntersections(intersections);\n\n    // split by intersection points\n    splitByIntersections(res_poly, intersections.int_points1_sorted);\n    splitByIntersections(wrk_poly, intersections.int_points2_sorted);\n\n    // filter duplicated intersection points\n    filterDuplicatedIntersections(intersections);\n\n    // sort intersection points again after filtering\n    sortIntersections(intersections);\n\n    // calculate inclusion and remove not relevant edges\n    filterNotRelevantEdges(res_poly, wrk_poly, intersections, op);\n\n    if (restore) {\n        swapLinksAndRestore(res_poly, wrk_poly, intersections, op);\n    }\n\n    return [res_poly, wrk_poly];\n}\n\nfunction getIntersections(polygon1, polygon2)\n{\n    let intersections = {\n        int_points1: [],\n        int_points2: []\n    };\n\n    // calculate intersections\n    for (let edge1 of polygon1.edges) {\n\n        // request edges of polygon2 in the box of edge1\n        let resp = polygon2.edges.search(edge1.box);\n\n        // for each edge2 in response\n        for (let edge2 of resp) {\n\n            // calculate intersections between edge1 and edge2\n            let ip = edge1.shape.intersect(edge2.shape);\n\n            // for each intersection point\n            for (let pt of ip) {\n                addToIntPoints(edge1, pt, intersections.int_points1);\n                addToIntPoints(edge2, pt, intersections.int_points2);\n            }\n        }\n    }\n    return intersections;\n}\n\nfunction getNotIntersectedFaces(poly, int_points)\n{\n    let notIntersected = [];\n    for (let face of poly.faces) {\n        if (!int_points.find((ip) => ip.face === face)) {\n            notIntersected.push(face);\n        }\n    }\n    return notIntersected;\n}\n\nfunction calcInclusionForNotIntersectedFaces(notIntersectedFaces, poly2)\n{\n    for (let face of notIntersectedFaces) {\n        face.first.bv = face.first.bvStart = face.first.bvEnd = undefined;\n        face.first.setInclusion(poly2);\n    }\n}\n\nfunction fixBoundaryConflicts(poly1, poly2, int_points1, int_points1_sorted, int_points2, intersections )\n{\n    let cur_face;\n    let first_int_point_in_face_id;\n    let next_int_point1;\n    let num_int_points = int_points1_sorted.length;\n    let iterate_more = false;\n\n    for (let i = 0; i < num_int_points; i++) {\n        let cur_int_point1 = int_points1_sorted[i];\n\n        // Find boundary chain in the polygon1\n        if (cur_int_point1.face !== cur_face) {                               // next chain started\n            first_int_point_in_face_id = i; // cur_int_point1;\n            cur_face = cur_int_point1.face;\n        }\n\n        // Skip duplicated points with same <x,y> in \"cur_int_point1\" pool\n        let int_points_cur_pool_start = i;\n        let int_points_cur_pool_num = intPointsPoolCount(int_points1_sorted, i, cur_face);\n        let next_int_point_id;\n        if (int_points_cur_pool_start + int_points_cur_pool_num < num_int_points &&\n            int_points1_sorted[int_points_cur_pool_start + int_points_cur_pool_num].face === cur_face) {\n            next_int_point_id = int_points_cur_pool_start + int_points_cur_pool_num;\n        } else {                                         // get first point from the same face\n            next_int_point_id = first_int_point_in_face_id;\n        }\n\n        // From all points with same ,x,y. in 'next_int_point1' pool choose one that\n        // has same face both in res_poly and in wrk_poly\n        let int_points_next_pool_num = intPointsPoolCount(int_points1_sorted, next_int_point_id, cur_face);\n        next_int_point1 = null;\n        for (let j=next_int_point_id; j < next_int_point_id + int_points_next_pool_num; j++) {\n            let next_int_point1_tmp = int_points1_sorted[j];\n            if (next_int_point1_tmp.face === cur_face &&\n                int_points2[next_int_point1_tmp.id].face === int_points2[cur_int_point1.id].face) {\n                next_int_point1 = next_int_point1_tmp;\n                break;\n            }\n        }\n        if (next_int_point1 === null)\n            continue;\n\n        let edge_from1 = cur_int_point1.edge_after;\n        let edge_to1 = next_int_point1.edge_before;\n\n        // Case #1. One of the ends is not boundary - probably tiny edge wrongly marked as boundary\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv != BOUNDARY) {\n            edge_from1.bv = edge_to1.bv;\n            continue;\n        }\n\n        if (edge_from1.bv != BOUNDARY && edge_to1.bv === BOUNDARY) {\n            edge_to1.bv = edge_from1.bv;\n            continue;\n        }\n\n        // Set up all boundary values for middle edges. Need for cases 2 and 3\n        if ( (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) ||\n        (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) ) {\n            let edge_tmp = edge_from1.next;\n            while (edge_tmp != edge_to1) {\n                edge_tmp.bvStart = undefined;\n                edge_tmp.bvEnd = undefined;\n                edge_tmp.bv = undefined;\n                edge_tmp.setInclusion(poly2);\n                edge_tmp = edge_tmp.next;\n            }\n        }\n\n        // Case #2. Both of the ends boundary. Check all the edges in the middle\n        // If some edges in the middle are not boundary then update bv of 'from' and 'to' edges\n        if (edge_from1.bv === BOUNDARY && edge_to1.bv === BOUNDARY && edge_from1 != edge_to1) {\n            let edge_tmp = edge_from1.next;\n            let new_bv;\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bv != BOUNDARY) {\n                    if (new_bv === undefined) {        // first not boundary edge between from and to\n                        new_bv = edge_tmp.bv;\n                    }\n                    else {                            // another not boundary edge between from and to\n                        if (edge_tmp.bv != new_bv) {  // and it has different bv - can't resolve conflict\n                            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n                        }\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            if (new_bv != undefined) {\n                edge_from1.bv = new_bv;\n                edge_to1.bv = new_bv;\n            }\n            continue;         // all middle edges are boundary, proceed with this\n        }\n\n        // Case 3. One of the ends is inner, another is outer\n        if (edge_from1.bv === INSIDE$1 && edge_to1.bv === OUTSIDE  || edge_from1.bv === OUTSIDE && edge_to1.bv === INSIDE$1 ) {\n            let edge_tmp = edge_from1;\n            // Find missing intersection point\n            while (edge_tmp != edge_to1) {\n                if (edge_tmp.bvStart === edge_from1.bv && edge_tmp.bvEnd === edge_to1.bv) {\n                    let [dist, segment] = edge_tmp.shape.distanceTo(poly2);\n                    if (dist < 10*Flatten.DP_TOL) {  // it should be very close\n                        // let pt = edge_tmp.end;\n                        // add to the list of intersections of poly1\n                        addToIntPoints(edge_tmp, segment.ps, int_points1);\n\n                        // split edge_tmp in poly1 if need\n                        let int_point1 = int_points1[int_points1.length-1];\n                        if (int_point1.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point1.edge_after = edge_tmp;\n                            int_point1.edge_before = edge_tmp.prev;\n                            edge_tmp.bvStart = BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else if (int_point1.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point1.edge_after = edge_tmp.next;\n                            edge_tmp.bvEnd = BOUNDARY;\n                            edge_tmp.bv = undefined;\n                            edge_tmp.setInclusion(poly2);\n                        }\n                        else {        // split edge here\n                            let newEdge1 = poly2.addVertex(int_point1.pt, edge_tmp);\n                            int_point1.edge_before = newEdge1;\n                            int_point1.edge_after = newEdge1.next;\n\n                            newEdge1.setInclusion(poly2);\n\n                            newEdge1.next.bvStart = BOUNDARY;\n                            newEdge1.next.bvEnd = undefined;\n                            newEdge1.next.bv = undefined;\n                            newEdge1.next.setInclusion(poly2);\n                        }\n\n                        // add to the list of intersections of poly2\n                        let edge2 = poly2.findEdgeByPoint(segment.pe);\n                        addToIntPoints(edge2, segment.pe, int_points2);\n                        // split edge2 in poly2 if need\n                        let int_point2 = int_points2[int_points2.length-1];\n                        if (int_point2.is_vertex & START_VERTEX) {        // nothing to split\n                            int_point2.edge_after = edge2;\n                            int_point2.edge_before = edge2.prev;\n                        }\n                        else if (int_point2.is_vertex & END_VERTEX) {    // nothing to split\n                            int_point2.edge_after = edge2.next;\n                        }\n                        else {        // split edge here\n                            // first locate int_points that may refer to edge2 as edge.after\n                            // let int_point2_edge_before = int_points2.find( int_point => int_point.edge_before === edge2)\n                            let int_point2_edge_after = int_points2.find( int_point => int_point.edge_after === edge2 );\n\n                            let newEdge2 = poly2.addVertex(int_point2.pt, edge2);\n                            int_point2.edge_before = newEdge2;\n                            int_point2.edge_after = newEdge2.next;\n\n                            if (int_point2_edge_after)\n                                int_point2_edge_after.edge_after = newEdge2;\n\n                            newEdge2.bvStart = undefined;\n                            newEdge2.bvEnd = BOUNDARY;\n                            newEdge2.bv = undefined;\n                            newEdge2.setInclusion(poly1);\n\n                            newEdge2.next.bvStart = BOUNDARY;\n                            newEdge2.next.bvEnd = undefined;\n                            newEdge2.next.bv = undefined;\n                            newEdge2.next.setInclusion(poly1);\n                        }\n\n                        sortIntersections(intersections);\n\n                        iterate_more = true;\n                        break;\n                    }\n                }\n                edge_tmp = edge_tmp.next;\n            }\n\n            // we changed intersections inside loop, have to exit and repair again\n            if (iterate_more)\n                break;\n\n            throw Errors.UNRESOLVED_BOUNDARY_CONFLICT;\n        }\n    }\n\n    return iterate_more;\n}\n\nfunction removeNotRelevantChains(polygon, op, int_points, is_res_polygon)\n{\n    if (!int_points) return;\n    let cur_face = undefined;\n    let first_int_point_in_face_num = undefined;\n    let int_point_current;\n    let int_point_next;\n\n    for (let i = 0; i < int_points.length; i++) {\n        int_point_current = int_points[i];\n\n        if (int_point_current.face !== cur_face) {   // next face started\n            first_int_point_in_face_num = i;\n            cur_face = int_point_current.face;\n        }\n\n        if (cur_face.isEmpty())                // ??\n            continue;\n\n        // Get next int point from the same face that current\n\n        // Count how many duplicated points with same <x,y> in \"points from\" pool ?\n        let int_points_from_pull_start = i;\n        let int_points_from_pull_num = intPointsPoolCount(int_points, i, cur_face);\n        let next_int_point_num;\n        if (int_points_from_pull_start + int_points_from_pull_num < int_points.length &&\n            int_points[int_points_from_pull_start + int_points_from_pull_num].face === int_point_current.face) {\n            next_int_point_num = int_points_from_pull_start + int_points_from_pull_num;\n        } else {                                         // get first point from the same face\n            next_int_point_num = first_int_point_in_face_num;\n        }\n        int_point_next = int_points[next_int_point_num];\n\n        /* Count how many duplicated points with same <x,y> in \"points to\" pull ? */\n        let int_points_to_pull_start = next_int_point_num;\n        let int_points_to_pull_num = intPointsPoolCount(int_points, int_points_to_pull_start, cur_face);\n\n\n        let edge_from = int_point_current.edge_after;\n        let edge_to = int_point_next.edge_before;\n\n        if ((edge_from.bv === INSIDE$1 && edge_to.bv === INSIDE$1 && op === BOOLEAN_UNION) ||\n            (edge_from.bv === OUTSIDE && edge_to.bv === OUTSIDE && op === BOOLEAN_INTERSECT) ||\n            ((edge_from.bv === OUTSIDE || edge_to.bv === OUTSIDE) && op === BOOLEAN_SUBTRACT && !is_res_polygon) ||\n            ((edge_from.bv === INSIDE$1 || edge_to.bv === INSIDE$1) && op === BOOLEAN_SUBTRACT && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_SAME) && is_res_polygon) ||\n            (edge_from.bv === BOUNDARY && edge_to.bv === BOUNDARY && (edge_from.overlap & OVERLAP_OPPOSITE))) {\n\n            polygon.removeChain(cur_face, edge_from, edge_to);\n\n            /* update all points in \"points from\" pull */\n            for (let k = int_points_from_pull_start; k < int_points_from_pull_start + int_points_from_pull_num; k++) {\n                int_points[k].edge_after = undefined;\n            }\n\n            /* update all points in \"points to\" pull */\n            for (let k = int_points_to_pull_start; k < int_points_to_pull_start + int_points_to_pull_num; k++) {\n                int_points[k].edge_before = undefined;\n            }\n        }\n\n        /* skip to the last point in \"points from\" group */\n        i += int_points_from_pull_num - 1;\n    }\n}\nfunction copyWrkToRes(res_polygon, wrk_polygon, op, int_points)\n{\n    for (let face of wrk_polygon.faces) {\n        for (let edge of face) {\n            res_polygon.edges.add(edge);\n        }\n        // If union - add face from wrk_polygon that is not intersected with res_polygon\n        if ( /*(op === BOOLEAN_UNION || op == BOOLEAN_SUBTRACT) &&*/\n            int_points.find((ip) => (ip.face === face)) === undefined) {\n            res_polygon.addFace(face.first, face.last);\n        }\n    }\n}\n\nfunction swapLinks(res_polygon, wrk_polygon, intersections)\n{\n    if (intersections.int_points1.length === 0) return;\n\n    for (let i = 0; i < intersections.int_points1.length; i++) {\n        let int_point1 = intersections.int_points1[i];\n        let int_point2 = intersections.int_points2[i];\n\n        // Simple case - find continuation on the other polygon\n\n        // Process edge from res_polygon\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // swap need\n            if (int_point2.edge_before === undefined && int_point2.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point1.edge_before.next = int_point2.edge_after;\n                int_point2.edge_after.prev = int_point1.edge_before;\n\n                // Fill in missed links in intersection points\n                int_point1.edge_after = int_point2.edge_after;\n                int_point2.edge_before = int_point1.edge_before;\n            }\n        }\n        // Process edge from wrk_polygon\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // swap need\n            if (int_point1.edge_before === undefined && int_point1.edge_after !== undefined) {  // simple case\n                // Connect edges\n                int_point2.edge_before.next = int_point1.edge_after;\n                int_point1.edge_after.prev = int_point2.edge_before;\n\n                // Complete missed links\n                int_point2.edge_after = int_point1.edge_after;\n                int_point1.edge_before = int_point2.edge_before;\n            }\n        }\n\n        // Continuation not found - complex case\n        // Continuation will be found on the same polygon.\n        // It happens when intersection point is actually touching point\n        // Polygon1\n        if (int_point1.edge_before !== undefined && int_point1.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points1_sorted) {\n                if (int_point === int_point1) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point1.pt)) {\n                        // Connect edges\n                        int_point1.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point1.edge_before;\n\n                        // Complete missed links\n                        int_point1.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point1.edge_before;\n                    }\n                }\n            }\n        }\n        // Polygon2\n        if (int_point2.edge_before !== undefined && int_point2.edge_after === undefined) {    // still swap need\n            for (let int_point of intersections.int_points2_sorted) {\n                if (int_point === int_point2) continue;     // skip same\n                if (int_point.edge_before === undefined && int_point.edge_after !== undefined) {\n                    if (int_point.pt.equalTo(int_point2.pt)) {\n                        // Connect edges\n                        int_point2.edge_before.next = int_point.edge_after;\n                        int_point.edge_after.prev = int_point2.edge_before;\n\n                        // Complete missed links\n                        int_point2.edge_after = int_point.edge_after;\n                        int_point.edge_before = int_point2.edge_before;\n                    }\n                }\n            }\n        }\n    }\n    // Sanity check that no dead ends left\n}\n\nfunction removeOldFaces(polygon, int_points)\n{\n    for (let int_point of int_points) {\n        polygon.faces.delete(int_point.face);\n        int_point.face = undefined;\n        if (int_point.edge_before)\n            int_point.edge_before.face = undefined;\n        if (int_point.edge_after)\n            int_point.edge_after.face = undefined;\n    }\n}\n\nfunction restoreFaces(polygon, int_points, other_int_points)\n{\n    // For each intersection point - create new face\n    for (let int_point of int_points) {\n        if (int_point.edge_before === undefined || int_point.edge_after === undefined)  // completely deleted\n            continue;\n        if (int_point.face)            // already restored\n            continue;\n\n        if (int_point.edge_after.face || int_point.edge_before.face)        // Face already created. Possible case in duplicated intersection points\n            continue;\n\n        let first = int_point.edge_after;      // face start\n        let last = int_point.edge_before;      // face end;\n\n        try {\n            LinkedList.testInfiniteLoop(first);    // check and throw error if infinite loop found\n        }\n        catch (error) {\n            throw Errors.CANNOT_COMPLETE_BOOLEAN_OPERATION\n        }\n\n        let face = polygon.addFace(first, last);\n\n        // Mark intersection points from the newly create face\n        // to avoid multiple creation of the same face.\n        // Face was assigned to each edge of new face in addFace function\n        for (let int_point_tmp of int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n        // Mark other intersection points as well\n        for (let int_point_tmp of other_int_points) {\n            if (int_point_tmp.edge_before && int_point_tmp.edge_after &&\n                int_point_tmp.edge_before.face === face && int_point_tmp.edge_after.face === face) {\n                int_point_tmp.face = face;\n            }\n        }\n    }\n}\n\nfunction removeNotRelevantNotIntersectedFaces(polygon, notIntersectedFaces, op, is_res_polygon)\n{\n    for (let face of notIntersectedFaces) {\n        let rel = face.first.bv;\n        if (op === BOOLEAN_UNION && rel === INSIDE$1 ||\n            op === BOOLEAN_SUBTRACT && rel === INSIDE$1 && is_res_polygon ||\n            op === BOOLEAN_SUBTRACT && rel === OUTSIDE && !is_res_polygon ||\n            op === BOOLEAN_INTERSECT && rel === OUTSIDE) {\n\n            polygon.deleteFace(face);\n        }\n    }\n}\n\nvar BooleanOperations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BOOLEAN_INTERSECT: BOOLEAN_INTERSECT,\n    BOOLEAN_SUBTRACT: BOOLEAN_SUBTRACT,\n    BOOLEAN_UNION: BOOLEAN_UNION,\n    calculateIntersections: calculateIntersections,\n    innerClip: innerClip,\n    intersect: intersect$1,\n    outerClip: outerClip,\n    removeNotRelevantChains: removeNotRelevantChains,\n    removeOldFaces: removeOldFaces,\n    restoreFaces: restoreFaces,\n    subtract: subtract,\n    unify: unify\n});\n\n/*\n    Dimensionally extended 9-intersected model\n    See https://en.wikipedia.org/wiki/DE-9IM for more details\n */\n// const DISJOINT = RegExp('FF.FF....');\nconst EQUAL = RegExp('T.F..FFF.|T.F...F..');\nconst INTERSECT = RegExp('T........|.T.......|...T.....|....T....');\nconst TOUCH = RegExp('FT.......|F..T.....|F...T....');\nconst INSIDE = RegExp('T.F..F...');\nconst COVERED = RegExp('T.F..F...|.TF..F...|..FT.F...|..F.TF...');\n\nclass DE9IM {\n    /**\n     * Create new instance of DE9IM matrix\n     */\n    constructor() {\n        /**\n         * Array representing 3x3 intersection matrix\n         * @type {Shape[]}\n         */\n        this.m = new Array(9).fill(undefined);\n    }\n\n    /**\n     * Get Interior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2I() {\n        return this.m[0];\n    }\n\n    /**\n     * Set Interior To Interior intersection\n     * @param geom\n     */\n    set I2I(geom) {\n        this.m[0] = geom;\n    }\n\n    /**\n     * Get Interior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2B() {\n        return this.m[1];\n    }\n\n    /**\n     * Set Interior to Boundary intersection\n     * @param geomc\n     */\n    set I2B(geom) {\n        this.m[1] = geom;\n    }\n\n    /**\n     * Get Interior To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get I2E() {\n        return this.m[2];\n    }\n\n    /**\n     * Set Interior to Exterior intersection\n     * @param geom\n     */\n    set I2E(geom) {\n        this.m[2] = geom;\n    }\n\n    /**\n     * Get Boundary To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2I() {\n        return this.m[3];\n    }\n\n    /**\n     * Set Boundary to Interior intersection\n     * @param geom\n     */\n    set B2I(geom) {\n        this.m[3] = geom;\n    }\n\n    /**\n     * Get Boundary To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2B() {\n        return this.m[4];\n    }\n\n    /**\n     * Set Boundary to Boundary intersection\n     * @param geom\n     */\n    set B2B(geom) {\n        this.m[4] = geom;\n    }\n\n    /**\n     * Get Boundary To Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get B2E() {\n        return this.m[5];\n    }\n\n    /**\n     * Set Boundary to Exterior intersection\n     * @param geom\n     */\n    set B2E(geom) {\n        this.m[5] = geom;\n    }\n\n    /**\n     * Get Exterior To Interior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2I() {\n        return this.m[6];\n    }\n\n    /**\n     * Set Exterior to Interior intersection\n     * @param geom\n     */\n    set E2I(geom) {\n        this.m[6] = geom;\n    }\n\n    /**\n     * Get Exterior To Boundary intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2B() {\n        return this.m[7];\n    }\n\n    /**\n     * Set Exterior to Boundary intersection\n     * @param geom\n     */\n    set E2B(geom) {\n        this.m[7] = geom;\n    }\n\n    /**\n     * Get Exterior to Exterior intersection\n     * @returns {Shape[] | undefined}\n     */\n    get E2E() {\n        return this.m[8];\n    }\n\n    /**\n     * Set Exterior to Exterior intersection\n     * @param geom\n     */\n    set E2E(geom) {\n        this.m[8] = geom;\n    }\n\n    /**\n     * Return de9im matrix as string where<br/>\n     * - intersection is 'T'<br/>\n     * - not intersected is 'F'<br/>\n     * - not relevant is '*'<br/>\n     * For example, string 'FF**FF****' means 'DISJOINT'\n     * @returns {string}\n     */\n    toString() {\n        return this.m.map( e => {\n            if (e instanceof Array && e.length > 0) {\n                return 'T'\n            }\n            else if (e instanceof Array && e.length === 0) {\n                return 'F'\n            }\n            else {\n                return '*'\n            }\n        }).join(\"\")\n    }\n\n    equal() {\n        return EQUAL.test(this.toString());\n    }\n\n    intersect() {\n        return INTERSECT.test(this.toString());\n    }\n\n    touch() {\n        return TOUCH.test(this.toString());\n    }\n\n    inside() {\n        return INSIDE.test(this.toString());\n    }\n\n    covered() {\n        return COVERED.test(this.toString());\n    }\n}\n\n/**\n * Intersection\n *\n * */\n\n\nfunction intersectLine2Line(line1, line2) {\n    let ip = [];\n\n    let [A1, B1, C1] = line1.standard;\n    let [A2, B2, C2] = line2.standard;\n\n    /* Cramer's rule */\n    let det = A1 * B2 - B1 * A2;\n    let detX = C1 * B2 - B1 * C2;\n    let detY = A1 * C2 - C1 * A2;\n\n    if (!Flatten.Utils.EQ_0(det)) {\n        let x, y;\n\n        if (B1 === 0) {        // vertical line x  = C1/A1, where A1 == +1 or -1\n            x = C1/A1;\n            y = detY / det;\n        }\n        else if (B2 === 0) {   // vertical line x = C2/A2, where A2 = +1 or -1\n            x = C2/A2;\n            y = detY / det;\n        }\n        else if (A1 === 0) {   // horizontal line y = C1/B1, where B1 = +1 or -1\n            x = detX / det;\n            y = C1/B1;\n        }\n        else if (A2 === 0) {   // horizontal line y = C2/B2, where B2 = +1 or -1\n            x = detX / det;\n            y = C2/B2;\n        }\n        else {\n            x = detX / det;\n            y = detY / det;\n        }\n\n        ip.push(new Flatten.Point(x, y));\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Circle(line, circle) {\n    let ip = [];\n    let prj = circle.pc.projectionOn(line);            // projection of circle center on a line\n    let dist = circle.pc.distanceTo(prj)[0];           // distance from circle center to projection\n\n    if (Flatten.Utils.EQ(dist, circle.r)) {            // line tangent to circle - return single intersection point\n        ip.push(prj);\n    } else if (Flatten.Utils.LT(dist, circle.r)) {       // return two intersection points\n        let delta = Math.sqrt(circle.r * circle.r - dist * dist);\n        let v_trans, pt;\n\n        v_trans = line.norm.rotate90CCW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n\n        v_trans = line.norm.rotate90CW().multiply(delta);\n        pt = prj.translate(v_trans);\n        ip.push(pt);\n    }\n    return ip;\n}\n\nfunction intersectLine2Box(line, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Line(seg, line);\n        for (let pt of ips_tmp) {\n            if (!ptInIntPoints(pt, ips)) {\n                ips.push(pt);\n            }\n        }\n    }\n    return ips;\n}\n\nfunction intersectLine2Arc(line, arc) {\n    let ip = [];\n\n    if (intersectLine2Box(line, arc.box).length === 0) {\n        return ip;\n    }\n\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectLine2Circle(line, circle);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectSegment2Line(seg, line) {\n    let ip = [];\n\n    // Boundary cases\n    if (seg.ps.on(line)) {\n        ip.push(seg.ps);\n    }\n    // If both ends lay on line, return two intersection points\n    if (seg.pe.on(line) && !seg.isZeroLength()) {\n        ip.push(seg.pe);\n    }\n\n    if (ip.length > 0) {\n        return ip;          // done, intersection found\n    }\n\n    // If zero-length segment and nothing found, return no intersections\n    if (seg.isZeroLength()) {\n        return ip;\n    }\n\n    // Not a boundary case, check if both points are on the same side and\n    // hence there is no intersection\n    if (seg.ps.leftTo(line) && seg.pe.leftTo(line) ||\n        !seg.ps.leftTo(line) && !seg.pe.leftTo(line)) {\n        return ip;\n    }\n\n    // Calculate intersection between lines\n    let line1 = new Flatten.Line(seg.ps, seg.pe);\n    return intersectLine2Line(line1, line);\n}\n\nfunction intersectSegment2Segment(seg1, seg2) {\n    let ip = [];\n\n    // quick reject\n    if (seg1.box.not_intersect(seg2.box)) {\n        return ip;\n    }\n\n    // Special case of seg1 zero length\n    if (seg1.isZeroLength()) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        return ip;\n    }\n\n    // Special case of seg2 zero length\n    if (seg2.isZeroLength()) {\n        if (seg2.ps.on(seg1)) {\n            ip.push(seg2.ps);\n        }\n        return ip;\n    }\n\n    // Neither seg1 nor seg2 is zero length\n    let line1 = new Flatten.Line(seg1.ps, seg1.pe);\n    let line2 = new Flatten.Line(seg2.ps, seg2.pe);\n\n    // Check overlapping between segments in case of incidence\n    // If segments touching, add one point. If overlapping, add two points\n    if (line1.incidentTo(line2)) {\n        if (seg1.ps.on(seg2)) {\n            ip.push(seg1.ps);\n        }\n        if (seg1.pe.on(seg2)) {\n            ip.push(seg1.pe);\n        }\n        if (seg2.ps.on(seg1) && !seg2.ps.equalTo(seg1.ps) && !seg2.ps.equalTo(seg1.pe)) {\n            ip.push(seg2.ps);\n        }\n        if (seg2.pe.on(seg1) && !seg2.pe.equalTo(seg1.ps) && !seg2.pe.equalTo(seg1.pe)) {\n            ip.push(seg2.pe);\n        }\n    } else {                /* not incident - parallel or intersect */\n        // Calculate intersection between lines\n        let new_ip = intersectLine2Line(line1, line2);\n        if (new_ip.length > 0) {\n            if (isPointInSegmentBox(new_ip[0], seg1) && isPointInSegmentBox(new_ip[0], seg2)) {\n                ip.push(new_ip[0]);\n            }\n        }\n    }\n    return ip;\n}\n\nfunction isPointInSegmentBox(point, segment) {\n    const box = segment.box;\n    return Flatten.Utils.LE(point.x, box.xmax) && Flatten.Utils.GE(point.x, box.xmin) &&\n        Flatten.Utils.LE(point.y, box.ymax) && Flatten.Utils.GE(point.y, box.ymin)\n}\n\nfunction intersectSegment2Circle(segment, circle) {\n    let ips = [];\n\n    if (segment.box.not_intersect(circle.box)) {\n        return ips;\n    }\n\n    // Special case of zero length segment\n    if (segment.isZeroLength()) {\n        let [dist, _] = segment.ps.distanceTo(circle.pc);\n        if (Flatten.Utils.EQ(dist, circle.r)) {\n            ips.push(segment.ps);\n        }\n        return ips;\n    }\n\n    // Non zero-length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n\n    let ips_tmp = intersectLine2Circle(line, circle);\n\n    for (let ip of ips_tmp) {\n        if (ip.on(segment)) {\n            ips.push(ip);\n        }\n    }\n\n    return ips;\n}\n\nfunction intersectSegment2Arc(segment, arc) {\n    let ip = [];\n\n    if (segment.box.not_intersect(arc.box)) {\n        return ip;\n    }\n\n    // Special case of zero-length segment\n    if (segment.isZeroLength()) {\n        if (segment.ps.on(arc)) {\n            ip.push(segment.ps);\n        }\n        return ip;\n    }\n\n    // Non-zero length segment\n    let line = new Flatten.Line(segment.ps, segment.pe);\n    let circle = new Flatten.Circle(arc.pc, arc.r);\n\n    let ip_tmp = intersectLine2Circle(line, circle);\n\n    for (let pt of ip_tmp) {\n        if (pt.on(segment) && pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n\n}\n\nfunction intersectSegment2Box(segment, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Segment(seg, segment);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectCircle2Circle(circle1, circle2) {\n    let ip = [];\n\n    if (circle1.box.not_intersect(circle2.box)) {\n        return ip;\n    }\n\n    let vec = new Flatten.Vector(circle1.pc, circle2.pc);\n\n    let r1 = circle1.r;\n    let r2 = circle2.r;\n\n    // Degenerated circle\n    if (Flatten.Utils.EQ_0(r1) || Flatten.Utils.EQ_0(r2))\n        return ip;\n\n    // In case of equal circles return one leftmost point\n    if (Flatten.Utils.EQ_0(vec.x) && Flatten.Utils.EQ_0(vec.y) && Flatten.Utils.EQ(r1, r2)) {\n        ip.push(circle1.pc.translate(-r1, 0));\n        return ip;\n    }\n\n    let dist = circle1.pc.distanceTo(circle2.pc)[0];\n\n    if (Flatten.Utils.GT(dist, r1 + r2))               // circles too far, no intersections\n        return ip;\n\n    if (Flatten.Utils.LT(dist, Math.abs(r1 - r2)))     // one circle is contained within another, no intersections\n        return ip;\n\n    // Normalize vector.\n    vec.x /= dist;\n    vec.y /= dist;\n\n    let pt;\n\n    // Case of touching from outside or from inside - single intersection point\n    // TODO: check this specifically not sure if correct\n    if (Flatten.Utils.EQ(dist, r1 + r2) || Flatten.Utils.EQ(dist, Math.abs(r1 - r2))) {\n        pt = circle1.pc.translate(r1 * vec.x, r1 * vec.y);\n        ip.push(pt);\n        return ip;\n    }\n\n    // Case of two intersection points\n\n    // Distance from first center to center of common chord:\n    //   a = (r1^2 - r2^2 + d^2) / 2d\n    // Separate for better accuracy\n    let a = (r1 * r1) / (2 * dist) - (r2 * r2) / (2 * dist) + dist / 2;\n\n    let mid_pt = circle1.pc.translate(a * vec.x, a * vec.y);\n    let h = Math.sqrt(r1 * r1 - a * a);\n    // let norm;\n\n    // norm = vec.rotate90CCW().multiply(h);\n    pt = mid_pt.translate(vec.rotate90CCW().multiply(h));\n    ip.push(pt);\n\n    // norm = vec.rotate90CW();\n    pt = mid_pt.translate(vec.rotate90CW().multiply(h));\n    ip.push(pt);\n\n    return ip;\n}\n\nfunction intersectCircle2Box(circle, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Circle(seg, circle);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectArc2Arc(arc1, arc2) {\n    let ip = [];\n\n    if (arc1.box.not_intersect(arc2.box)) {\n        return ip;\n    }\n\n    // Special case: overlapping arcs\n    // May return up to 4 intersection points\n    if (arc1.pc.equalTo(arc2.pc) && Flatten.Utils.EQ(arc1.r, arc2.r)) {\n        let pt;\n\n        pt = arc1.start;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc1.end;\n        if (pt.on(arc2))\n            ip.push(pt);\n\n        pt = arc2.start;\n        if (pt.on(arc1)) ip.push(pt);\n\n        pt = arc2.end;\n        if (pt.on(arc1)) ip.push(pt);\n\n        return ip;\n    }\n\n    // Common case\n    let circle1 = new Flatten.Circle(arc1.pc, arc1.r);\n    let circle2 = new Flatten.Circle(arc2.pc, arc2.r);\n    let ip_tmp = circle1.intersect(circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc1) && pt.on(arc2)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Circle(arc, circle) {\n    let ip = [];\n\n    if (arc.box.not_intersect(circle.box)) {\n        return ip;\n    }\n\n    // Case when arc center incident to circle center\n    // Return arc's end points as 2 intersection points\n    if (circle.pc.equalTo(arc.pc) && Flatten.Utils.EQ(circle.r, arc.r)) {\n        ip.push(arc.start);\n        ip.push(arc.end);\n        return ip;\n    }\n\n    // Common case\n    let circle1 = circle;\n    let circle2 = new Flatten.Circle(arc.pc, arc.r);\n    let ip_tmp = intersectCircle2Circle(circle1, circle2);\n    for (let pt of ip_tmp) {\n        if (pt.on(arc)) {\n            ip.push(pt);\n        }\n    }\n    return ip;\n}\n\nfunction intersectArc2Box(arc, box) {\n    let ips = [];\n    for (let seg of box.toSegments()) {\n        let ips_tmp = intersectSegment2Arc(seg, arc);\n        for (let ip of ips_tmp) {\n            ips.push(ip);\n        }\n    }\n    return ips;\n}\n\nfunction intersectEdge2Segment(edge, segment) {\n    return edge.isSegment ? intersectSegment2Segment(edge.shape, segment) : intersectSegment2Arc(segment, edge.shape);\n}\n\nfunction intersectEdge2Arc(edge, arc) {\n    return edge.isSegment ? intersectSegment2Arc(edge.shape, arc) : intersectArc2Arc(edge.shape, arc);\n}\n\nfunction intersectEdge2Line(edge, line) {\n    return edge.isSegment ? intersectSegment2Line(edge.shape, line) : intersectLine2Arc(line, edge.shape);\n}\n\nfunction intersectEdge2Ray(edge, ray) {\n    return edge.isSegment ? intersectRay2Segment(ray, edge.shape) : intersectRay2Arc(ray, edge.shape);\n}\n\nfunction intersectEdge2Circle(edge, circle) {\n    return edge.isSegment ? intersectSegment2Circle(edge.shape, circle) : intersectArc2Circle(edge.shape, circle);\n}\n\nfunction intersectSegment2Polygon(segment, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Segment(edge, segment)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectArc2Polygon(arc, polygon) {\n    let ip = [];\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Arc(edge, arc)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectLine2Polygon(line, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Line(edge, line)) {\n            if (!ptInIntPoints(pt, ip)) {\n                ip.push(pt);\n            }\n        }\n    }\n\n    return line.sortPoints(ip);\n}\n\nfunction intersectCircle2Polygon(circle, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty()) {\n        return ip;\n    }\n\n    for (let edge of polygon.edges) {\n        for (let pt of intersectEdge2Circle(edge, circle)) {\n            ip.push(pt);\n        }\n    }\n\n    return ip;\n}\n\nfunction intersectEdge2Edge(edge1, edge2) {\n    if (edge1.isSegment) {\n        return intersectEdge2Segment(edge2, edge1.shape)\n    }\n    else if (edge1.isArc) {\n        return intersectEdge2Arc(edge2, edge1.shape)\n    }\n    else if (edge1.isLine) {\n        return intersectEdge2Line(edge2, edge1.shape)\n    }\n    else if (edge1.isRay) {\n        return intersectEdge2Ray(edge2, edge1.shape)\n    }\n    return []\n}\n\nfunction intersectEdge2Polygon(edge, polygon) {\n    let ip = [];\n\n    if (polygon.isEmpty() || edge.shape.box.not_intersect(polygon.box)) {\n        return ip;\n    }\n\n    let resp_edges = polygon.edges.search(edge.shape.box);\n\n    for (let resp_edge of resp_edges) {\n        ip = [...ip, ...intersectEdge2Edge(edge, resp_edge)];\n    }\n\n    return ip;\n}\n\nfunction intersectPolygon2Polygon(polygon1, polygon2) {\n    let ip = [];\n\n    if (polygon1.isEmpty() || polygon2.isEmpty()) {\n        return ip;\n    }\n\n    if (polygon1.box.not_intersect(polygon2.box)) {\n        return ip;\n    }\n\n    for (let edge1 of polygon1.edges) {\n        ip = [...ip, ...intersectEdge2Polygon(edge1, polygon2)];\n    }\n\n    return ip;\n}\n\nfunction intersectShape2Polygon(shape, polygon) {\n    if (shape instanceof Flatten.Line) {\n        return intersectLine2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Segment) {\n        return intersectSegment2Polygon(shape, polygon);\n    }\n    else if (shape instanceof Flatten.Arc) {\n        return intersectArc2Polygon(shape, polygon);\n    }\n    else {\n        return [];\n    }\n}\n\nfunction ptInIntPoints(new_pt, ip) {\n    return ip.some( pt => pt.equalTo(new_pt) )\n}\n\nfunction createLineFromRay(ray) {\n    return new Flatten.Line(ray.start, ray.norm)\n}\nfunction intersectRay2Segment(ray, segment) {\n    return intersectSegment2Line(segment, createLineFromRay(ray))\n        .filter(pt => ray.contains(pt));\n}\n\nfunction intersectRay2Arc(ray, arc) {\n    return intersectLine2Arc(createLineFromRay(ray), arc)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Circle(ray, circle) {\n    return intersectLine2Circle(createLineFromRay(ray), circle)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Box(ray, box) {\n    return intersectLine2Box(createLineFromRay(ray), box)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Line(ray, line) {\n    return intersectLine2Line(createLineFromRay(ray), line)\n        .filter(pt => ray.contains(pt))\n}\n\nfunction intersectRay2Ray(ray1, ray2) {\n    return intersectLine2Line(createLineFromRay(ray1), createLineFromRay(ray2))\n        .filter(pt => ray1.contains(pt))\n        .filter(pt => ray2.contains(pt))\n}\n\nfunction intersectRay2Polygon(ray, polygon) {\n    return intersectLine2Polygon(createLineFromRay(ray), polygon)\n        .filter(pt => ray.contains(pt))\n}\n\n/**\n * @module RayShoot\n */\n/**\n * Implements ray shooting algorithm. Returns relation between point and polygon: inside, outside or boundary\n * @param {Polygon} polygon - polygon to test\n * @param {Point} point - point to test\n * @returns {INSIDE|OUTSIDE|BOUNDARY}\n */\nfunction ray_shoot(polygon, point) {\n    let contains = undefined;\n\n    // 1. Quick reject\n    // if (polygon.box.not_intersect(point.box)) {\n    //     return Flatten.OUTSIDE;\n    // }\n\n    let ray = new Flatten.Ray(point);\n    let line = new Flatten.Line(ray.pt, ray.norm);\n\n    // 2. Locate relevant edges of the polygon\n    const searchBox = new Flatten.Box(\n        ray.box.xmin-Flatten.DP_TOL, ray.box.ymin-Flatten.DP_TOL,\n        ray.box.xmax, ray.box.ymax+Flatten.DP_TOL\n    );\n\n    if (polygon.box.not_intersect(searchBox)) {\n        return Flatten.OUTSIDE;\n    }\n\n    let resp_edges = polygon.edges.search(searchBox);\n\n    if (resp_edges.length === 0) {\n        return Flatten.OUTSIDE;\n    }\n\n    // 2.5 Check if boundary\n    for (let edge of resp_edges) {\n        if (edge.shape.contains(point)) {\n            return Flatten.BOUNDARY;\n        }\n    }\n\n    let faces = [...polygon.faces];\n\n    // 3. Calculate intersections\n    let intersections = [];\n    for (let edge of resp_edges) {\n        for (let ip of ray.intersect(edge.shape)) {\n\n            // If intersection is equal to query point then point lays on boundary\n            if (ip.equalTo(point)) {\n                return Flatten.BOUNDARY;\n            }\n\n            intersections.push({\n                pt: ip,\n                edge: edge,\n                face_index: faces.indexOf(edge.face)\n            });\n        }\n    }\n\n    // 4. Sort intersection in x-ascending order\n    intersections.sort((i1, i2) => {\n        if (LT(i1.pt.x, i2.pt.x)) {\n            return -1;\n        }\n        if (GT(i1.pt.x, i2.pt.x)) {\n            return 1;\n        }\n        if (i1.face_index < i2.face_index) {\n            return -1\n        }\n        if (i1.face_index > i2.face_index) {\n            return 1\n        }\n        if (i1.edge.arc_length < i2.edge.arc_length) {\n            return -1\n        }\n        if (i1.edge.arc_length > i2.edge.arc_length) {\n            return 1\n        }\n        return 0;\n    });\n\n    // 5. Count real intersections, exclude touching\n    let counter = 0;\n\n    for (let i = 0; i < intersections.length; i++) {\n        let intersection = intersections[i];\n\n        if (intersection.pt.equalTo(intersection.edge.shape.start)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.face_index === intersections[i - 1].face_index &&\n                intersection.edge.prev === intersections[i - 1].edge) {\n                continue;\n            }\n\n            let prev_edge = intersection.edge.prev;\n            while (EQ_0(prev_edge.length)) {\n                prev_edge = prev_edge.prev;\n            }\n            let prev_tangent = prev_edge.shape.tangentInEnd();\n            let prev_point = intersection.pt.translate(prev_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInStart();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let prev_on_the_left = prev_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((prev_on_the_left && !cur_on_the_left) || (!prev_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else if (intersection.pt.equalTo(intersection.edge.shape.end)) {\n            /* skip same point between same edges if already counted */\n            if (i > 0 && intersection.pt.equalTo(intersections[i - 1].pt) &&\n                intersection.face_index === intersections[i-1].face_index &&\n                intersection.edge.next === intersections[i - 1].edge) {\n                continue;\n            }\n\n            let next_edge = intersection.edge.next;\n            while (EQ_0(next_edge.length)) {\n                next_edge = next_edge.next;\n            }\n            let next_tangent = next_edge.shape.tangentInStart();\n            let next_point = intersection.pt.translate(next_tangent);\n\n            let cur_tangent = intersection.edge.shape.tangentInEnd();\n            let cur_point = intersection.pt.translate(cur_tangent);\n\n            let next_on_the_left = next_point.leftTo(line);\n            let cur_on_the_left = cur_point.leftTo(line);\n\n            if ((next_on_the_left && !cur_on_the_left) || (!next_on_the_left && cur_on_the_left)) {\n                counter++;\n            }\n        } else {        /* intersection point is not a vertex */\n            if (intersection.edge.shape instanceof Flatten.Segment) {\n                counter++;\n            } else {\n                /* Check if ray does not touch the curve in the extremal (top or bottom) point */\n                let box = intersection.edge.shape.box;\n                if (!(EQ(intersection.pt.y, box.ymin) ||\n                    EQ(intersection.pt.y, box.ymax))) {\n                    counter++;\n                }\n            }\n        }\n    }\n\n    // 6. Odd or even?\n    contains = counter % 2 === 1 ? INSIDE$2 : OUTSIDE$1;\n    return contains;\n}\n\n/*\n    Calculate relationship between two shapes and return result in the form of\n    Dimensionally Extended nine-Intersection Matrix (https://en.wikipedia.org/wiki/DE-9IM)\n */\n\n\n/**\n * Returns true if shapes are topologically equal:  their interiors intersect and\n * no part of the interior or boundary of one geometry intersects the exterior of the other\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction equal(shape1, shape2) {\n    return relate(shape1, shape2).equal();\n}\n\n/**\n * Returns true if shapes have at least one point in common, same as \"not disjoint\"\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction intersect(shape1, shape2) {\n    return relate(shape1, shape2).intersect();\n}\n\n/**\n * Returns true if shapes have at least one point in common, but their interiors do not intersect\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction touch(shape1, shape2) {\n    return relate(shape1, shape2).touch();\n}\n\n/**\n * Returns true if shapes have no points in common neither in interior nor in boundary\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction disjoint(shape1, shape2) {\n    return !intersect(shape1, shape2);\n}\n\n/**\n * Returns true shape1 lies in the interior of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction inside(shape1, shape2) {\n    return relate(shape1, shape2).inside();\n}\n\n/**\n * Returns true if every point in shape1 lies in the interior or on the boundary of shape2\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction covered(shape1, shape2) {\n    return  relate(shape1, shape2).covered();\n}\n\n/**\n * Returns true shape1's interior contains shape2 <br/>\n * Same as inside(shape2, shape1)\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction contain(shape1, shape2) {\n    return inside(shape2, shape1);\n}\n\n/**\n * Returns true shape1's cover shape2, same as shape2 covered by shape1\n * @param shape1\n * @param shape2\n * @returns {boolean}\n */\nfunction cover(shape1, shape2) {\n    return covered(shape2, shape1);\n}\n\n/**\n * Returns relation between two shapes as intersection 3x3 matrix, where each\n * element contains relevant intersection as array of shapes.\n * If there is no intersection, element contains empty array\n * If intersection is irrelevant it left undefined. (For example, intersection\n * between two exteriors is usually irrelevant)\n * @param shape1\n * @param shape2\n * @returns {DE9IM}\n */\nfunction relate(shape1, shape2) {\n    if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Line) {\n        return relateLine2Line(shape1,  shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Circle) {\n        return relateLine2Circle(shape1, shape2);\n    }\n    else if (shape1 instanceof Flatten.Line && shape2 instanceof Flatten.Box) {\n        return relateLine2Box(shape1, shape2);\n    }\n    else if ( shape1 instanceof Flatten.Line  && shape2 instanceof Flatten.Polygon) {\n        return relateLine2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  && shape2 instanceof Flatten.Polygon) {\n        return relateShape2Polygon(shape1, shape2);\n    }\n    else if ( (shape1 instanceof Flatten.Segment || shape1 instanceof Flatten.Arc)  &&\n        (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box) ) {\n        return relateShape2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n    else if (shape1 instanceof Flatten.Polygon && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(shape1, shape2);\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) &&\n        (shape2 instanceof  Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), new Flatten.Polygon(shape2));\n    }\n    else if ((shape1 instanceof Flatten.Circle || shape1 instanceof Flatten.Box) && shape2 instanceof Flatten.Polygon) {\n        return relatePolygon2Polygon(new Flatten.Polygon(shape1), shape2);\n    }\n    else if (shape1 instanceof Flatten.Polygon && (shape2 instanceof Flatten.Circle || shape2 instanceof Flatten.Box)) {\n        return relatePolygon2Polygon(shape1, new Flatten.Polygon(shape2));\n    }\n}\n\nfunction relateLine2Line(line1, line2) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Line(line1, line2);\n    if (ip.length === 0) {       // parallel or equal ?\n        if (line1.contains(line2.pt) && line2.contains(line1.pt)) {\n            denim.I2I = [line1];   // equal  'T.F...F..'  - no boundary\n            denim.I2E = [];\n            denim.E2I = [];\n        }\n        else {                     // parallel - disjoint 'FFTFF*T**'\n            denim.I2I = [];\n            denim.I2E = [line1];\n            denim.E2I = [line2];\n        }\n    }\n    else {                       // intersect   'T********'\n        denim.I2I = ip;\n        denim.I2E = line1.split(ip);\n        denim.E2I = line2.split(ip);\n    }\n    return denim;\n}\n\nfunction relateLine2Circle(line,circle) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Circle(line, circle);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n        denim.E2I = [circle];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [circle];\n    }\n    else {       // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        denim.I2I = [splitShapes[1]];\n        denim.I2B = ip_sorted;\n        denim.I2E = [splitShapes[0], splitShapes[2]];\n\n        denim.E2I = new Flatten.Polygon([circle.toArc()]).cutWithLine(line);\n    }\n\n    return denim;\n}\n\nfunction relateLine2Box(line, box) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Box(line, box);\n    if (ip.length === 0) {\n        denim.I2I = [];\n        denim.I2B = [];\n        denim.I2E = [line];\n\n        denim.E2I = [box];\n    }\n    else if (ip.length === 1) {\n        denim.I2I = [];\n        denim.I2B = ip;\n        denim.I2E = line.split(ip);\n\n        denim.E2I = [box];\n    }\n    else {                     // ip.length == 2\n        let multiline = new Multiline([line]);\n        let ip_sorted = line.sortPoints(ip);\n        multiline.split(ip_sorted);\n        let splitShapes = multiline.toShapes();\n\n        /* Are two intersection points on the same segment of the box boundary ? */\n        if (box.toSegments().some( segment => segment.contains(ip[0]) && segment.contains(ip[1]) )) {\n            denim.I2I = [];                         // case of touching\n            denim.I2B = [splitShapes[1]];\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = [box];\n        }\n        else {                                       // case of intersection\n            denim.I2I = [splitShapes[1]];            // [segment(ip[0], ip[1])];\n            denim.I2B = ip_sorted;\n            denim.I2E = [splitShapes[0], splitShapes[2]];\n\n            denim.E2I = new Flatten.Polygon(box.toSegments()).cutWithLine(line);\n        }\n    }\n    return denim;\n}\n\nfunction relateLine2Polygon(line, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectLine2Polygon(line, polygon);\n    let multiline = new Multiline([line]);\n    let ip_sorted = ip.length > 0 ? ip.slice() : line.sortPoints(ip);\n\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n    denim.E2I = polygon.cutWithLine(line);\n\n    return denim;\n}\n\nfunction relateShape2Polygon(shape, polygon) {\n    let denim = new DE9IM();\n    let ip = intersectShape2Polygon(shape, polygon);\n    let ip_sorted = ip.length > 0 ? ip.slice() : shape.sortPoints(ip);\n\n    let multiline = new Multiline([shape]);\n    multiline.split(ip_sorted);\n\n    [...multiline].forEach(edge => edge.setInclusion(polygon));\n\n    denim.I2I = [...multiline].filter(edge => edge.bv === Flatten.INSIDE).map(edge => edge.shape);\n    denim.I2B = [...multiline].slice(1).map( (edge) => edge.bv === Flatten.BOUNDARY ? edge.shape : edge.shape.start );\n    denim.I2E = [...multiline].filter(edge => edge.bv === Flatten.OUTSIDE).map(edge => edge.shape);\n\n\n    denim.B2I = [];\n    denim.B2B = [];\n    denim.B2E = [];\n    for (let pt of [shape.start, shape.end]) {\n        switch (ray_shoot(polygon, pt)) {\n            case Flatten.INSIDE:\n                denim.B2I.push(pt);\n                break;\n            case Flatten.BOUNDARY:\n                denim.B2B.push(pt);\n                break;\n            case Flatten.OUTSIDE:\n                denim.B2E.push(pt);\n                break;\n        }\n    }\n\n    // denim.E2I  TODO: calculate, not clear what is expected result\n\n    return denim;\n}\n\nfunction relatePolygon2Polygon(polygon1, polygon2) {\n    let denim = new DE9IM();\n\n    let [ip_sorted1, ip_sorted2] = calculateIntersections(polygon1, polygon2);\n    let boolean_intersection = intersect$1(polygon1, polygon2);\n    let boolean_difference1 = subtract(polygon1, polygon2);\n    let boolean_difference2 = subtract(polygon2, polygon1);\n    let [inner_clip_shapes1, inner_clip_shapes2] = innerClip(polygon1, polygon2);\n    let outer_clip_shapes1 = outerClip(polygon1, polygon2);\n    let outer_clip_shapes2 = outerClip(polygon2, polygon1);\n\n    denim.I2I = boolean_intersection.isEmpty() ? [] : [boolean_intersection];\n    denim.I2B = inner_clip_shapes2;\n    denim.I2E = boolean_difference1.isEmpty() ? [] : [boolean_difference1];\n\n    denim.B2I = inner_clip_shapes1;\n    denim.B2B = ip_sorted1;\n    denim.B2E = outer_clip_shapes1;\n\n    denim.E2I = boolean_difference2.isEmpty() ? [] : [boolean_difference2];\n    denim.E2B = outer_clip_shapes2;\n    // denim.E2E    not relevant meanwhile\n\n    return denim;\n}\n\nvar Relations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    contain: contain,\n    cover: cover,\n    covered: covered,\n    disjoint: disjoint,\n    equal: equal,\n    inside: inside,\n    intersect: intersect,\n    relate: relate,\n    touch: touch\n});\n\n/**\n * Class representing an affine transformation 3x3 matrix:\n * <pre>\n *      [ a  c  tx\n * A =    b  d  ty\n *        0  0  1  ]\n * </pre\n * @type {Matrix}\n */\nclass Matrix {\n    /**\n     * Construct new instance of affine transformation matrix <br/>\n     * If parameters omitted, construct identity matrix a = 1, d = 1\n     * @param {number} a - position(0,0)   sx*cos(alpha)\n     * @param {number} b - position (0,1)  sx*sin(alpha)\n     * @param {number} c - position (1,0)  -sy*sin(alpha)\n     * @param {number} d - position (1,1)  sy*cos(alpha)\n     * @param {number} tx - position (2,0) translation by x\n     * @param {number} ty - position (2,1) translation by y\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Return new cloned instance of matrix\n     * @return {Matrix}\n     **/\n    clone() {\n        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);\n    };\n\n    /**\n     * Transform vector [x,y] using transformation matrix. <br/>\n     * Vector [x,y] is an abstract array[2] of numbers and not a FlattenJS object <br/>\n     * The result is also an abstract vector [x',y'] = A * [x,y]:\n     * <code>\n     * [x'       [ ax + by + tx\n     *  y'   =     cx + dy + ty\n     *  1]                    1 ]\n     * </code>\n     * @param {number[]} vector - array[2] of numbers\n     * @returns {number[]} transformation result - array[2] of numbers\n     */\n    transform(vector) {\n        return [\n            vector[0] * this.a + vector[1] * this.c + this.tx,\n            vector[0] * this.b + vector[1] * this.d + this.ty\n        ]\n    };\n\n    /**\n     * Returns result of multiplication of this matrix by other matrix\n     * @param {Matrix} other_matrix - matrix to multiply by\n     * @returns {Matrix}\n     */\n    multiply(other_matrix) {\n        return new Matrix(\n            this.a * other_matrix.a + this.c * other_matrix.b,\n            this.b * other_matrix.a + this.d * other_matrix.b,\n            this.a * other_matrix.c + this.c * other_matrix.d,\n            this.b * other_matrix.c + this.d * other_matrix.d,\n            this.a * other_matrix.tx + this.c * other_matrix.ty + this.tx,\n            this.b * other_matrix.tx + this.d * other_matrix.ty + this.ty\n        )\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix(1,0,0,1,tx,ty)\n     * @param {Vector} vector - Translation by vector or\n     * @param {number} tx - translation by x-axis\n     * @param {number} ty - translation by y-axis\n     * @returns {Matrix}\n     */\n    translate(...args) {\n        let tx, ty;\n        if (args.length == 1 &&  !isNaN(args[0].x) && !isNaN(args[0].y)) {\n            tx = args[0].x;\n            ty = args[0].y;\n        } else if (args.length === 2 && typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n            tx = args[0];\n            ty = args[1];\n        } else {\n            throw Errors.ILLEGAL_PARAMETERS;\n        }\n        return this.multiply(new Matrix(1, 0, 0, 1, tx, ty))\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix that defines rotation by given angle (in radians) around\n     * center of rotation (centerX,centerY) in counterclockwise direction\n     * @param {number} angle - angle in radians\n     * @param {number} centerX - center of rotation\n     * @param {number} centerY - center of rotation\n     * @returns {Matrix}\n     */\n    rotate(angle, centerX = 0.0, centerY = 0.0) {\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        return this\n            .translate(centerX, centerY)\n            .multiply(new Matrix(cos, sin, -sin, cos, 0, 0))\n            .translate(-centerX, -centerY);\n    };\n\n    /**\n     * Return new matrix as a result of multiplication of the current matrix\n     * by the matrix (sx,0,0,sy,0,0) that defines scaling\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Matrix}\n     */\n    scale(sx, sy) {\n        return this.multiply(new Matrix(sx, 0, 0, sy, 0, 0));\n    };\n\n    /**\n     * Returns true if two matrix are equal parameter by parameter\n     * @param {Matrix} matrix - other matrix\n     * @returns {boolean} true if equal, false otherwise\n     */\n    equalTo(matrix) {\n        if (!Flatten.Utils.EQ(this.tx, matrix.tx)) return false;\n        if (!Flatten.Utils.EQ(this.ty, matrix.ty)) return false;\n        if (!Flatten.Utils.EQ(this.a, matrix.a)) return false;\n        if (!Flatten.Utils.EQ(this.b, matrix.b)) return false;\n        if (!Flatten.Utils.EQ(this.c, matrix.c)) return false;\n        if (!Flatten.Utils.EQ(this.d, matrix.d)) return false;\n        return true;\n    };\n}\nFlatten.Matrix = Matrix;\n/**\n * Function to create matrix equivalent to \"new\" constructor\n * @param args\n */\nconst matrix = (...args) => new Flatten.Matrix(...args);\nFlatten.matrix = matrix;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low == other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low == other_interval.low && this.high == other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length == 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\n            this.item.value.less_than(other_node.item.value) :\n            this.item.value < other_node.item.value;\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\n        }\n    }\n\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\n            this.item.value.equal_to(other_node.item.value) :\n            this.item.value == other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n        }\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root == this.nil_node);\n    }\n\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return this.tree_search(this.root, search_node) ? true : false;\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        let found = this.tree_find_any_interval(this.root, search_node);\n        return found;\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /** Value Mapper. Walk through every node and map node value to another value\n    * @param callback(value,key) - function to be called for each tree item\n    */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root == this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node != this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left != this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node == this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node == cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node != delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\n            if (current_node == current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node == this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left != this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right != this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right != this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right == current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left != this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x == this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x == x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right != this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y == this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y == y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node != this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color == RB_TREE_COLOR_RED) {\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color == RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left != this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right != this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft != heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    };\n}\n\n/**\n * Created by Alex Bol on 3/12/2017.\n */\n\n\n/**\n * Class representing a planar set - a generic container with ability to keep and retrieve shapes and\n * perform spatial queries. Planar set is an extension of Set container, so it supports\n * Set properties and methods\n */\nclass PlanarSet extends Set {\n    /**\n     * Create new instance of PlanarSet\n     * @param shapes - array or set of geometric objects to store in planar set\n     * Each object should have a <b>box</b> property\n     */\n    constructor(shapes) {\n        super(shapes);\n        this.index = new IntervalTree();\n        this.forEach(shape => this.index.insert(shape));\n    }\n\n    /**\n     * Add new shape to planar set and to its spatial index.<br/>\n     * If shape already exist, it will not be added again.\n     * This happens with no error, it is possible to use <i>size</i> property to check if\n     * a shape was actually added.<br/>\n     * Method returns planar set object updated and may be chained\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be added, should have valid <i>box</i> property\n     * Another option to transfer as an object {key: Box, value: AnyShape}\n     * @returns {PlanarSet}\n     */\n    add(entry) {\n        let size = this.size;\n        const {key, value} = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        super.add(shape);\n        // size not changed - item not added, probably trying to add same item twice\n        if (this.size > size) {\n            this.index.insert(box, shape);\n        }\n        return this;         // in accordance to Set.add interface\n    }\n\n    /**\n     * Delete shape from planar set. Returns true if shape was actually deleted, false otherwise\n     * @param {AnyShape | {Box, AnyShape}} entry - shape to be deleted\n     * @returns {boolean}\n     */\n    delete(entry) {\n        const {key, value} = entry;\n        const box = key || entry.box;\n        const shape = value || entry;\n        let deleted = super.delete(shape);\n        if (deleted) {\n            this.index.remove(box, shape);\n        }\n        return deleted;\n    }\n\n    /**\n     * Clear planar set\n     */\n    clear() {\n        super.clear();\n        this.index = new IntervalTree();\n    }\n\n    /**\n     * 2d range search in planar set.<br/>\n     * Returns array of all shapes in planar set which bounding box is intersected with query box\n     * @param {Box} box - query box\n     * @returns {AnyShape[]}\n     */\n    search(box) {\n        let resp = this.index.search(box);\n        return resp;\n    }\n\n    /**\n     * Point location test. Returns array of shapes which contains given point\n     * @param {Point} point - query point\n     * @returns {AnyShape[]}\n     */\n    hit(point) {\n        let box = new Flatten.Box(point.x - 1, point.y - 1, point.x + 1, point.y + 1);\n        let resp = this.index.search(box);\n        return resp.filter((shape) => point.on(shape));\n    }\n\n    /**\n     * Returns svg string to draw all shapes in planar set\n     * @returns {String}\n     */\n    svg() {\n        let svgcontent = [...this].reduce((acc, shape) => acc + shape.svg(), \"\");\n        return svgcontent;\n    }\n}\n\nFlatten.PlanarSet = PlanarSet;\n\n/**\n * Base class representing shape\n * Implement common methods of affine transformations\n */\nclass Shape {\n    get name() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    get box() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    clone() {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    /**\n     * Returns new shape translated by given vector.\n     * Translation vector may be also defined by a pair of numbers.\n     * @param {Vector | (number, number) } args - Translation vector\n     * or tuple of numbers\n     * @returns {Shape}\n     */\n    translate(...args) {\n        return this.transform(new Matrix().translate(...args))\n    }\n\n    /**\n     * Returns new shape rotated by given angle around given center point.\n     * If center point is omitted, rotates around zero point (0,0).\n     * Positive value of angle defines rotation in counterclockwise direction,\n     * negative angle defines rotation in clockwise direction\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     * @returns {Shape}\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return this.transform(new Matrix().rotate(angle, center.x, center.y));\n    }\n\n    /**\n     * Return new shape with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Shape}\n     */\n    scale(sx, sy) {\n        return this.transform(new Matrix().scale(sx, sy));\n    }\n\n    transform(...args) {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return Object.assign({}, this, {name: this.name});\n    }\n\n    svg(attrs = {}) {\n        throw(Errors.CANNOT_INVOKE_ABSTRACT_METHOD);\n    }\n}\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n\n/**\n *\n * Class representing a point\n * @type {Point}\n */\nlet Point$1 = class Point extends Shape {\n    /**\n     * Point may be constructed by two numbers, or by array of two numbers\n     * @param {number} x - x-coordinate (float number)\n     * @param {number} y - y-coordinate (float number)\n     */\n    constructor(...args) {\n        super();\n        /**\n         * x-coordinate (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"point\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            if (typeof (args[0]) == \"number\" && typeof (args[1]) == \"number\") {\n                this.x = args[0];\n                this.y = args[1];\n                return;\n            }\n        }\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Returns bounding box of a point\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(this.x, this.y, this.x, this.y);\n    }\n\n    /**\n     * Return new cloned instance of point\n     * @returns {Point}\n     */\n    clone() {\n        return new Flatten.Point(this.x, this.y);\n    }\n\n    get vertices() {\n        return [this.clone()];\n    }\n\n    /**\n     * Returns true if points are equal up to [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    equalTo(pt) {\n        return Flatten.Utils.EQ(this.x, pt.x) && Flatten.Utils.EQ(this.y, pt.y);\n    }\n\n    /**\n     * Defines predicate \"less than\" between points. Returns true if the point is less than query points, false otherwise <br/>\n     * By definition point1 < point2 if {point1.y < point2.y || point1.y == point2.y && point1.x < point2.x <br/>\n     * Numeric values compared with [Flatten.Utils.DP_TOL]{@link DP_TOL} tolerance\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    lessThan(pt) {\n        if (Flatten.Utils.LT(this.y, pt.y))\n            return true;\n        if (Flatten.Utils.EQ(this.y, pt.y) && Flatten.Utils.LT(this.x, pt.x))\n            return true;\n        return false;\n    }\n\n    /**\n     * Return new point transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Point}\n     */\n    transform(m) {\n        return new Flatten.Point(m.transform([this.x, this.y]))\n    }\n\n    /**\n     * Returns projection point on given line\n     * @param {Line} line Line this point be projected on\n     * @returns {Point}\n     */\n    projectionOn(line) {\n        if (this.equalTo(line.pt))                   // this point equal to line anchor point\n            return this.clone();\n\n        let vec = new Flatten.Vector(this, line.pt);\n        if (Flatten.Utils.EQ_0(vec.cross(line.norm)))    // vector to point from anchor point collinear to normal vector\n            return line.pt.clone();\n\n        let dist = vec.dot(line.norm);             // signed distance\n        let proj_vec = line.norm.multiply(dist);\n        return this.translate(proj_vec);\n    }\n\n    /**\n     * Returns true if point belongs to the \"left\" semi-plane, which means, point belongs to the same semi plane where line normal vector points to\n     * Return false if point belongs to the \"right\" semi-plane or to the line itself\n     * @param {Line} line Query line\n     * @returns {boolean}\n     */\n    leftTo(line) {\n        let vec = new Flatten.Vector(line.pt, this);\n        let onLeftSemiPlane = Flatten.Utils.GT(vec.dot(line.norm), 0);\n        return onLeftSemiPlane;\n    }\n\n    /**\n     * Calculate distance and shortest segment from point to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from point to shape\n     * @returns {Segment} shortest segment between point and shape (started at point, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Point) {\n            let dx = shape.x - this.x;\n            let dy = shape.y - this.y;\n            return [Math.sqrt(dx * dx + dy * dy), new Flatten.Segment(this, shape)];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return Flatten.Distance.point2line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return Flatten.Distance.point2circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Distance.point2segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return Flatten.Distance.point2arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return Flatten.Distance.point2polygon(this, shape);\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            return Flatten.Distance.shape2planarSet(this, shape);\n        }\n    }\n\n    /**\n     * Returns true if point is on a shape, false otherwise\n     * @param {Shape} shape\n     * @returns {boolean}\n     */\n    on(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.equalTo(shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return shape.contains(this)\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return shape.contains(this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return shape.contains(this);\n        }\n    }\n\n    get name() {\n        return \"point\"\n    }\n\n    /**\n     * Return string to draw point in svg as circle with radius \"r\" <br/>\n     * Accept any valid attributes of svg elements as svg object\n     * Defaults attribues are: <br/>\n     * {\n     *    r:\"3\",\n     *    stroke:\"black\",\n     *    strokeWidth:\"1\",\n     *    fill:\"red\"\n     * }\n     * @param {Object} attrs - Any valid attributes of svg circle element, like \"r\", \"stroke\", \"strokeWidth\", \"fill\"\n     * @returns {String}\n     */\n    svg(attrs = {}) {\n        const r = attrs.r ?? 3;            // default radius - 3\n        return `\\n<circle cx=\"${this.x}\" cy=\"${this.y}\" r=\"${r}\"\n            ${convertToString({fill: \"red\", ...attrs})} />`;\n    }\n};\n\nFlatten.Point = Point$1;\n/**\n * Function to create point equivalent to \"new\" constructor\n * @param args\n */\nconst point = (...args) => new Flatten.Point(...args);\nFlatten.point = point;\n\n// export {Point};\n\n/**\n * Created by Alex Bol on 2/19/2017.\n */\n\n\n/**\n * Class representing a vector\n * @type {Vector}\n */\nlet Vector$1 = class Vector extends Shape {\n    /**\n     * Vector may be constructed by two points, or by two float numbers,\n     * or by array of two numbers\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        super();\n        /**\n         * x-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.x = 0;\n        /**\n         * y-coordinate of a vector (float number)\n         * @type {number}\n         */\n        this.y = 0;\n\n        /* return zero vector */\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 2) {\n            let arr = args[0];\n            if (typeof (arr[0]) == \"number\" && typeof (arr[1]) == \"number\") {\n                this.x = arr[0];\n                this.y = arr[1];\n                return;\n            }\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"vector\") {\n            let {x, y} = args[0];\n            this.x = x;\n            this.y = y;\n            return;\n        }\n\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (typeof (a1) == \"number\" && typeof (a2) == \"number\") {\n                this.x = a1;\n                this.y = a2;\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.x = a2.x - a1.x;\n                this.y = a2.y - a1.y;\n                return;\n            }\n\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Method clone returns new instance of Vector\n     * @returns {Vector}\n     */\n    clone() {\n        return new Flatten.Vector(this.x, this.y);\n    }\n\n    /**\n     * Slope of the vector in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let angle = Math.atan2(this.y, this.x);\n        if (angle < 0) angle = 2 * Math.PI + angle;\n        return angle;\n    }\n\n    /**\n     * Length of vector\n     * @returns {number}\n     */\n    get length() {\n        return Math.sqrt(this.dot(this));\n    }\n\n    /**\n     * Returns true if vectors are equal up to [DP_TOL]{@link http://localhost:63342/flatten-js/docs/global.html#DP_TOL}\n     * tolerance\n     * @param {Vector} v\n     * @returns {boolean}\n     */\n    equalTo(v) {\n        return Flatten.Utils.EQ(this.x, v.x) && Flatten.Utils.EQ(this.y, v.y);\n    }\n\n    /**\n     * Returns new vector multiplied by scalar\n     * @param {number} scalar\n     * @returns {Vector}\n     */\n    multiply(scalar) {\n        return (new Flatten.Vector(scalar * this.x, scalar * this.y));\n    }\n\n    /**\n     * Returns scalar product (dot product) of two vectors <br/>\n     * <code>dot_product = (this * v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    dot(v) {\n        return (this.x * v.x + this.y * v.y);\n    }\n\n    /**\n     * Returns vector product (cross product) of two vectors <br/>\n     * <code>cross_product = (this x v)</code>\n     * @param {Vector} v Other vector\n     * @returns {number}\n     */\n    cross(v) {\n        return (this.x * v.y - this.y * v.x);\n    }\n\n    /**\n     * Returns unit vector.<br/>\n     * Throw error if given vector has zero length\n     * @returns {Vector}\n     */\n    normalize() {\n        if (!Flatten.Utils.EQ_0(this.length)) {\n            return (new Flatten.Vector(this.x / this.length, this.y / this.length));\n        }\n        throw Errors.ZERO_DIVISION;\n    }\n\n    /**\n     * Returns new vector rotated by given angle,\n     * positive angle defines rotation in counterclockwise direction,\n     * negative - in clockwise direction\n     * Vector only can be rotated around (0,0) point!\n     * @param {number} angle - Angle in radians\n     * @returns {Vector}\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        if (center.x === 0 && center.y === 0) {\n            return this.transform(new Matrix().rotate(angle));\n        }\n        throw(Errors.OPERATION_IS_NOT_SUPPORTED);\n    }\n\n    /**\n     * Return new vector transformed by affine transformation matrix m\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Vector}\n     */\n    transform(m) {\n        return new Flatten.Vector(m.transform([this.x, this.y]))\n    }\n\n    /**\n     * Returns vector rotated 90 degrees counterclockwise\n     * @returns {Vector}\n     */\n    rotate90CCW() {\n        return new Flatten.Vector(-this.y, this.x);\n    };\n\n    /**\n     * Returns vector rotated 90 degrees clockwise\n     * @returns {Vector}\n     */\n    rotate90CW() {\n        return new Flatten.Vector(this.y, -this.x);\n    };\n\n    /**\n     * Return inverted vector\n     * @returns {Vector}\n     */\n    invert() {\n        return new Flatten.Vector(-this.x, -this.y);\n    }\n\n    /**\n     * Return result of addition of other vector to this vector as a new vector\n     * @param {Vector} v Other vector\n     * @returns {Vector}\n     */\n    add(v) {\n        return new Flatten.Vector(this.x + v.x, this.y + v.y);\n    }\n\n    /**\n     * Return result of subtraction of other vector from current vector as a new vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    subtract(v) {\n        return new Flatten.Vector(this.x - v.x, this.y - v.y);\n    }\n\n    /**\n     * Return angle between this vector and other vector. <br/>\n     * Angle is measured from 0 to 2*PI in the counterclockwise direction\n     * from current vector to  another.\n     * @param {Vector} v Another vector\n     * @returns {number}\n     */\n    angleTo(v) {\n        let norm1 = this.normalize();\n        let norm2 = v.normalize();\n        let angle = Math.atan2(norm1.cross(norm2), norm1.dot(norm2));\n        if (angle < 0) angle += 2 * Math.PI;\n        return angle;\n    }\n\n    /**\n     * Return vector projection of the current vector on another vector\n     * @param {Vector} v Another vector\n     * @returns {Vector}\n     */\n    projectionOn(v) {\n        let n = v.normalize();\n        let d = this.dot(n);\n        return n.multiply(d);\n    }\n\n    get name() {\n        return \"vector\"\n    }\n};\n\nFlatten.Vector = Vector$1;\n\n/**\n * Function to create vector equivalent to \"new\" constructor\n * @param args\n */\nconst vector$1 = (...args) => new Flatten.Vector(...args);\nFlatten.vector = vector$1;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\n/**\n * Class representing a segment\n * @type {Segment}\n */\nclass Segment extends Shape {\n    /**\n     *\n     * @param {Point} ps - start point\n     * @param {Point} pe - end point\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Start point\n         * @type {Point}\n         */\n        this.ps = new Flatten.Point();\n        /**\n         * End Point\n         * @type {Point}\n         */\n        this.pe = new Flatten.Point();\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Array && args[0].length === 4) {\n            let coords = args[0];\n            this.ps = new Flatten.Point(coords[0], coords[1]);\n            this.pe = new Flatten.Point(coords[2], coords[3]);\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"segment\") {\n            let {ps, pe} = args[0];\n            this.ps = new Flatten.Point(ps.x, ps.y);\n            this.pe = new Flatten.Point(pe.x, pe.y);\n            return;\n        }\n\n        // second point omitted issue #84\n        if (args.length === 1 && args[0] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            return;\n        }\n\n        if (args.length === 2 && args[0] instanceof Flatten.Point && args[1] instanceof Flatten.Point) {\n            this.ps = args[0].clone();\n            this.pe = args[1].clone();\n            return;\n        }\n\n        if (args.length === 4) {\n            this.ps = new Flatten.Point(args[0], args[1]);\n            this.pe = new Flatten.Point(args[2], args[3]);\n            return;\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of segment\n     * @returns {Segment}\n     */\n    clone() {\n        return new Flatten.Segment(this.start, this.end);\n    }\n\n    /**\n     * Start point\n     * @returns {Point}\n     */\n    get start() {\n        return this.ps;\n    }\n\n    /**\n     * End point\n     * @returns {Point}\n     */\n    get end() {\n        return this.pe;\n    }\n\n\n    /**\n     * Returns array of start and end point\n     * @returns [Point,Point]\n     */\n    get vertices() {\n        return [this.ps.clone(), this.pe.clone()];\n    }\n\n    /**\n     * Length of a segment\n     * @returns {number}\n     */\n    get length() {\n        return this.start.distanceTo(this.end)[0];\n    }\n\n    /**\n     * Slope of the line - angle to axe x in radians from 0 to 2PI\n     * @returns {number}\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.slope;\n    }\n\n    /**\n     * Bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Math.min(this.start.x, this.end.x),\n            Math.min(this.start.y, this.end.y),\n            Math.max(this.start.x, this.end.x),\n            Math.max(this.start.y, this.end.y)\n        )\n    }\n\n    /**\n     * Returns true if equals to query segment, false otherwise\n     * @param {Seg} seg - query segment\n     * @returns {boolean}\n     */\n    equalTo(seg) {\n        return this.ps.equalTo(seg.ps) && this.pe.equalTo(seg.pe);\n    }\n\n    /**\n     * Returns true if segment contains point\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        return Flatten.Utils.EQ_0(this.distanceToPoint(pt));\n    }\n\n    /**\n     * Returns array of intersection points between segment and other shape\n     * @param {Shape} shape - Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectSegment2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Segment(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return  intersectSegment2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectSegment2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectSegment2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectSegment2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectSegment2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from segment to shape and return as array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from segment to shape\n     * @returns {Segment} shortest segment between segment and shape (started at segment, ended at shape)\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2segment(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2segment(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Returns unit vector in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.start, this.end);\n        return vec.normalize();\n    }\n\n    /**\n     * Return unit vector in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.end, this.start);\n        return vec.normalize();\n    }\n\n    /**\n     * Returns new segment with swapped start and end points\n     * @returns {Segment}\n     */\n    reverse() {\n        return new Segment(this.end, this.start);\n    }\n\n    /**\n     * When point belongs to segment, return array of two segments split by given point,\n     * if point is inside segment. Returns clone of this segment if query point is incident\n     * to start or end point of the segment. Returns empty array if point does not belong to segment\n     * @param {Point} pt Query point\n     * @returns {Segment[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        return [\n            new Flatten.Segment(this.start, pt),\n            new Flatten.Segment(pt, this.end)\n        ]\n    }\n\n    /**\n     * Return middle point of the segment\n     * @returns {Point}\n     */\n    middle() {\n        return new Flatten.Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the segment\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length == 0) return this.start;\n        if (length == this.length) return this.end;\n        let factor = length / this.length;\n        return new Flatten.Point(\n            (this.end.x - this.start.x) * factor + this.start.x,\n            (this.end.y - this.start.y) * factor + this.start.y\n        );\n    }\n\n    distanceToPoint(pt) {\n        let [dist, ...rest] = Flatten.Distance.point2segment(pt, this);\n        return dist;\n    };\n\n    definiteIntegral(ymin = 0.0) {\n        let dx = this.end.x - this.start.x;\n        let dy1 = this.start.y - ymin;\n        let dy2 = this.end.y - ymin;\n        return (dx * (dy1 + dy2) / 2);\n    }\n\n    /**\n     * Return new segment transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Segment} - transformed segment\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Segment(this.ps.transform(matrix), this.pe.transform(matrix))\n    }\n\n    /**\n     * Returns true if segment start is equal to segment end up to DP_TOL\n     * @returns {boolean}\n     */\n    isZeroLength() {\n        return this.ps.equalTo(this.pe)\n    }\n\n    /**\n     * Sort given array of points from segment start to end, assuming all points lay on the segment\n     * @param {Point[]} - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let line = new Flatten.Line(this.start, this.end);\n        return line.sortPoints(pts);\n    }\n\n    get name() {\n        return \"segment\"\n    }\n\n    /**\n     * Return string to draw segment in svg\n     * @param {Object} attrs - an object with attributes for svg path element,\n     * like \"stroke\", \"strokeWidth\" <br/>\n     * Defaults are stroke:\"black\", strokeWidth:\"1\"\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        return `\\n<line x1=\"${this.start.x}\" y1=\"${this.start.y}\" x2=\"${this.end.x}\" y2=\"${this.end.y}\" ${convertToString(attrs)} />`;\n    }\n}\n\nFlatten.Segment = Segment;\n/**\n * Shortcut method to create new segment\n */\nconst segment = (...args) => new Flatten.Segment(...args);\nFlatten.segment = segment;\n\n/**\n * Created by Alex Bol on 2/20/2017.\n */\n\nlet {vector} = Flatten;\n\n/**\n * Class representing a line\n * @type {Line}\n */\nlet Line$1 = class Line extends Shape {\n    /**\n     * Line may be constructed by point and normal vector or by two points that a line passes through\n     * @param {Point} pt - point that a line passes through\n     * @param {Vector|Point} norm - normal vector to a line or second point a line passes through\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Point a line passes through\n         * @type {Point}\n         */\n        this.pt = new Flatten.Point();\n        /**\n         * Normal vector to a line <br/>\n         * Vector is normalized (length == 1)<br/>\n         * Direction of the vector is chosen to satisfy inequality norm * p >= 0\n         * @type {Vector}\n         */\n        this.norm = new Flatten.Vector(0, 1);\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"line\") {\n            let {pt, norm} = args[0];\n            this.pt = new Flatten.Point(pt);\n            this.norm = new Flatten.Vector(norm);\n            return;\n        }\n\n        if (args.length === 2) {\n            let a1 = args[0];\n            let a2 = args[1];\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Point) {\n                this.pt = a1;\n                this.norm = Line.points2norm(a1, a2);\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Point && a2 instanceof Flatten.Vector) {\n                if (Flatten.Utils.EQ_0(a2.x) && Flatten.Utils.EQ_0(a2.y)) {\n                    throw Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a1.clone();\n                this.norm = a2.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n\n            if (a1 instanceof Flatten.Vector && a2 instanceof Flatten.Point) {\n                if (Flatten.Utils.EQ_0(a1.x) && Flatten.Utils.EQ_0(a1.y)) {\n                    throw Errors.ILLEGAL_PARAMETERS;\n                }\n                this.pt = a2.clone();\n                this.norm = a1.clone();\n                this.norm = this.norm.normalize();\n                if (this.norm.dot(vector(this.pt.x,this.pt.y)) >= 0) {\n                    this.norm.invert();\n                }\n                return;\n            }\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of line\n     * @returns {Line}\n     */\n    clone() {\n        return new Flatten.Line(this.pt, this.norm);\n    }\n\n    /* The following methods need for implementation of Edge interface\n    /**\n     * Line has no start point\n     * @returns {undefined}\n     */\n    get start() {return undefined;}\n\n    /**\n     * Line has no end point\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns infinite box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            Number.NEGATIVE_INFINITY,\n            Number.NEGATIVE_INFINITY,\n            Number.POSITIVE_INFINITY,\n            Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Middle point is undefined\n     * @returns {undefined}\n     */\n    get middle() {return undefined}\n\n    /**\n     * Slope of the line - angle in radians between line and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Get coefficients [A,B,C] of a standard line equation in the form Ax + By = C\n     * @code [A, B, C] = line.standard\n     * @returns {number[]} - array of coefficients\n     */\n    get standard() {\n        let A = this.norm.x;\n        let B = this.norm.y;\n        let C = this.norm.dot(vector(this.pt.x, this.pt.y));\n\n        return [A, B, C];\n    }\n\n    /**\n     * Return true if parallel or incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    parallelTo(other_line) {\n        return Flatten.Utils.EQ_0(this.norm.cross(other_line.norm));\n    }\n\n    /**\n     * Returns true if incident to other line\n     * @param {Line} other_line - line to check\n     * @returns {boolean}\n     */\n    incidentTo(other_line) {\n        return this.parallelTo(other_line) && this.pt.on(other_line);\n    }\n\n    /**\n     * Returns true if point belongs to line\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Line contains point if vector to point is orthogonal to the line normal vector */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec));\n    }\n\n    /**\n     * Return coordinate of the point that lies on the line in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the line and does not check it\n     * @param {Point} pt - point on a line\n     * @returns {number}\n     */\n    coord(pt) {\n        return vector(pt.x, pt.y).cross(this.norm);\n    }\n\n    /**\n     * Returns array of intersection points\n     * @param {Shape} shape - shape to intersect with\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Line(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectLine2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectLine2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Line(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectLine2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectLine2Polygon(this, shape);\n        }\n\n    }\n\n    /**\n     * Calculate distance and shortest segment from line to shape and returns array [distance, shortest_segment]\n     * @param {Shape} shape Shape of the one of the types Point, Circle, Segment, Arc, Polygon\n     * @returns {[number, Segment]}\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2line(shape, this);\n            return [distance, shortest_segment.reverse()];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n    }\n\n    /**\n     * Split line with a point or array of points and return array of shapes\n     * Assumed (but not checked) that all points lay on the line\n     * @param {Point | Point[]} pt\n     * @returns {MultilineShapes}\n     */\n    split(pt) {\n        if (pt instanceof Flatten.Point) {\n            return [new Flatten.Ray(pt, this.norm), new Flatten.Ray(pt, this.norm)]\n        }\n        else {\n            let multiline = new Flatten.Multiline([this]);\n            let sorted_points = this.sortPoints(pt);\n            multiline.split(sorted_points);\n            return multiline.toShapes();\n        }\n    }\n\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return new Flatten.Line(\n            this.pt.rotate(angle, center),\n            this.norm.rotate(angle)\n        )\n    }\n\n    /**\n     * Return new line transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Line}\n     */\n    transform(m) {\n        return new Flatten.Line(\n            this.pt.transform(m),\n            this.norm.clone()\n        )\n    }\n\n    /**\n     * Sort given array of points that lay on a line with respect to coordinate on a line\n     * The method assumes that points lay on the line and does not check this\n     * @param {Point[]} pts - array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        return pts.slice().sort( (pt1, pt2) => {\n            if (this.coord(pt1) < this.coord(pt2)) {\n                return -1;\n            }\n            if (this.coord(pt1) > this.coord(pt2)) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    get name() {\n        return \"line\"\n    }\n\n    /**\n     * Return string to draw svg segment representing line inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg circle element\n     */\n    svg(box, attrs = {}) {\n        let ip = intersectLine2Box(this, box);\n        if (ip.length === 0)\n            return \"\";\n        let ps = ip[0];\n        let pe = ip.length === 2 ? ip[1] : ip.find(pt => !pt.equalTo(ps));\n        if (pe === undefined) pe = ps;\n        let segment = new Flatten.Segment(ps, pe);\n        return segment.svg(attrs);\n    }\n\n    static points2norm(pt1, pt2) {\n        if (pt1.equalTo(pt2)) {\n            throw Errors.ILLEGAL_PARAMETERS;\n        }\n        let vec = new Flatten.Vector(pt1, pt2);\n        let unit = vec.normalize();\n        return unit.rotate90CCW();\n    }\n};\n\nFlatten.Line = Line$1;\n/**\n * Function to create line equivalent to \"new\" constructor\n * @param args\n */\nconst line = (...args) => new Flatten.Line(...args);\nFlatten.line = line;\n\n/**\n * Created by Alex Bol on 3/6/2017.\n */\n\n\n/**\n * Class representing a circle\n * @type {Circle}\n */\nlet Circle$1 = class Circle extends Shape {\n    /**\n     * Class private property\n     * @type {string}\n     */\n\n    /**\n     *\n     * @param {Point} pc - circle center point\n     * @param {number} r - circle radius\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Circle center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Circle radius\n         * @type {number}\n         */\n        this.r = 1;\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"circle\") {\n            let {pc, r} = args[0];\n            this.pc = new Flatten.Point(pc);\n            this.r = r;\n        } else {\n            let [pc, r] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n        }\n        // throw Errors.ILLEGAL_PARAMETERS;    unreachable code\n    }\n\n    /**\n     * Return new cloned instance of circle\n     * @returns {Circle}\n     */\n    clone() {\n        return new Flatten.Circle(this.pc.clone(), this.r);\n    }\n\n    /**\n     * Circle center\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc;\n    }\n\n    /**\n     * Circle bounding box\n     * @returns {Box}\n     */\n    get box() {\n        return new Flatten.Box(\n            this.pc.x - this.r,\n            this.pc.y - this.r,\n            this.pc.x + this.r,\n            this.pc.y + this.r\n        );\n    }\n\n    /**\n     * Return true if circle contains shape: no point of shape lies outside of the circle\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            return Flatten.Utils.LE(shape.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.start.distanceTo(this.center)[0], this.r) &&\n                Flatten.Utils.LE(shape.end.distanceTo(this.center)[0], this.r);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return this.intersect(shape).length === 0 &&\n                Flatten.Utils.LE(shape.r, this.r) &&\n                Flatten.Utils.LE(shape.center.distanceTo(this.center)[0], this.r);\n        }\n\n        /* TODO: box, polygon */\n    }\n\n    /**\n     * Transform circle to closed arc\n     * @param {boolean} counterclockwise\n     * @returns {Arc}\n     */\n    toArc(counterclockwise = true) {\n        return new Flatten.Arc(this.center, this.r, Math.PI, -Math.PI, counterclockwise);\n    }\n\n    /**\n     * Method scale is supported only for uniform scaling of the circle with (0,0) center\n     * @param {number} sx\n     * @param {number} sy\n     * @returns {Circle}\n     */\n    scale(sx, sy) {\n        if (sx !== sy)\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n        if (!(this.pc.x === 0.0 && this.pc.y === 0.0))\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n        return new Flatten.Circle(this.pc, this.r*sx)\n    }\n\n    /**\n     * Return new circle transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Circle}\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        return new Flatten.Circle(this.pc.transform(matrix), this.r)\n    }\n\n    /**\n     * Returns array of intersection points between circle and other shape\n     * @param {Shape} shape Shape of the one of supported types\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Circle(shape, this);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectCircle2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Circle(shape, this);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectCircle2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from circle to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from circle to shape\n     * @returns {Segment} shortest segment between circle and shape (started at circle, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [distance, shortest_segment] = Flatten.Distance.point2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2circle(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [distance, shortest_segment] = Flatten.Distance.circle2line(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [distance, shortest_segment] = Flatten.Distance.segment2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [distance, shortest_segment] = Flatten.Distance.arc2circle(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [distance, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [distance, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    get name() {\n        return \"circle\"\n    }\n\n    /**\n     * Return string to draw circle in svg\n     * @param {Object} attrs - an object with attributes of svg circle element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        return `\\n<circle cx=\"${this.pc.x}\" cy=\"${this.pc.y}\" r=\"${this.r}\"\n                ${convertToString({fill: \"none\", ...attrs})} />`;\n    }\n\n};\n\nFlatten.Circle = Circle$1;\n/**\n * Shortcut to create new circle\n * @param args\n */\nconst circle = (...args) => new Flatten.Circle(...args);\nFlatten.circle = circle;\n\n/**\n * Created by Alex Bol on 3/10/2017.\n */\n\n\n/**\n * Class representing a circular arc\n * @type {Arc}\n */\nclass Arc extends Shape {\n    /**\n     *\n     * @param {Point} pc - arc center\n     * @param {number} r - arc radius\n     * @param {number} startAngle - start angle in radians from 0 to 2*PI\n     * @param {number} endAngle - end angle in radians from 0 to 2*PI\n     * @param {boolean} counterClockwise - arc direction, true - clockwise, false - counterclockwise\n     */\n    constructor(...args) {\n        super();\n        /**\n         * Arc center\n         * @type {Point}\n         */\n        this.pc = new Flatten.Point();\n        /**\n         * Arc radius\n         * @type {number}\n         */\n        this.r = 1;\n        /**\n         * Arc start angle in radians\n         * @type {number}\n         */\n        this.startAngle = 0;\n        /**\n         * Arc end angle in radians\n         * @type {number}\n         */\n        this.endAngle = 2 * Math.PI;\n        /**\n         * Arc orientation\n         * @type {boolean}\n         */\n        this.counterClockwise = Flatten.CCW;\n\n        if (args.length === 0)\n            return;\n\n        if (args.length === 1 && args[0] instanceof Object && args[0].name === \"arc\") {\n            let {pc, r, startAngle, endAngle, counterClockwise} = args[0];\n            this.pc = new Flatten.Point(pc.x, pc.y);\n            this.r = r;\n            this.startAngle = startAngle;\n            this.endAngle = endAngle;\n            this.counterClockwise = counterClockwise;\n        } else {\n            let [pc, r, startAngle, endAngle, counterClockwise] = [...args];\n            if (pc && pc instanceof Flatten.Point) this.pc = pc.clone();\n            if (r !== undefined) this.r = r;\n            if (startAngle !== undefined) this.startAngle = startAngle;\n            if (endAngle !== undefined) this.endAngle = endAngle;\n            if (counterClockwise !== undefined) this.counterClockwise = counterClockwise;\n        }\n\n        // throw Flatten.Errors.ILLEGAL_PARAMETERS; unreachable code\n    }\n\n    /**\n     * Return new cloned instance of arc\n     * @returns {Arc}\n     */\n    clone() {\n        return new Flatten.Arc(this.pc.clone(), this.r, this.startAngle, this.endAngle, this.counterClockwise);\n    }\n\n    /**\n     * Get sweep angle in radians. Sweep angle is non-negative number from 0 to 2*PI\n     * @returns {number}\n     */\n    get sweep() {\n        if (Flatten.Utils.EQ(this.startAngle, this.endAngle))\n            return 0.0;\n        if (Flatten.Utils.EQ(Math.abs(this.startAngle - this.endAngle), Flatten.PIx2)) {\n            return Flatten.PIx2;\n        }\n        let sweep;\n        if (this.counterClockwise) {\n            sweep = Flatten.Utils.GT(this.endAngle, this.startAngle) ?\n                this.endAngle - this.startAngle : this.endAngle - this.startAngle + Flatten.PIx2;\n        } else {\n            sweep = Flatten.Utils.GT(this.startAngle, this.endAngle) ?\n                this.startAngle - this.endAngle : this.startAngle - this.endAngle + Flatten.PIx2;\n        }\n\n        if (Flatten.Utils.GT(sweep, Flatten.PIx2)) {\n            sweep -= Flatten.PIx2;\n        }\n        if (Flatten.Utils.LT(sweep, 0)) {\n            sweep += Flatten.PIx2;\n        }\n        return sweep;\n    }\n\n    /**\n     * Get start point of arc\n     * @returns {Point}\n     */\n    get start() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.startAngle, this.pc);\n    }\n\n    /**\n     * Get end point of arc\n     * @returns {Point}\n     */\n    get end() {\n        let p0 = new Flatten.Point(this.pc.x + this.r, this.pc.y);\n        return p0.rotate(this.endAngle, this.pc);\n    }\n\n    /**\n     * Get center of arc\n     * @returns {Point}\n     */\n    get center() {\n        return this.pc.clone();\n    }\n\n    get vertices() {\n        return [this.start.clone(), this.end.clone()];\n    }\n\n    /**\n     * Get arc length\n     * @returns {number}\n     */\n    get length() {\n        return Math.abs(this.sweep * this.r);\n    }\n\n    /**\n     * Get bounding box of the arc\n     * @returns {Box}\n     */\n    get box() {\n        let func_arcs = this.breakToFunctional();\n        let box = func_arcs.reduce((acc, arc) => acc.merge(arc.start.box), new Flatten.Box());\n        box = box.merge(this.end.box);\n        return box;\n    }\n\n    /**\n     * Returns true if arc contains point, false otherwise\n     * @param {Point} pt - point to test\n     * @returns {boolean}\n     */\n    contains(pt) {\n        // first check if  point on circle (pc,r)\n        if (!Flatten.Utils.EQ(this.pc.distanceTo(pt)[0], this.r))\n            return false;\n\n        // point on circle\n\n        if (pt.equalTo(this.start))\n            return true;\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n        let test_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise);\n        return Flatten.Utils.LE(test_arc.length, this.length);\n    }\n\n    /**\n     * When given point belongs to arc, return array of two arcs split by this point. If points is incident\n     * to start or end point of the arc, return clone of the arc. If point does not belong to the arcs, return\n     * empty array.\n     * @param {Point} pt Query point\n     * @returns {Arc[]}\n     */\n    split(pt) {\n        if (this.start.equalTo(pt))\n            return [null, this.clone()];\n\n        if (this.end.equalTo(pt))\n            return [this.clone(), null];\n\n        let angle = new Flatten.Vector(this.pc, pt).slope;\n\n        return [\n            new Flatten.Arc(this.pc, this.r, this.startAngle, angle, this.counterClockwise),\n            new Flatten.Arc(this.pc, this.r, angle, this.endAngle, this.counterClockwise)\n        ]\n    }\n\n    /**\n     * Return middle point of the arc\n     * @returns {Point}\n     */\n    middle() {\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep / 2 : this.startAngle - this.sweep / 2;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the arc\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.length || length < 0) return null;\n        if (length === 0) return this.start;\n        if (length === this.length) return this.end;\n        let factor = length / this.length;\n        let endAngle = this.counterClockwise ? this.startAngle + this.sweep * factor : this.startAngle - this.sweep * factor;\n        let arc = new Flatten.Arc(this.pc, this.r, this.startAngle, endAngle, this.counterClockwise);\n        return arc.end;\n    }\n\n    /**\n     * Returns chord height (\"sagitta\") of the arc\n     * @returns {number}\n     */\n    chordHeight() {\n        return (1.0 - Math.cos(Math.abs(this.sweep / 2.0))) * this.r;\n    }\n\n    /**\n     * Returns array of intersection points between arc and other shape\n     * @param {Shape} shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Circle) {\n            return intersectArc2Circle(this, shape);\n        }\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Arc(shape, this);\n        }\n        if (shape instanceof Flatten.Box) {\n            return intersectArc2Box(this, shape);\n        }\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Arc(this, shape);\n        }\n        if (shape instanceof Flatten.Polygon) {\n            return intersectArc2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment from arc to shape and return array [distance, shortest segment]\n     * @param {Shape} shape Shape of the one of supported types Point, Line, Circle, Segment, Arc, Polygon or Planar Set\n     * @returns {number} distance from arc to shape\n     * @returns {Segment} shortest segment between arc and shape (started at arc, ended at shape)\n\n     */\n    distanceTo(shape) {\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2circle(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2line(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            let [dist, shortest_segment] = Flatten.Distance.segment2arc(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.arc2arc(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(this, shape);\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.PlanarSet) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2planarSet(this, shape);\n            return [dist, shortest_segment];\n        }\n    }\n\n    /**\n     * Breaks arc in extreme point 0, pi/2, pi, 3*pi/2 and returns array of sub-arcs\n     * @returns {Arc[]}\n     */\n    breakToFunctional() {\n        let func_arcs_array = [];\n        let angles = [0, Math.PI / 2, 2 * Math.PI / 2, 3 * Math.PI / 2];\n        let pts = [\n            this.pc.translate(this.r, 0),\n            this.pc.translate(0, this.r),\n            this.pc.translate(-this.r, 0),\n            this.pc.translate(0, -this.r)\n        ];\n\n        // If arc contains extreme point,\n        // create test arc started at start point and ended at this extreme point\n        let test_arcs = [];\n        for (let i = 0; i < 4; i++) {\n            if (pts[i].on(this)) {\n                test_arcs.push(new Flatten.Arc(this.pc, this.r, this.startAngle, angles[i], this.counterClockwise));\n            }\n        }\n\n        if (test_arcs.length === 0) {                  // arc does contain any extreme point\n            func_arcs_array.push(this.clone());\n        } else {                                        // arc passes extreme point\n            // sort these arcs by length\n            test_arcs.sort((arc1, arc2) => arc1.length - arc2.length);\n\n            for (let i = 0; i < test_arcs.length; i++) {\n                let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n                let new_arc;\n                if (prev_arc) {\n                    new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, test_arcs[i].endAngle, this.counterClockwise);\n                } else {\n                    new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, test_arcs[i].endAngle, this.counterClockwise);\n                }\n                if (!Flatten.Utils.EQ_0(new_arc.length)) {\n                    func_arcs_array.push(new_arc.clone());\n                }\n            }\n\n            // add last sub arc\n            let prev_arc = func_arcs_array.length > 0 ? func_arcs_array[func_arcs_array.length - 1] : undefined;\n            let new_arc;\n            if (prev_arc) {\n                new_arc = new Flatten.Arc(this.pc, this.r, prev_arc.endAngle, this.endAngle, this.counterClockwise);\n            } else {\n                new_arc = new Flatten.Arc(this.pc, this.r, this.startAngle, this.endAngle, this.counterClockwise);\n            }\n            // It could be 2*PI when occasionally start = 0 and end = 2*PI but this is not valid for breakToFunctional\n            if (!Flatten.Utils.EQ_0(new_arc.length) && !Flatten.Utils.EQ(new_arc.sweep, 2*Math.PI)) {\n                func_arcs_array.push(new_arc.clone());\n            }\n        }\n        return func_arcs_array;\n    }\n\n    /**\n     * Return tangent unit vector in the start point in the direction from start to end\n     * @returns {Vector}\n     */\n    tangentInStart() {\n        let vec = new Flatten.Vector(this.pc, this.start);\n        let angle = this.counterClockwise ? Math.PI / 2. : -Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n\n    /**\n     * Return tangent unit vector in the end point in the direction from end to start\n     * @returns {Vector}\n     */\n    tangentInEnd() {\n        let vec = new Flatten.Vector(this.pc, this.end);\n        let angle = this.counterClockwise ? -Math.PI / 2. : Math.PI / 2.;\n        return vec.rotate(angle).normalize();\n    }\n\n    /**\n     * Returns new arc with swapped start and end angles and reversed direction\n     * @returns {Arc}\n     */\n    reverse() {\n        return new Flatten.Arc(this.pc, this.r, this.endAngle, this.startAngle, !this.counterClockwise);\n    }\n\n    /**\n     * Return new arc transformed using affine transformation matrix <br/>\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Arc}\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newStart = this.start.transform(matrix);\n        let newEnd = this.end.transform(matrix);\n        let newCenter = this.pc.transform(matrix);\n        let newDirection = this.counterClockwise;\n        if (matrix.a * matrix.d < 0) {\n          newDirection = !newDirection;\n        }\n        return Flatten.Arc.arcSE(newCenter, newStart, newEnd, newDirection);\n    }\n\n    static arcSE(center, start, end, counterClockwise) {\n        let {vector} = Flatten;\n        let startAngle = vector(center, start).slope;\n        let endAngle = vector(center, end).slope;\n        if (Flatten.Utils.EQ(startAngle, endAngle)) {\n            endAngle += 2 * Math.PI;\n            counterClockwise = true;\n        }\n        let r = vector(center, start).length;\n\n        return new Flatten.Arc(center, r, startAngle, endAngle, counterClockwise);\n    }\n\n    definiteIntegral(ymin = 0) {\n        let f_arcs = this.breakToFunctional();\n        let area = f_arcs.reduce((acc, arc) => acc + arc.circularSegmentDefiniteIntegral(ymin), 0.0);\n        return area;\n    }\n\n    circularSegmentDefiniteIntegral(ymin) {\n        let line = new Flatten.Line(this.start, this.end);\n        let onLeftSide = this.pc.leftTo(line);\n        let segment = new Flatten.Segment(this.start, this.end);\n        let areaTrapez = segment.definiteIntegral(ymin);\n        let areaCircularSegment = this.circularSegmentArea();\n        let area = onLeftSide ? areaTrapez - areaCircularSegment : areaTrapez + areaCircularSegment;\n        return area;\n    }\n\n    circularSegmentArea() {\n        return (0.5 * this.r * this.r * (this.sweep - Math.sin(this.sweep)))\n    }\n\n    /**\n     * Sort given array of points from arc start to end, assuming all points lay on the arc\n     * @param {Point[]} pts array of points\n     * @returns {Point[]} new array sorted\n     */\n    sortPoints(pts) {\n        let {vector} = Flatten;\n        return pts.slice().sort( (pt1, pt2) => {\n            let slope1 = vector(this.pc, pt1).slope;\n            let slope2 = vector(this.pc, pt2).slope;\n            if (slope1 < slope2) {\n                return -1;\n            }\n            if (slope1 > slope2) {\n                return 1;\n            }\n            return 0;\n        })\n    }\n\n    get name() {\n        return \"arc\"\n    }\n\n    /**\n     * Return string to draw arc in svg\n     * @param {Object} attrs - an object with attributes of svg path element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let largeArcFlag = this.sweep <= Math.PI ? \"0\" : \"1\";\n        let sweepFlag = this.counterClockwise ? \"1\" : \"0\";\n\n        if (Flatten.Utils.EQ(this.sweep, 2 * Math.PI)) {\n            let circle = new Flatten.Circle(this.pc, this.r);\n            return circle.svg(attrs);\n        } else {\n            return `\\n<path d=\"M${this.start.x},${this.start.y}\n                             A${this.r},${this.r} 0 ${largeArcFlag},${sweepFlag} ${this.end.x},${this.end.y}\"\n                    ${convertToString({fill: \"none\", ...attrs})} />`\n        }\n    }\n\n}\n\nFlatten.Arc = Arc;\n/**\n * Function to create arc equivalent to \"new\" constructor\n * @param args\n */\nconst arc = (...args) => new Flatten.Arc(...args);\nFlatten.arc = arc;\n\n/**\n * Created by Alex Bol on 3/7/2017.\n */\n\n/**\n * Class Box represents bounding box of the shape.\n * It may also represent axis-aligned rectangle\n * @type {Box}\n */\nclass Box extends Shape {\n    /**\n     *\n     * @param {number} xmin - minimal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    constructor(xmin = undefined, ymin = undefined, xmax = undefined, ymax = undefined) {\n        super();\n        /**\n         * Minimal x coordinate\n         * @type {number}\n         */\n        this.xmin = xmin;\n        /**\n         * Minimal y coordinate\n         * @type {number}\n         */\n        this.ymin = ymin;\n        /**\n         * Maximal x coordinate\n         * @type {number}\n         */\n        this.xmax = xmax;\n        /**\n         * Maximal y coordinate\n         * @type {number}\n         */\n        this.ymax = ymax;\n    }\n\n    /**\n     * Return new cloned instance of box\n     * @returns {Box}\n     */\n    clone() {\n        return new Box(this.xmin, this.ymin, this.xmax, this.ymax);\n    }\n\n    /**\n     * Property low need for interval tree interface\n     * @returns {Point}\n     */\n    get low() {\n        return new Flatten.Point(this.xmin, this.ymin);\n    }\n\n    /**\n     * Property high need for interval tree interface\n     * @returns {Point}\n     */\n    get high() {\n        return new Flatten.Point(this.xmax, this.ymax);\n    }\n\n    /**\n     * Property max returns the box itself !\n     * @returns {Box}\n     */\n    get max() {\n        return this.clone();\n    }\n    \n    /**\n     * Return center of the box\n     * @returns {Point}\n     */\n    get center() {\n        return new Flatten.Point((this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2);\n    }\n\n    /**\n     * Return the width of the box\n     * @returns {number}\n     */\n    get width() {\n        return Math.abs(this.xmax - this.xmin);\n    }\n\n    /**\n     * Return the height of the box\n     * @returns {number}\n     */\n    get height() {\n        return Math.abs(this.ymax - this.ymin);\n    }\n    \n    /**\n     * Return property box like all other shapes\n     * @returns {Box}\n     */\n    get box() {\n        return this.clone();\n    }\n\n    /**\n     * Returns true if not intersected with other box\n     * @param {Box} other_box - other box to test\n     * @returns {boolean}\n     */\n    not_intersect(other_box) {\n        return (\n            this.xmax < other_box.xmin ||\n            this.xmin > other_box.xmax ||\n            this.ymax < other_box.ymin ||\n            this.ymin > other_box.ymax\n        );\n    }\n\n    /**\n     * Returns true if intersected with other box\n     * @param {Box} other_box - Query box\n     * @returns {boolean}\n     */\n    intersect(other_box) {\n        return !this.not_intersect(other_box);\n    }\n\n    /**\n     * Returns new box merged with other box\n     * @param {Box} other_box - Other box to merge with\n     * @returns {Box}\n     */\n    merge(other_box) {\n        return new Box(\n            this.xmin === undefined ? other_box.xmin : Math.min(this.xmin, other_box.xmin),\n            this.ymin === undefined ? other_box.ymin : Math.min(this.ymin, other_box.ymin),\n            this.xmax === undefined ? other_box.xmax : Math.max(this.xmax, other_box.xmax),\n            this.ymax === undefined ? other_box.ymax : Math.max(this.ymax, other_box.ymax)\n        );\n    }\n\n    /**\n     * Defines predicate \"less than\" between two boxes. Need for interval index\n     * @param {Box} other_box - other box\n     * @returns {boolean} - true if this box less than other box, false otherwise\n     */\n    less_than(other_box) {\n        if (this.low.lessThan(other_box.low))\n            return true;\n        if (this.low.equalTo(other_box.low) && this.high.lessThan(other_box.high))\n            return true;\n        return false;\n    }\n\n    /**\n     * Returns true if this box is equal to other box, false otherwise\n     * @param {Box} other_box - query box\n     * @returns {boolean}\n     */\n    equal_to(other_box) {\n        return (this.low.equalTo(other_box.low) && this.high.equalTo(other_box.high));\n    }\n\n    output() {\n        return this.clone();\n    }\n\n    static comparable_max(box1, box2) {\n        // return pt1.lessThan(pt2) ? pt2.clone() : pt1.clone();\n        return box1.merge(box2);\n    }\n\n    static comparable_less_than(pt1, pt2) {\n        return pt1.lessThan(pt2);\n    }\n\n    /**\n     * Set new values to the box object\n     * @param {number} xmin - mininal x coordinate\n     * @param {number} ymin - minimal y coordinate\n     * @param {number} xmax - maximal x coordinate\n     * @param {number} ymax - maximal y coordinate\n     */\n    set(xmin, ymin, xmax, ymax) {\n        this.xmin = xmin;\n        this.ymin = ymin;\n        this.xmax = xmax;\n        this.ymax = ymax;\n    }\n\n    /**\n     * Transform box into array of points from low left corner in counterclockwise\n     * @returns {Point[]}\n     */\n    toPoints() {\n        return [\n            new Flatten.Point(this.xmin, this.ymin),\n            new Flatten.Point(this.xmax, this.ymin),\n            new Flatten.Point(this.xmax, this.ymax),\n            new Flatten.Point(this.xmin, this.ymax)\n        ];\n    }\n\n    /**\n     * Transform box into array of segments from low left corner in counterclockwise\n     * @returns {Segment[]}\n     */\n    toSegments() {\n        let pts = this.toPoints();\n        return [\n            new Flatten.Segment(pts[0], pts[1]),\n            new Flatten.Segment(pts[1], pts[2]),\n            new Flatten.Segment(pts[2], pts[3]),\n            new Flatten.Segment(pts[3], pts[0])\n        ];\n    }\n\n    /**\n     * Box rotation is not supported\n     * Attempt to rotate box throws error\n     * @param {number} angle - angle in radians\n     * @param {Point} [center=(0,0)] center\n     */\n    rotate(angle, center = new Flatten.Point()) {\n            throw Errors.OPERATION_IS_NOT_SUPPORTED\n    }\n\n    /**\n     * Return new box transformed using affine transformation matrix\n     * New box is a bounding box of transformed corner points\n     * @param {Matrix} m - affine transformation matrix\n     * @returns {Box}\n     */\n    transform(m = new Flatten.Matrix()) {\n        const transformed_points = this.toPoints().map(pt => pt.transform(m));\n        return transformed_points.reduce(\n            (new_box, pt) => new_box.merge(pt.box), new Box())\n    }\n\n    /**\n     * Return true if box contains shape: no point of shape lies outside the box\n     * @param {AnyShape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            return (shape.x >= this.xmin) && (shape.x <= this.xmax) && (shape.y >= this.ymin) && (shape.y <= this.ymax);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return shape.vertices.every(vertex => this.contains(vertex))\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return shape.toSegments().every(segment => this.contains(segment))\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return this.contains(shape.box)\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return shape.vertices.every(vertex => this.contains(vertex)) &&\n                shape.toSegments().every(segment => intersectSegment2Arc(segment, shape).length === 0)\n        }\n\n        if (shape instanceof Flatten.Line || shape instanceof Flatten.Ray) {\n            return false\n        }\n\n        if (shape instanceof Flatten.Multiline) {\n            return shape.toShapes().every(shape => this.contains(shape))\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return this.contains(shape.box)\n        }\n    }\n\n    get name() {\n        return \"box\"\n    }\n\n    /**\n     * Return string to draw box in svg\n     * @param {Object} attrs - an object with attributes of svg rectangle element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        const width = this.xmax - this.xmin;\n        const height = this.ymax - this.ymin;\n        return `\\n<rect x=\"${this.xmin}\" y=\"${this.ymin}\" width=${width} height=${height}\n                ${convertToString({fill: \"none\", ...attrs})} />`;\n    };\n}\n\nFlatten.Box = Box;\n/**\n * Shortcut to create new box\n * @param args\n * @returns {Box}\n */\nconst box = (...args) => new Flatten.Box(...args);\nFlatten.box = box;\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n\n/**\n * Class representing an edge of polygon. Edge shape may be Segment or Arc.\n * Each edge contains references to the next and previous edges in the face of the polygon.\n *\n * @type {Edge}\n */\nclass Edge {\n    /**\n     * Construct new instance of edge\n     * @param {Shape} shape Shape of type Segment or Arc\n     */\n    constructor(shape) {\n        /**\n         * Shape of the edge: Segment or Arc\n         * @type {Segment|Arc}\n         */\n        this.shape = shape;\n        /**\n         * Pointer to the next edge in the face\n         * @type {Edge}\n         */\n        this.next = undefined;\n        /**\n         * Pointer to the previous edge in the face\n         * @type {Edge}\n         */\n        this.prev = undefined;\n        /**\n         * Pointer to the face containing this edge\n         * @type {Face}\n         */\n        this.face = undefined;\n        /**\n         * \"Arc distance\" from the face start\n         * @type {number}\n         */\n        this.arc_length = 0;\n        /**\n         * Start inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvStart = undefined;\n        /**\n         * End inclusion flag (inside/outside/boundary)\n         * @type {*}\n         */\n        this.bvEnd = undefined;\n        /**\n         * Edge inclusion flag (Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY)\n         * @type {*}\n         */\n        this.bv = undefined;\n        /**\n         * Overlap flag for boundary edge (Flatten.OVERLAP_SAME/Flatten.OVERLAP_OPPOSITE)\n         * @type {*}\n         */\n        this.overlap = undefined;\n    }\n\n    /**\n     * Get edge start point\n     */\n    get start() {\n        return this.shape.start;\n    }\n\n    /**\n     * Get edge end point\n     */\n    get end() {\n        return this.shape.end;\n    }\n\n    /**\n     * Get edge length\n     */\n    get length() {\n        return this.shape.length;\n    }\n\n    /**\n     * Get bounding box of the edge\n     * @returns {Box}\n     */\n    get box() {\n        return this.shape.box;\n    }\n\n    get isSegment() {\n        return this.shape instanceof Flatten.Segment;\n    }\n\n    get isArc() {\n        return this.shape instanceof Flatten.Arc;\n    }\n\n    get isLine() {\n        return this.shape instanceof Flatten.Line;\n    }\n\n    get isRay() {\n        return this.shape instanceof Flatten.Ray\n    }\n\n    /**\n     * Get middle point of the edge\n     * @returns {Point}\n     */\n    middle() {\n        return this.shape.middle();\n    }\n\n    /**\n     * Get point at given length\n     * @param {number} length - The length along the edge\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        return this.shape.pointAtLength(length);\n    }\n\n    /**\n     * Returns true if point belongs to the edge, false otherwise\n     * @param {Point} pt - test point\n     */\n    contains(pt) {\n        return this.shape.contains(pt);\n    }\n\n    /**\n     * Set inclusion flag of the edge with respect to another polygon\n     * Inclusion flag is one of Flatten.INSIDE, Flatten.OUTSIDE, Flatten.BOUNDARY\n     * @param polygon\n     */\n    setInclusion(polygon) {\n        if (this.bv !== undefined) return this.bv;\n\n        if (this.shape instanceof Flatten.Line || this.shape instanceof Flatten.Ray) {\n            this.bv = Flatten.OUTSIDE;\n            return this.bv;\n        }\n\n        if (this.bvStart === undefined) {\n            this.bvStart = ray_shoot(polygon, this.start);\n        }\n        if (this.bvEnd === undefined) {\n            this.bvEnd = ray_shoot(polygon, this.end);\n        }\n        /* At least one end outside - the whole edge outside */\n        if (this.bvStart === Flatten.OUTSIDE || this.bvEnd == Flatten.OUTSIDE) {\n            this.bv = Flatten.OUTSIDE;\n        }\n        /* At least one end inside - the whole edge inside */\n        else if (this.bvStart === Flatten.INSIDE || this.bvEnd == Flatten.INSIDE) {\n            this.bv = Flatten.INSIDE;\n        }\n        /* Both are boundary - check the middle point */\n        else {\n            let bvMiddle = ray_shoot(polygon, this.middle());\n            // let boundary = this.middle().distanceTo(polygon)[0] < 10*Flatten.DP_TOL;\n            // let bvMiddle = boundary ? Flatten.BOUNDARY : ray_shoot(polygon, this.middle());\n            this.bv = bvMiddle;\n        }\n        return this.bv;\n    }\n\n    /**\n     * Set overlapping between two coincident boundary edges\n     * Overlapping flag is one of Flatten.OVERLAP_SAME or Flatten.OVERLAP_OPPOSITE\n     * @param edge\n     */\n    setOverlap(edge) {\n        let flag = undefined;\n        let shape1 = this.shape;\n        let shape2 = edge.shape;\n\n        if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end)) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start)) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Arc) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && /*shape1.counterClockwise === shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && /*shape1.counterClockwise !== shape2.counterClockwise &&*/\n                shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        } else if (shape1 instanceof Flatten.Segment && shape2 instanceof Flatten.Arc ||\n            shape1 instanceof Flatten.Arc && shape2 instanceof Flatten.Segment) {\n            if (shape1.start.equalTo(shape2.start) && shape1.end.equalTo(shape2.end) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_SAME;\n            } else if (shape1.start.equalTo(shape2.end) && shape1.end.equalTo(shape2.start) && shape1.middle().equalTo(shape2.middle())) {\n                flag = Flatten.OVERLAP_OPPOSITE;\n            }\n        }\n\n        /* Do not update overlap flag if already set on previous chain */\n        if (this.overlap === undefined) this.overlap = flag;\n        if (edge.overlap === undefined) edge.overlap = flag;\n    }\n\n    svg() {\n        if (this.shape instanceof Flatten.Segment) {\n            return ` L${this.shape.end.x},${this.shape.end.y}`;\n        } else if (this.shape instanceof Flatten.Arc) {\n            let arc = this.shape;\n            let largeArcFlag;\n            let sweepFlag = arc.counterClockwise ? \"1\" : \"0\";\n\n            // Draw full circe arc as special case: split it into two half-circles\n            if (Flatten.Utils.EQ(arc.sweep, 2 * Math.PI)) {\n                let sign = arc.counterClockwise ? 1 : -1;\n                let halfArc1 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle, arc.startAngle + sign * Math.PI, arc.counterClockwise);\n                let halfArc2 = new Flatten.Arc(arc.pc, arc.r, arc.startAngle + sign * Math.PI, arc.endAngle, arc.counterClockwise);\n\n                largeArcFlag = \"0\";\n\n                return ` A${halfArc1.r},${halfArc1.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc1.end.x},${halfArc1.end.y}\n                    A${halfArc2.r},${halfArc2.r} 0 ${largeArcFlag},${sweepFlag} ${halfArc2.end.x},${halfArc2.end.y}`\n            } else {\n                largeArcFlag = arc.sweep <= Math.PI ? \"0\" : \"1\";\n\n                return ` A${arc.r},${arc.r} 0 ${largeArcFlag},${sweepFlag} ${arc.end.x},${arc.end.y}`;\n            }\n        }\n    }\n\n    toJSON() {\n        return this.shape.toJSON();\n    }\n}\nFlatten.Edge = Edge;\n\n/**\n * Class implements circular bidirectional linked list <br/>\n * LinkedListElement - object of any type that has properties next and prev.\n */\nclass CircularLinkedList extends LinkedList {\n    constructor(first, last) {\n        super(first, last);\n        this.setCircularLinks();\n    }\n\n    setCircularLinks() {\n        if (this.isEmpty()) return;\n        this.last.next = this.first;\n        this.first.prev = this.last;\n    }\n\n    [Symbol.iterator]() {\n        let element = undefined;\n        return {\n            next: () => {\n                let value = element ? element : this.first;\n                let done = this.first ? (element ? element === this.first : false) : true;\n                element = value ? value.next : undefined;\n                return {value: value, done: done};\n            }\n        };\n    };\n\n    /**\n     * Append new element to the end of the list\n     * @param {LinkedListElement} element - new element to be appended\n     * @returns {CircularLinkedList}\n     */\n    append(element) {\n        super.append(element);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Insert new element to the list after elementBefore\n     * @param {LinkedListElement} newElement - new element to be inserted\n     * @param {LinkedListElement} elementBefore - element in the list to insert after it\n     * @returns {CircularLinkedList}\n     */\n    insert(newElement, elementBefore) {\n        super.insert(newElement, elementBefore);\n        this.setCircularLinks();\n        return this;\n    }\n\n    /**\n     * Remove element from the list\n     * @param {LinkedListElement} element - element to be removed from the list\n     * @returns {CircularLinkedList}\n     */\n    remove(element) {\n        super.remove(element);\n        // this.setCircularLinks();\n        return this;\n    }\n}\n\n/**\n * Created by Alex Bol on 3/17/2017.\n */\n\n\n/**\n * Class representing a face (closed loop) in a [polygon]{@link Flatten.Polygon} object.\n * Face is a circular bidirectional linked list of [edges]{@link Flatten.Edge}.\n * Face object cannot be instantiated with a constructor.\n * Instead, use [polygon.addFace()]{@link Flatten.Polygon#addFace} method.\n * <br/>\n * Note, that face only set entry point to the linked list of edges but does not contain edges by itself.\n * Container of edges is a property of the polygon object. <br/>\n *\n * @example\n * // Face implements \"next\" iterator which enables to iterate edges in for loop:\n * for (let edge of face) {\n *      console.log(edge.shape.length)     // do something\n * }\n *\n * // Instead, it is possible to iterate edges as linked list, starting from face.first:\n * let edge = face.first;\n * do {\n *   console.log(edge.shape.length);   // do something\n *   edge = edge.next;\n * } while (edge != face.first)\n */\nclass Face extends CircularLinkedList {\n    constructor(polygon, ...args) {\n        super();            // construct empty list of edges\n        /**\n         * Reference to the first edge in face\n         */\n        // this.first;\n        /**\n         * Reference to the last edge in face\n         */\n        // this.last;\n\n        this._box = undefined;  // new Box();\n        this._orientation = undefined;\n\n        if (args.length === 0) {\n            return;\n        }\n\n        /* If passed an array it supposed to be:\n         1) array of shapes that performs close loop or\n         2) array of points that performs set of vertices\n         */\n        if (args.length === 1) {\n            if (args[0] instanceof Array) {\n                // let argsArray = args[0];\n                let shapes = args[0];  // argsArray[0];\n                if (shapes.length === 0)\n                    return;\n\n                /* array of Flatten.Points */\n                if (shapes.every((shape) => {return shape instanceof Flatten.Point})) {\n                    let segments = Face.points2segments(shapes);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of points as pairs of numbers */\n                else if (shapes.every((shape) => {return shape instanceof Array && shape.length === 2})) {\n                    let points = shapes.map((shape) => new Flatten.Point(shape[0],shape[1]));\n                    let segments = Face.points2segments(points);\n                    this.shapes2face(polygon.edges, segments);\n                }\n                /* array of segments ot arcs */\n                else if (shapes.every((shape) => {\n                    return (shape instanceof Flatten.Segment || shape instanceof Flatten.Arc)\n                })) {\n                    this.shapes2face(polygon.edges, shapes);\n                }\n                // this is from JSON.parse object\n                else if (shapes.every((shape) => {\n                    return (shape.name === \"segment\" || shape.name === \"arc\")\n                })) {\n                    let flattenShapes = [];\n                    for (let shape of shapes) {\n                        let flattenShape;\n                        if (shape.name === \"segment\") {\n                            flattenShape = new Flatten.Segment(shape);\n                        } else {\n                            flattenShape = new Flatten.Arc(shape);\n                        }\n                        flattenShapes.push(flattenShape);\n                    }\n                    this.shapes2face(polygon.edges, flattenShapes);\n                }\n            }\n            /* Create new face and copy edges into polygon.edges set */\n            else if (args[0] instanceof Face) {\n                let face = args[0];\n                this.first = face.first;\n                this.last = face.last;\n                for (let edge of face) {\n                    polygon.edges.add(edge);\n                }\n            }\n            /* Instantiate face from a circle in CCW orientation */\n            else if (args[0] instanceof Flatten.Circle) {\n                this.shapes2face(polygon.edges, [args[0].toArc(CCW)]);\n            }\n            /* Instantiate face from a box in CCW orientation */\n            else if (args[0] instanceof Flatten.Box) {\n                let box = args[0];\n                this.shapes2face(polygon.edges, [\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymin), new Flatten.Point(box.xmax, box.ymin)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymin), new Flatten.Point(box.xmax, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmax, box.ymax), new Flatten.Point(box.xmin, box.ymax)),\n                    new Flatten.Segment(new Flatten.Point(box.xmin, box.ymax), new Flatten.Point(box.xmin, box.ymin))\n                ]);\n            }\n        }\n        /* If passed two edges, consider them as start and end of the face loop */\n        /* THIS METHOD WILL BE USED BY BOOLEAN OPERATIONS */\n        /* Assume that edges already copied to polygon.edges set in the clip algorithm !!! */\n        if (args.length === 2 && args[0] instanceof Flatten.Edge && args[1] instanceof Flatten.Edge) {\n            this.first = args[0];                          // first edge in face or undefined\n            this.last = args[1];                           // last edge in face or undefined\n            this.last.next = this.first;\n            this.first.prev = this.last;\n\n            // set arc length\n            this.setArcLength();\n\n            // this.box = this.getBox();\n            // this.orientation = this.getOrientation();      // face direction cw or ccw\n        }\n    }\n\n    /**\n     * Return array of edges from first to last\n     * @returns {Array}\n     */\n    get edges() {\n        return this.toArray();\n    }\n\n    /**\n     * Return array of shapes which comprise face\n     * @returns {Array}\n     */\n    get shapes() {\n        return this.edges.map(edge => edge.shape.clone());\n    }\n\n    /**\n     * Return bounding box of the face\n     * @returns {Box}\n     */\n    get box() {\n        if (this._box === undefined) {\n            let box = new Flatten.Box();\n            for (let edge of this) {\n                box = box.merge(edge.box);\n            }\n            this._box = box;\n        }\n        return this._box;\n    }\n\n    /**\n     * Get all edges length\n     * @returns {number}\n     */\n    get perimeter() {\n        return this.last.arc_length + this.last.length\n    }\n\n    /**\n     * Get point on face boundary at given length\n     * @param {number} length - The length along the face boundary\n     * @returns {Point}\n     */\n    pointAtLength(length) {\n        if (length > this.perimeter || length < 0) return null;\n        let point = null;\n        for (let edge of this) {\n            if (length >= edge.arc_length &&\n                (edge === this.last || length < edge.next.arc_length)) {\n                point = edge.pointAtLength(length - edge.arc_length);\n                break;\n            }\n        }\n        return point;\n    }\n\n    static points2segments(points) {\n        let segments = [];\n        for (let i = 0; i < points.length; i++) {\n            // skip zero length segment\n            if (points[i].equalTo(points[(i + 1) % points.length]))\n                continue;\n            segments.push(new Flatten.Segment(points[i], points[(i + 1) % points.length]));\n        }\n        return segments;\n    }\n\n    shapes2face(edges, shapes) {\n        for (let shape of shapes) {\n            let edge = new Flatten.Edge(shape);\n            this.append(edge);\n            // this.box = this.box.merge(shape.box);\n            edges.add(edge);\n        }\n        // this.orientation = this.getOrientation();              // face direction cw or ccw\n    }\n\n    /**\n     * Append edge after the last edge of the face (and before the first edge). <br/>\n     * @param {Edge} edge - Edge to be appended to the linked list\n     * @returns {Face}\n     */\n    append(edge) {\n        super.append(edge);\n        // set arc length\n        this.setOneEdgeArcLength(edge);\n        edge.face = this;\n        // edges.add(edge);      // Add new edges into edges container\n        return this;\n    }\n\n    /**\n     * Insert edge newEdge into the linked list after the edge edgeBefore <br/>\n     * @param {Edge} newEdge - Edge to be inserted into linked list\n     * @param {Edge} edgeBefore - Edge to insert newEdge after it\n     * @returns {Face}\n     */\n    insert(newEdge, edgeBefore) {\n        super.insert(newEdge, edgeBefore);\n        // set arc length\n        this.setOneEdgeArcLength(newEdge);\n        newEdge.face = this;\n        return this;\n    }\n\n    /**\n     * Remove the given edge from the linked list of the face <br/>\n     * @param {Edge} edge - Edge to be removed\n     * @returns {Face}\n     */\n    remove(edge) {\n        super.remove(edge);\n        // Recalculate arc length\n        this.setArcLength();\n        return this;\n    }\n\n    /**\n     * Merge current edge with the next edge. Given edge will be extended,\n     * next edge after it will be removed. The distortion of the polygon\n     * is on the responsibility of the user of this method\n     * @param {Edge} edge - edge to be extended\n     * @returns {Face}\n     */\n    merge_with_next_edge(edge) {\n        edge.shape.end.x = edge.next.shape.end.x;\n        edge.shape.end.y = edge.next.shape.end.y;\n        this.remove(edge.next);\n        return this;\n    }\n\n    /**\n     * Reverse orientation of the face: first edge become last and vice a verse,\n     * all edges starts and ends swapped, direction of arcs inverted. If face was oriented\n     * clockwise, it becomes counterclockwise and vice versa\n     */\n    reverse() {\n        // collect edges in revert order with reverted shapes\n        let edges = [];\n        let edge_tmp = this.last;\n        do {\n            // reverse shape\n            edge_tmp.shape = edge_tmp.shape.reverse();\n            edges.push(edge_tmp);\n            edge_tmp = edge_tmp.prev;\n        } while (edge_tmp !== this.last);\n\n        // restore linked list\n        this.first = undefined;\n        this.last = undefined;\n        for (let edge of edges) {\n            if (this.first === undefined) {\n                edge.prev = edge;\n                edge.next = edge;\n                this.first = edge;\n                this.last = edge;\n            } else {\n                // append to end\n                edge.prev = this.last;\n                this.last.next = edge;\n\n                // update edge to be last\n                this.last = edge;\n\n                // restore circular links\n                this.last.next = this.first;\n                this.first.prev = this.last;\n\n            }\n            // set arc length\n            this.setOneEdgeArcLength(edge);\n        }\n\n        // Recalculate orientation, if set\n        if (this._orientation !== undefined) {\n            this._orientation = undefined;\n            this._orientation = this.orientation();\n        }\n    }\n\n\n    /**\n     * Set arc_length property for each of the edges in the face.\n     * Arc_length of the edge it the arc length from the first edge of the face\n     */\n    setArcLength() {\n        for (let edge of this) {\n            this.setOneEdgeArcLength(edge);\n            edge.face = this;\n        }\n    }\n\n    setOneEdgeArcLength(edge) {\n        if (edge === this.first) {\n            edge.arc_length = 0.0;\n        } else {\n            edge.arc_length = edge.prev.arc_length + edge.prev.length;\n        }\n    }\n\n    /**\n     * Returns the absolute value of the area of the face\n     * @returns {number}\n     */\n    area() {\n        return Math.abs(this.signedArea());\n    }\n\n    /**\n     * Returns signed area of the simple face.\n     * Face is simple if it has no self intersections that change its orientation.\n     * Then the area will be positive if the orientation of the face is clockwise,\n     * and negative if orientation is counterclockwise.\n     * It may be zero if polygon is degenerated.\n     * @returns {number}\n     */\n    signedArea() {\n        let sArea = 0;\n        let ymin = this.box.ymin;\n        for (let edge of this) {\n            sArea += edge.shape.definiteIntegral(ymin);\n        }\n        return sArea;\n    }\n\n    /**\n     * Return face orientation: one of Flatten.ORIENTATION.CCW, Flatten.ORIENTATION.CW, Flatten.ORIENTATION.NOT_ORIENTABLE <br/>\n     * According to Green theorem the area of a closed curve may be calculated as double integral,\n     * and the sign of the integral will be defined by the direction of the curve.\n     * When the integral (\"signed area\") will be negative, direction is counterclockwise,\n     * when positive - clockwise and when it is zero, polygon is not orientable.\n     * See {@link https://mathinsight.org/greens_theorem_find_area}\n     * @returns {number}\n     */\n    orientation() {\n        if (this._orientation === undefined) {\n            let area = this.signedArea();\n            if (Flatten.Utils.EQ_0(area)) {\n                this._orientation = ORIENTATION.NOT_ORIENTABLE;\n            } else if (Flatten.Utils.LT(area, 0)) {\n                this._orientation = ORIENTATION.CCW;\n            } else {\n                this._orientation = ORIENTATION.CW;\n            }\n        }\n        return this._orientation;\n    }\n\n    /**\n     * Returns true if face of the polygon is simple (no self-intersection points found)\n     * NOTE: this method is incomplete because it does not exclude touching points.\n     * Self intersection test should check if polygon change orientation in the test point.\n     * @param {PlanarSet} edges - reference to polygon edges to provide search index\n     * @returns {boolean}\n     */\n    isSimple(edges) {\n        let ip = Face.getSelfIntersections(this, edges, true);\n        return ip.length === 0;\n    }\n\n    static getSelfIntersections(face, edges, exitOnFirst = false) {\n        let int_points = [];\n\n        // calculate intersections\n        for (let edge1 of face) {\n\n            // request edges of polygon in the box of edge1\n            let resp = edges.search(edge1.box);\n\n            // for each edge2 in response\n            for (let edge2 of resp) {\n\n                // Skip itself\n                if (edge1 === edge2)\n                    continue;\n\n                // Skip is edge2 belongs to another face\n                if (edge2.face !== face)\n                    continue;\n\n                // Skip next and previous edge if both are segment (if one of them arc - calc intersection)\n                if (edge1.shape instanceof Flatten.Segment && edge2.shape instanceof Flatten.Segment &&\n                    (edge1.next === edge2 || edge1.prev === edge2))\n                    continue;\n\n                // calculate intersections between edge1 and edge2\n                let ip = edge1.shape.intersect(edge2.shape);\n\n                // for each intersection point\n                for (let pt of ip) {\n\n                    // skip start-end connections\n                    if (pt.equalTo(edge1.start) && pt.equalTo(edge2.end) && edge2 === edge1.prev)\n                        continue;\n                    if (pt.equalTo(edge1.end) && pt.equalTo(edge2.start) && edge2 === edge1.next)\n                        continue;\n\n                    int_points.push(pt);\n\n                    if (exitOnFirst)\n                        break;\n                }\n\n                if (int_points.length > 0 && exitOnFirst)\n                    break;\n            }\n\n            if (int_points.length > 0 && exitOnFirst)\n                break;\n\n        }\n        return int_points;\n    }\n\n    /**\n     * Returns edge which contains given point\n     * @param {Point} pt - test point\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edgeFound;\n        for (let edge of this) {\n            if (pt.equalTo(edge.shape.start)) continue\n            if (pt.equalTo(edge.shape.end) || edge.shape.contains(pt)) {\n                edgeFound = edge;\n                break;\n            }\n        }\n        return edgeFound;\n    }\n\n    /**\n     * Returns new polygon created from one face\n     * @returns {Polygon}\n     */\n    toPolygon() {\n        return new Flatten.Polygon(this.shapes);\n    }\n\n    toJSON() {\n        return this.edges.map(edge => edge.toJSON());\n    }\n\n    /**\n     * Returns string to be assigned to \"d\" attribute inside defined \"path\"\n     * @returns {string}\n     */\n    svg() {\n        let svgStr = `M${this.first.start.x},${this.first.start.y}`;\n        for (let edge of this) {\n            svgStr += edge.svg();\n        }\n        svgStr += ` z`;\n        return svgStr;\n    }\n\n}\n\nFlatten.Face = Face;\n\n/**\n * Class representing a ray (a half-infinite line).\n * @type {Ray}\n */\nclass Ray extends Shape {\n    /**\n     * Ray may be constructed by setting an <b>origin</b> point and a <b>normal</b> vector, so that any point <b>x</b>\n     * on a ray fit an equation: <br />\n     *  (<b>x</b> - <b>origin</b>) * <b>vector</b> = 0 <br />\n     * Ray defined by constructor is a right semi-infinite line with respect to the normal vector <br/>\n     * If normal vector is omitted ray is considered horizontal (normal vector is (0,1)). <br/>\n     * Don't be confused: direction of the normal vector is orthogonal to the ray <br/>\n     * @param {Point} pt - start point\n     * @param {Vector} norm - normal vector\n     */\n    constructor(...args) {\n        super();\n        this.pt = new Flatten.Point();\n        this.norm = new Flatten.Vector(0,1);\n\n        if (args.length === 0) {\n            return;\n        }\n\n        if (args.length >= 1 && args[0] instanceof Flatten.Point) {\n            this.pt = args[0].clone();\n        }\n\n        if (args.length === 1) {\n            return;\n        }\n\n        if (args.length === 2 && args[1] instanceof Flatten.Vector) {\n            this.norm = args[1].clone();\n            return;\n        }\n\n        throw Errors.ILLEGAL_PARAMETERS;\n    }\n\n    /**\n     * Return new cloned instance of ray\n     * @returns {Ray}\n     */\n    clone() {\n        return new Ray(this.pt, this.norm);\n    }\n\n    /**\n     * Slope of the ray - angle in radians between ray and axe x from 0 to 2PI\n     * @returns {number} - slope of the line\n     */\n    get slope() {\n        let vec = new Flatten.Vector(this.norm.y, -this.norm.x);\n        return vec.slope;\n    }\n\n    /**\n     * Returns half-infinite bounding box of the ray\n     * @returns {Box} - bounding box\n     */\n    get box() {\n        let slope = this.slope;\n        return new Flatten.Box(\n            slope > Math.PI/2 && slope < 3*Math.PI/2 ? Number.NEGATIVE_INFINITY : this.pt.x,\n            slope >= 0 && slope <= Math.PI ? this.pt.y : Number.NEGATIVE_INFINITY,\n            slope >= Math.PI/2 && slope <= 3*Math.PI/2 ? this.pt.x : Number.POSITIVE_INFINITY,\n            slope >= Math.PI && slope <= 2*Math.PI || slope === 0 ? this.pt.y : Number.POSITIVE_INFINITY\n        )\n    }\n\n    /**\n     * Return ray start point\n     * @returns {Point} - ray start point\n     */\n    get start() {\n        return this.pt;\n    }\n\n    /**\n     * Ray has no end point?\n     * @returns {undefined}\n     */\n    get end() {return undefined;}\n\n    /**\n     * Return positive infinity number as length\n     * @returns {number}\n     */\n    get length() {return Number.POSITIVE_INFINITY;}\n\n    /**\n     * Returns true if point belongs to ray\n     * @param {Point} pt Query point\n     * @returns {boolean}\n     */\n    contains(pt) {\n        if (this.pt.equalTo(pt)) {\n            return true;\n        }\n        /* Ray contains point if vector to point is orthogonal to the ray normal vector\n            and cross product from vector to point is positive */\n        let vec = new Flatten.Vector(this.pt, pt);\n        return Flatten.Utils.EQ_0(this.norm.dot(vec)) && Flatten.Utils.GE(vec.cross(this.norm),0);\n    }\n\n    /**\n     * Return coordinate of the point that lies on the ray in the transformed\n     * coordinate system where center is the projection of the point(0,0) to\n     * the line containing this ray and axe y is collinear to the normal vector. <br/>\n     * This method assumes that point lies on the ray\n     * @param {Point} pt - point on a ray\n     * @returns {number}\n     */\n    coord(pt) {\n        return vector$1(pt.x, pt.y).cross(this.norm);\n    }\n\n    /**\n     * Split ray with point and return array of segment and new ray\n     * @param {Point} pt\n     * @returns [Segment,Ray]\n     */\n    split(pt) {\n        if (!this.contains(pt))\n            return [];\n\n        if (this.pt.equalTo(pt)) {\n            return [this]\n        }\n\n        return [\n            new Flatten.Segment(this.pt, pt),\n            new Flatten.Ray(pt, this.norm)\n        ]\n    }\n\n    /**\n     * Returns array of intersection points between ray and another shape\n     * @param {Shape} shape - Shape to intersect with ray\n     * @returns {Point[]} array of intersection points\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectRay2Segment(this, shape);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectRay2Arc(this, shape);\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectRay2Line(this, shape);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Ray(this, shape)\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectRay2Circle(this, shape);\n        }\n\n        if (shape instanceof Flatten.Box) {\n            return intersectRay2Box(this, shape);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return  intersectRay2Polygon(this, shape);\n        }\n    }\n\n    /**\n     * Return new line rotated by angle\n     * @param {number} angle - angle in radians\n     * @param {Point} center - center of rotation\n     */\n    rotate(angle, center = new Flatten.Point()) {\n        return new Flatten.Ray(\n            this.pt.rotate(angle, center),\n            this.norm.rotate(angle)\n        )\n    }\n\n    /**\n     * Return new ray transformed by affine transformation matrix\n     * @param {Matrix} m - affine transformation matrix (a,b,c,d,tx,ty)\n     * @returns {Ray}\n     */\n    transform(m) {\n        return new Flatten.Ray(\n            this.pt.transform(m),\n            this.norm.clone()\n        )\n    }\n\n    get name() {\n        return \"ray\"\n    }\n\n    /**\n     * Return string to draw svg segment representing ray inside given box\n     * @param {Box} box Box representing drawing area\n     * @param {Object} attrs - an object with attributes of svg segment element\n     */\n    svg(box, attrs = {}) {\n        let line = new Flatten.Line(this.pt, this.norm);\n        let ip = intersectLine2Box(line, box);\n        ip = ip.filter( pt => this.contains(pt) );\n        if (ip.length === 0 || ip.length === 2)\n            return \"\";\n        let segment = new Flatten.Segment(this.pt, ip[0]);\n        return segment.svg(attrs);\n    }\n\n}\n\nFlatten.Ray = Ray;\n\nconst ray = (...args) => new Flatten.Ray(...args);\nFlatten.ray = ray;\n\n/**\n * Created by Alex Bol on 3/15/2017.\n */\n\n\n/**\n * Class representing a polygon.<br/>\n * Polygon in FlattenJS is a multipolygon comprised from a set of [faces]{@link Flatten.Face}. <br/>\n * Face, in turn, is a closed loop of [edges]{@link Flatten.Edge}, where edge may be segment or circular arc<br/>\n * @type {Polygon}\n */\nclass Polygon {\n    /**\n     * Constructor creates new instance of polygon. With no arguments new polygon is empty.<br/>\n     * Constructor accepts as argument array that define loop of shapes\n     * or array of arrays in case of multi polygon <br/>\n     * Loop may be defined in different ways: <br/>\n     * - array of shapes of type Segment or Arc <br/>\n     * - array of points (Flatten.Point) <br/>\n     * - array of numeric pairs which represent points <br/>\n     * - box or circle object <br/>\n     * Alternatively, it is possible to use polygon.addFace method\n     * @param {args} - array of shapes or array of arrays\n     */\n    constructor() {\n        /**\n         * Container of faces (closed loops), may be empty\n         * @type {PlanarSet}\n         */\n        this.faces = new Flatten.PlanarSet();\n        /**\n         * Container of edges\n         * @type {PlanarSet}\n         */\n        this.edges = new Flatten.PlanarSet();\n\n        /* It may be array of something that may represent one loop (face) or\n         array of arrays that represent multiple loops\n         */\n        let args = [...arguments];\n        if (args.length === 1 &&\n            ((args[0] instanceof Array && args[0].length > 0) ||\n                args[0] instanceof Flatten.Circle || args[0] instanceof Flatten.Box)) {\n            let argsArray = args[0];\n            if (args[0] instanceof Array && args[0].every((loop) => {\n                return loop instanceof Array\n            })) {\n                if (argsArray.every(el => {\n                    return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\n                })) {\n                    this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon as array of pairs of numbers\n                } else {\n                    for (let loop of argsArray) {   // multi-loop polygon\n                        /* Check extra level of nesting for GeoJSON-style multi polygons */\n                        if (loop instanceof Array && loop[0] instanceof Array &&\n                            loop[0].every(el => {\n                                return el instanceof Array && el.length === 2 && typeof (el[0]) === \"number\" && typeof (el[1]) === \"number\"\n                            })) {\n                            for (let loop1 of loop) {\n                                this.faces.add(new Flatten.Face(this, loop1));\n                            }\n                        } else {\n                            this.faces.add(new Flatten.Face(this, loop));\n                        }\n                    }\n                }\n            } else {\n                this.faces.add(new Flatten.Face(this, argsArray));    // one-loop polygon\n            }\n        }\n    }\n\n    /**\n     * (Getter) Returns bounding box of the polygon\n     * @returns {Box}\n     */\n    get box() {\n        return [...this.faces].reduce((acc, face) => acc.merge(face.box), new Flatten.Box());\n    }\n\n    /**\n     * (Getter) Returns array of vertices\n     * @returns {Array}\n     */\n    get vertices() {\n        return [...this.edges].map(edge => edge.start);\n    }\n\n    /**\n     * Create new cloned instance of the polygon\n     * @returns {Polygon}\n     */\n    clone() {\n        let polygon = new Polygon();\n        for (let face of this.faces) {\n            polygon.addFace(face.shapes);\n        }\n        return polygon;\n    }\n\n    /**\n     * Return true is polygon has no edges\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.edges.size === 0;\n    }\n\n    /**\n     * Return true if polygon is valid for boolean operations\n     * Polygon is valid if <br/>\n     * 1. All faces are simple polygons (there are no self-intersected polygons) <br/>\n     * 2. All faces are orientable and there is no island inside island or hole inside hole - TODO <br/>\n     * 3. There is no intersections between faces (excluding touching) - TODO <br/>\n     * @returns {boolean}\n     */\n    isValid() {\n        let valid = true;\n        // 1. Polygon is invalid if at least one face is not simple\n        for (let face of this.faces) {\n            if (!face.isSimple(this.edges)) {\n                valid = false;\n                break;\n            }\n        }\n        // 2. TODO: check if no island inside island and no hole inside hole\n        // 3. TODO: check the there is no intersection between faces\n        return valid;\n    }\n\n    /**\n     * Returns area of the polygon. Area of an island will be added, area of a hole will be subtracted\n     * @returns {number}\n     */\n    area() {\n        let signedArea = [...this.faces].reduce((acc, face) => acc + face.signedArea(), 0);\n        return Math.abs(signedArea);\n    }\n\n    /**\n     * Add new face to polygon. Returns added face\n     * @param {Point[]|Segment[]|Arc[]|Circle|Box} args -  new face may be create with one of the following ways: <br/>\n     * 1) array of points that describe closed path (edges are segments) <br/>\n     * 2) array of shapes (segments and arcs) which describe closed path <br/>\n     * 3) circle - will be added as counterclockwise arc <br/>\n     * 4) box - will be added as counterclockwise rectangle <br/>\n     * You can chain method face.reverse() is you need to change direction of the creates face\n     * @returns {Face}\n     */\n    addFace(...args) {\n        let face = new Flatten.Face(this, ...args);\n        this.faces.add(face);\n        return face;\n    }\n\n    /**\n     * Delete existing face from polygon\n     * @param {Face} face Face to be deleted\n     * @returns {boolean}\n     */\n    deleteFace(face) {\n        for (let edge of face) {\n            this.edges.delete(edge);\n        }\n        return this.faces.delete(face);\n    }\n\n    /**\n     * Clear all faces and create new faces from edges\n     */\n    recreateFaces() {\n        // Remove all faces\n        this.faces.clear();\n        for (let edge of this.edges) {\n            edge.face = null;\n        }\n\n        // Restore faces\n        let first;\n        let unassignedEdgeFound = true;\n        while (unassignedEdgeFound) {\n            unassignedEdgeFound = false;\n            for (let edge of this.edges) {\n                if (edge.face === null) {\n                    first = edge;\n                    unassignedEdgeFound = true;\n                    break;\n                }\n            }\n\n            if (unassignedEdgeFound) {\n                let last = first;\n                do {\n                    last = last.next;\n                } while (last.next !== first)\n\n                this.addFace(first, last);\n            }\n        }\n    }\n\n    /**\n     * Delete chain of edges from the face.\n     * @param {Face} face Face to remove chain\n     * @param {Edge} edgeFrom Start of the chain of edges to be removed\n     * @param {Edge} edgeTo End of the chain of edges to be removed\n     */\n    removeChain(face, edgeFrom, edgeTo) {\n        // Special case: all edges removed\n        if (edgeTo.next === edgeFrom) {\n            this.deleteFace(face);\n            return;\n        }\n        for (let edge = edgeFrom; edge !== edgeTo.next; edge = edge.next) {\n            face.remove(edge);\n            this.edges.delete(edge);      // delete from PlanarSet of edges and update index\n            if (face.isEmpty()) {\n                this.deleteFace(face);    // delete from PlanarSet of faces and update index\n                break;\n            }\n        }\n    }\n\n    /**\n     * Add point as a new vertex and split edge. Point supposed to belong to an edge.\n     * When edge is split, new edge created from the start of the edge to the new vertex\n     * and inserted before current edge.\n     * Current edge is trimmed and updated.\n     * Method returns new edge added. If no edge added, it returns edge before vertex\n     * @param {Point} pt Point to be added as a new vertex\n     * @param {Edge} edge Edge to be split with new vertex and then trimmed from start\n     * @returns {Edge}\n     */\n    addVertex(pt, edge) {\n        let shapes = edge.shape.split(pt);\n        // if (shapes.length < 2) return;\n\n        if (shapes[0] === null)   // point incident to edge start vertex, return previous edge\n            return edge.prev;\n\n        if (shapes[1] === null)   // point incident to edge end vertex, return edge itself\n            return edge;\n\n        let newEdge = new Flatten.Edge(shapes[0]);\n        let edgeBefore = edge.prev;\n\n        /* Insert first split edge into linked list after edgeBefore */\n        edge.face.insert(newEdge, edgeBefore);\n\n        // Remove old edge from edges container and 2d index\n        this.edges.delete(edge);\n\n        // Insert new edge to the edges container and 2d index\n        this.edges.add(newEdge);\n\n        // Update edge shape with second split edge keeping links\n        edge.shape = shapes[1];\n\n        // Add updated edge to the edges container and 2d index\n        this.edges.add(edge);\n\n        return newEdge;\n    }\n\n    /**\n     * Merge given edge with next edge and remove vertex between them\n     * @param {Edge} edge\n     */\n    removeEndVertex(edge) {\n        const edge_next = edge.next;\n        if (edge_next === edge) return\n        edge.face.merge_with_next_edge(edge);\n        this.edges.delete(edge_next);\n    }\n\n    /**\n     * Cut polygon with multiline and return a new polygon\n     * @param {Multiline} multiline\n     * @returns {Polygon}\n     */\n    cut(multiline) {\n        let newPoly = this.clone();\n\n        // smart intersections\n        let intersections = {\n            int_points1: [],\n            int_points2: [],\n            int_points1_sorted: [],\n            int_points2_sorted: []\n        };\n\n        // intersect each edge of multiline with each edge of the polygon\n        // and create smart intersections\n        for (let edge1 of multiline.edges) {\n            for (let edge2 of newPoly.edges) {\n                let ip = intersectEdge2Edge(edge1, edge2);\n                // for each intersection point\n                for (let pt of ip) {\n                    addToIntPoints(edge1, pt, intersections.int_points1);\n                    addToIntPoints(edge2, pt, intersections.int_points2);\n                }\n            }\n        }\n\n        // No intersections - return a copy of the original polygon\n        if (intersections.int_points1.length === 0)\n            return newPoly;\n\n        // sort smart intersections\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // split by intersection points\n        splitByIntersections(multiline, intersections.int_points1_sorted);\n        splitByIntersections(newPoly, intersections.int_points2_sorted);\n\n        // filter duplicated intersection points\n        filterDuplicatedIntersections(intersections);\n\n        // sort intersection points again after filtering\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // initialize inclusion flags for edges of multiline incident to intersections\n        initializeInclusionFlags(intersections.int_points1);\n\n        // calculate inclusion flag for edges of multiline incident to intersections\n        calculateInclusionFlags(intersections.int_points1, newPoly);\n\n        // filter intersections between two edges that got same inclusion flag\n        for (let int_point1 of intersections.int_points1_sorted) {\n            if (int_point1.edge_before && int_point1.edge_after &&\n                int_point1.edge_before.bv === int_point1.edge_after.bv) {\n                intersections.int_points2[int_point1.id] = -1;   // to be filtered out\n                int_point1.id = -1;                              // to be filtered out\n            }\n        }\n        intersections.int_points1 = intersections.int_points1.filter( int_point => int_point.id >= 0);\n        intersections.int_points2 = intersections.int_points2.filter( int_point => int_point.id >= 0);\n        intersections.int_points1.forEach((int_point, index) => { int_point.id = index; });\n        intersections.int_points2.forEach((int_point, index) => { int_point.id = index; });\n\n\n        // No intersections left after filtering - return a copy of the original polygon\n        if (intersections.int_points1.length === 0)\n            return newPoly;\n\n        // sort intersection points 3d time after filtering\n        intersections.int_points1_sorted = getSortedArray(intersections.int_points1);\n        intersections.int_points2_sorted = getSortedArray(intersections.int_points2);\n\n        // Add new inner edges between intersection points\n        let int_point1_prev;\n        let int_point1_curr;\n        for (let i = 1; i <  intersections.int_points1_sorted.length; i++) {\n            int_point1_curr = intersections.int_points1_sorted[i];\n            int_point1_prev = intersections.int_points1_sorted[i-1];\n            if (int_point1_curr.edge_before && int_point1_curr.edge_before.bv === INSIDE$2) {\n                let edgeFrom = int_point1_prev.edge_after;\n                let edgeTo = int_point1_curr.edge_before;\n                let newEdges = multiline.getChain(edgeFrom, edgeTo);\n                insertBetweenIntPoints(intersections.int_points2[int_point1_prev.id], intersections.int_points2[int_point1_curr.id], newEdges);\n                newEdges.forEach(edge => newPoly.edges.add(edge));\n\n                newEdges = newEdges.reverse().map(edge => new Flatten.Edge(edge.shape.reverse()));\n                for (let k=0; k < newEdges.length-1; k++) {\n                    newEdges[k].next = newEdges[k+1];\n                    newEdges[k+1].prev = newEdges[k];\n                }\n                insertBetweenIntPoints(intersections.int_points2[int_point1_curr.id], intersections.int_points2[int_point1_prev.id], newEdges);\n                newEdges.forEach(edge => newPoly.edges.add(edge));\n            }\n\n        }\n\n        // Recreate faces\n        newPoly.recreateFaces();\n\n        return newPoly\n    }\n\n    /**\n     * A special case of cut() function\n     * The return is a polygon cut with line\n     * @param {Line} line - cutting line\n     * @returns {Polygon} newPoly - resulted polygon\n     */\n    cutWithLine(line) {\n        let multiline = new Multiline([line]);\n        return this.cut(multiline);\n    }\n\n    /**\n     * Returns the first found edge of polygon that contains given point\n     * If point is a vertex, return the edge where the point is an end vertex, not a start one\n     * @param {Point} pt\n     * @returns {Edge}\n     */\n    findEdgeByPoint(pt) {\n        let edge;\n        for (let face of this.faces) {\n            edge = face.findEdgeByPoint(pt);\n            if (edge !== undefined)\n                break;\n        }\n        return edge;\n    }\n\n    /**\n     * Split polygon into array of polygons, where each polygon is an outer face with all\n     * containing inner faces\n     * @returns {Flatten.Polygon[]}\n     */\n    splitToIslands() {\n        if (this.isEmpty()) return [];      // return empty array if polygon is empty\n        let polygons = this.toArray();      // split into array of one-loop polygons\n        /* Sort polygons by area in descending order */\n        polygons.sort((polygon1, polygon2) => polygon2.area() - polygon1.area());\n        /* define orientation of the island by orientation of the first polygon in array */\n        let orientation = [...polygons[0].faces][0].orientation();\n        /* Create output array from polygons with same orientation as a first polygon (array of islands) */\n        let newPolygons = polygons.filter(polygon => [...polygon.faces][0].orientation() === orientation);\n        for (let polygon of polygons) {\n            let face = [...polygon.faces][0];\n            if (face.orientation() === orientation) continue;  // skip same orientation\n            /* Proceed with opposite orientation */\n            /* Look if any of island polygons contains tested polygon as a hole */\n            for (let islandPolygon of newPolygons) {\n                if (face.shapes.every(shape => islandPolygon.contains(shape))) {\n                    islandPolygon.addFace(face.shapes);      // add polygon as a hole in islandPolygon\n                    break;\n                }\n            }\n        }\n        // TODO: assert if not all polygons added into output\n        return newPolygons;\n    }\n\n    /**\n     * Reverse orientation of all faces to opposite\n     * @returns {Polygon}\n     */\n    reverse() {\n        for (let face of this.faces) {\n            face.reverse();\n        }\n        return this;\n    }\n\n    /**\n     * Returns true if polygon contains shape: no point of shape lay outside of the polygon,\n     * false otherwise\n     * @param {Shape} shape - test shape\n     * @returns {boolean}\n     */\n    contains(shape) {\n        if (shape instanceof Flatten.Point) {\n            let rel = ray_shoot(this, shape);\n            return rel === INSIDE$2 || rel === BOUNDARY$1;\n        } else {\n            return cover(this, shape);\n        }\n    }\n\n    /**\n     * Return distance and shortest segment between polygon and other shape as array [distance, shortest_segment]\n     * @param {Shape} shape Shape of one of the types Point, Circle, Line, Segment, Arc or Polygon\n     * @returns {Number | Segment}\n     */\n    distanceTo(shape) {\n        // let {Distance} = Flatten;\n\n        if (shape instanceof Flatten.Point) {\n            let [dist, shortest_segment] = Flatten.Distance.point2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        if (shape instanceof Flatten.Circle ||\n            shape instanceof Flatten.Line ||\n            shape instanceof Flatten.Segment ||\n            shape instanceof Flatten.Arc) {\n            let [dist, shortest_segment] = Flatten.Distance.shape2polygon(shape, this);\n            shortest_segment = shortest_segment.reverse();\n            return [dist, shortest_segment];\n        }\n\n        /* this method is bit faster */\n        if (shape instanceof Flatten.Polygon) {\n            let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n            let dist, shortest_segment;\n\n            for (let edge of this.edges) {\n                // let [dist, shortest_segment] = Distance.shape2polygon(edge.shape, shape);\n                let min_stop = min_dist_and_segment[0];\n                [dist, shortest_segment] = Flatten.Distance.shape2planarSet(edge.shape, shape.edges, min_stop);\n                if (Flatten.Utils.LT(dist, min_stop)) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n            return min_dist_and_segment;\n        }\n    }\n\n    /**\n     * Return array of intersection points between polygon and other shape\n     * @param shape Shape of the one of supported types <br/>\n     * @returns {Point[]}\n     */\n    intersect(shape) {\n        if (shape instanceof Flatten.Point) {\n            return this.contains(shape) ? [shape] : [];\n        }\n\n        if (shape instanceof Flatten.Line) {\n            return intersectLine2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Ray) {\n            return intersectRay2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Circle) {\n            return intersectCircle2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Segment) {\n            return intersectSegment2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Arc) {\n            return intersectArc2Polygon(shape, this);\n        }\n\n        if (shape instanceof Flatten.Polygon) {\n            return intersectPolygon2Polygon(shape, this);\n        }\n    }\n\n    /**\n     * Returns new polygon translated by vector vec\n     * @param {Vector} vec\n     * @returns {Polygon}\n     */\n    translate(vec) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.translate(vec)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon rotated by given angle around given point\n     * If point omitted, rotate around origin (0,0)\n     * Positive value of angle defines rotation counterclockwise, negative - clockwise\n     * @param {number} angle - rotation angle in radians\n     * @param {Point} center - rotation center, default is (0,0)\n     * @returns {Polygon} - new rotated polygon\n     */\n    rotate(angle = 0, center = new Flatten.Point()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.rotate(angle, center)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon with coordinates multiplied by scaling factor\n     * @param {number} sx - x-axis scaling factor\n     * @param {number} sy - y-axis scaling factor\n     * @returns {Polygon}\n     */\n    scale(sx, sy) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.scale(sx, sy)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * Return new polygon transformed using affine transformation matrix\n     * @param {Matrix} matrix - affine transformation matrix\n     * @returns {Polygon} - new polygon\n     */\n    transform(matrix = new Flatten.Matrix()) {\n        let newPolygon = new Polygon();\n        for (let face of this.faces) {\n            newPolygon.addFace(face.shapes.map(shape => shape.transform(matrix)));\n        }\n        return newPolygon;\n    }\n\n    /**\n     * This method returns an object that defines how data will be\n     * serialized when called JSON.stringify() method\n     * @returns {Object}\n     */\n    toJSON() {\n        return [...this.faces].map(face => face.toJSON());\n    }\n\n    /**\n     * Transform all faces into array of polygons\n     * @returns {Flatten.Polygon[]}\n     */\n    toArray() {\n        return [...this.faces].map(face => face.toPolygon());\n    }\n\n    /**\n     * Return string to be assigned to 'd' attribute of <path> element\n     * @returns {*}\n     */\n    dpath() {\n        return [...this.faces].reduce((acc, face) => acc + face.svg(), \"\")\n    }\n\n    /**\n     * Return string to draw polygon in svg\n     * @param attrs  - an object with attributes for svg path element\n     * @returns {string}\n     */\n    svg(attrs = {}) {\n        let svgStr = `\\n<path ${convertToString({fillRule: \"evenodd\", fill: \"lightcyan\", ...attrs})} d=\"`;\n        for (let face of this.faces) {\n            svgStr += `\\n${face.svg()}` ;\n        }\n        svgStr += `\" >\\n</path>`;\n        return svgStr;\n    }\n}\n\nFlatten.Polygon = Polygon;\n\n/**\n * Shortcut method to create new polygon\n */\nconst polygon = (...args) => new Flatten.Polygon(...args);\nFlatten.polygon = polygon;\n\nconst {Circle, Line, Point, Vector, Utils} = Flatten;\n/**\n * Class Inversion represent operator of inversion in circle\n * Inversion is a transformation of the Euclidean plane that maps generalized circles\n * (where line is considered as a circle with infinite radius) into generalized circles\n * See also https://en.wikipedia.org/wiki/Inversive_geometry and\n * http://mathworld.wolfram.com/Inversion.html <br/>\n * @type {Inversion}\n */\nclass Inversion {\n    /**\n     * Inversion constructor\n     * @param {Circle} inversion_circle inversion circle\n     */\n    constructor(inversion_circle) {\n        this.circle = inversion_circle;\n    }\n\n\n    get inversion_circle() {\n        return this.circle;\n    }\n\n    static inversePoint(inversion_circle, point) {\n        const v = new Vector(inversion_circle.pc, point);\n        const k2 = inversion_circle.r * inversion_circle.r;\n        const len2 = v.dot(v);\n        const reflected_point = Utils.EQ_0(len2) ?\n            new Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY) :\n            inversion_circle.pc.translate(v.multiply(k2 / len2));\n        return reflected_point;\n    }\n\n    static inverseCircle(inversion_circle, circle) {\n        const dist = inversion_circle.pc.distanceTo(circle.pc)[0];\n        if (Utils.EQ(dist, circle.r)) {     // Circle passing through inversion center mapped into line\n            let d = (inversion_circle.r * inversion_circle.r) / (2 * circle.r);\n            let v = new Vector(inversion_circle.pc, circle.pc);\n            v = v.normalize();\n            let pt = inversion_circle.pc.translate(v.multiply(d));\n\n            return new Line(pt, v);\n        } else {                           // Circle not passing through inversion center - map into another circle */\n            /* Taken from http://mathworld.wolfram.com */\n            let v = new Vector(inversion_circle.pc, circle.pc);\n            let s = inversion_circle.r * inversion_circle.r / (v.dot(v) - circle.r * circle.r);\n            let pc = inversion_circle.pc.translate(v.multiply(s));\n            let r = Math.abs(s) * circle.r;\n\n            return new Circle(pc, r);\n        }\n    }\n\n    static inverseLine(inversion_circle, line) {\n        const [dist, shortest_segment] = inversion_circle.pc.distanceTo(line);\n        if (Utils.EQ_0(dist)) {            // Line passing through inversion center, is mapping to itself\n            return line.clone();\n        } else {                           // Line not passing through inversion center is mapping into circle\n            let r = inversion_circle.r * inversion_circle.r / (2 * dist);\n            let v = new Vector(inversion_circle.pc, shortest_segment.end);\n            v = v.multiply(r / dist);\n            return new Circle(inversion_circle.pc.translate(v), r);\n        }\n    }\n\n    inverse(shape) {\n        if (shape instanceof Point) {\n            return Inversion.inversePoint(this.circle, shape);\n        }\n        else if (shape instanceof Circle) {\n            return Inversion.inverseCircle(this.circle, shape);\n        }\n        else if (shape instanceof Line) {\n            return Inversion.inverseLine(this.circle, shape);\n        }\n    }\n}\nFlatten.Inversion = Inversion;\n\n/**\n * Shortcut to create inversion operator\n * @param circle\n * @returns {Inversion}\n */\nconst inversion = (circle) => new Flatten.Inversion(circle);\nFlatten.inversion = inversion;\n\nclass Distance {\n    /**\n     * Calculate distance and shortest segment between points\n     * @param pt1\n     * @param pt2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2point(pt1, pt2) {\n        return pt1.distanceTo(pt2);\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and line\n     * @param pt\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2line(pt, line) {\n        let closest_point = pt.projectionOn(line);\n        let vec = new Flatten.Vector(pt, closest_point);\n        return [vec.length, new Flatten.Segment(pt, closest_point)];\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and circle\n     * @param pt\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2circle(pt, circle) {\n        let [dist2center, shortest_dist] = pt.distanceTo(circle.center);\n        if (Flatten.Utils.EQ_0(dist2center)) {\n            return [circle.r, new Flatten.Segment(pt, circle.toArc().start)];\n        } else {\n            let dist = Math.abs(dist2center - circle.r);\n            let v = new Flatten.Vector(circle.pc, pt).normalize().multiply(circle.r);\n            let closest_point = circle.pc.translate(v);\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and segment\n     * @param pt\n     * @param segment\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2segment(pt, segment) {\n        /* Degenerated case of zero-length segment */\n        if (segment.start.equalTo(segment.end)) {\n            return Distance.point2point(pt, segment.start);\n        }\n\n        let v_seg = new Flatten.Vector(segment.start, segment.end);\n        let v_ps2pt = new Flatten.Vector(segment.start, pt);\n        let v_pe2pt = new Flatten.Vector(segment.end, pt);\n        let start_sp = v_seg.dot(v_ps2pt);\n        /* dot product v_seg * v_ps2pt */\n        let end_sp = -v_seg.dot(v_pe2pt);\n        /* minus dot product v_seg * v_pe2pt */\n\n        let dist;\n        let closest_point;\n        if (Flatten.Utils.GE(start_sp, 0) && Flatten.Utils.GE(end_sp, 0)) {    /* point inside segment scope */\n            let v_unit = segment.tangentInStart(); // new Flatten.Vector(v_seg.x / this.length, v_seg.y / this.length);\n            /* unit vector ||v_unit|| = 1 */\n            dist = Math.abs(v_unit.cross(v_ps2pt));\n            /* dist = abs(v_unit x v_ps2pt) */\n            closest_point = segment.start.translate(v_unit.multiply(v_unit.dot(v_ps2pt)));\n            return [dist, new Flatten.Segment(pt, closest_point)];\n        } else if (start_sp < 0) {                             /* point is out of scope closer to ps */\n            return pt.distanceTo(segment.start);\n        } else {                                               /* point is out of scope closer to pe */\n            return pt.distanceTo(segment.end);\n        }\n    };\n\n    /**\n     * Calculate distance and shortest segment between point and arc\n     * @param pt\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2arc(pt, arc) {\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n        let dist_and_segment = [];\n        let dist, shortest_segment;\n        [dist, shortest_segment] = Distance.point2circle(pt, circle);\n        if (shortest_segment.end.on(arc)) {\n            dist_and_segment.push(Distance.point2circle(pt, circle));\n        }\n        dist_and_segment.push(Distance.point2point(pt, arc.start));\n        dist_and_segment.push(Distance.point2point(pt, arc.end));\n\n        Distance.sort(dist_and_segment);\n\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and line\n     * @param seg\n     * @param line\n     * @returns {Number | Segment}\n     */\n    static segment2line(seg, line) {\n        let ip = seg.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2line(seg.start, line));\n        dist_and_segment.push(Distance.point2line(seg.end, line));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n\n    }\n\n    /**\n     * Calculate distance and shortest segment between two segments\n     * @param seg1\n     * @param seg2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2segment(seg1, seg2) {\n        let ip = intersectSegment2Segment(seg1, seg2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];   // distance = 0, closest point is the first point\n        }\n\n        // Seg1 and seg2 not intersected\n        let dist_and_segment = [];\n        let dist_tmp, shortest_segment_tmp;\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.start, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        [dist_tmp, shortest_segment_tmp] = Distance.point2segment(seg2.end, seg1);\n        dist_and_segment.push([dist_tmp, shortest_segment_tmp.reverse()]);\n        dist_and_segment.push(Distance.point2segment(seg1.start, seg2));\n        dist_and_segment.push(Distance.point2segment(seg1.end, seg2));\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and circle\n     * @param seg\n     * @param circle\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2circle(seg, circle) {\n        /* Case 1 Segment and circle intersected. Return the first point and zero distance */\n        let ip = seg.intersect(circle);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and circle\n\n        /* Case 2. Distance to projection of center point to line bigger than radius\n         * And projection point belong to segment\n          * Then measure again distance from projection to circle and return it */\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let [dist, shortest_segment] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist, circle.r) && shortest_segment.end.on(seg)) {\n            return Distance.point2circle(shortest_segment.end, circle);\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        else {\n            let [dist_from_start, shortest_segment_from_start] = Distance.point2circle(seg.start, circle);\n            let [dist_from_end, shortest_segment_from_end] = Distance.point2circle(seg.end, circle);\n            return Flatten.Utils.LT(dist_from_start, dist_from_end) ?\n                [dist_from_start, shortest_segment_from_start] :\n                [dist_from_end, shortest_segment_from_end];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between segment and arc\n     * @param seg\n     * @param arc\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static segment2arc(seg, arc) {\n        /* Case 1 Segment and arc intersected. Return the first point and zero distance */\n        let ip = seg.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // No intersection between segment and arc\n        let line = new Flatten.Line(seg.ps, seg.pe);\n        let circle = new Flatten.Circle(arc.pc, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r) && shortest_segment_from_center.end.on(seg)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        }\n        /* Case 3. Otherwise closest point is one of the end points of the segment */\n        let dist_and_segment = [];\n        dist_and_segment.push(Distance.point2arc(seg.start, arc));\n        dist_and_segment.push(Distance.point2arc(seg.end, arc));\n\n        let dist_tmp, segment_tmp;\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.start, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        [dist_tmp, segment_tmp] = Distance.point2segment(arc.end, seg);\n        dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n\n        Distance.sort(dist_and_segment);\n        return dist_and_segment[0];\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle1\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2circle(circle1, circle2) {\n        let ip = circle1.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        // Case 1. Concentric circles. Convert to arcs and take distance between two arc starts\n        if (circle1.center.equalTo(circle2.center)) {\n            let arc1 = circle1.toArc();\n            let arc2 = circle2.toArc();\n            return Distance.point2point(arc1.start, arc2.start);\n        } else {\n            // Case 2. Not concentric circles\n            let line = new Flatten.Line(circle1.center, circle2.center);\n            let ip1 = line.intersect(circle1);\n            let ip2 = line.intersect(circle2);\n\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[0], ip2[1]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[0]));\n            dist_and_segment.push(Distance.point2point(ip1[1], ip2[1]));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two circles\n     * @param circle\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static circle2line(circle, line) {\n        let ip = circle.intersect(line);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        let [dist, shortest_segment] = Distance.point2circle(shortest_segment_from_center.end, circle);\n        shortest_segment = shortest_segment.reverse();\n        return [dist, shortest_segment];\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and line\n     * @param arc\n     * @param line\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2line(arc, line) {\n        /* Case 1 Line and arc intersected. Return the first point and zero distance */\n        let ip = line.intersect(arc);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle = new Flatten.Circle(arc.center, arc.r);\n\n        /* Case 2. Distance to projection of center point to line bigger than radius AND\n         * projection point belongs to segment AND\n           * distance from projection point to circle belongs to arc  =>\n           * return this distance from projection to circle */\n        let [dist_from_center, shortest_segment_from_center] = Distance.point2line(circle.center, line);\n        if (Flatten.Utils.GE(dist_from_center, circle.r)) {\n            let [dist_from_projection, shortest_segment_from_projection] =\n                Distance.point2circle(shortest_segment_from_center.end, circle);\n            if (shortest_segment_from_projection.end.on(arc)) {\n                return [dist_from_projection, shortest_segment_from_projection];\n            }\n        } else {\n            let dist_and_segment = [];\n            dist_and_segment.push(Distance.point2line(arc.start, line));\n            dist_and_segment.push(Distance.point2line(arc.end, line));\n\n            Distance.sort(dist_and_segment);\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between arc and circle\n     * @param arc\n     * @param circle2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2circle(arc, circle2) {\n        let ip = arc.intersect(circle2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc.center, arc.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            dist_and_segment.push(Distance.point2circle(arc.start, circle2));\n            dist_and_segment.push(Distance.point2circle(arc.end, circle2));\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between two arcs\n     * @param arc1\n     * @param arc2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static arc2arc(arc1, arc2) {\n        let ip = arc1.intersect(arc2);\n        if (ip.length > 0) {\n            return [0, new Flatten.Segment(ip[0], ip[0])];\n        }\n\n        let circle1 = new Flatten.Circle(arc1.center, arc1.r);\n        let circle2 = new Flatten.Circle(arc2.center, arc2.r);\n\n        let [dist, shortest_segment] = Distance.circle2circle(circle1, circle2);\n        if (shortest_segment.start.on(arc1) && shortest_segment.end.on(arc2)) {\n            return [dist, shortest_segment];\n        } else {\n            let dist_and_segment = [];\n\n            let dist_tmp, segment_tmp;\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.start, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc1.end, arc2);\n            if (segment_tmp.end.on(arc2)) {\n                dist_and_segment.push([dist_tmp, segment_tmp]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.start, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2arc(arc2.end, arc1);\n            if (segment_tmp.end.on(arc1)) {\n                dist_and_segment.push([dist_tmp, segment_tmp.reverse()]);\n            }\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.start, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.start);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            [dist_tmp, segment_tmp] = Distance.point2point(arc1.end, arc2.end);\n            dist_and_segment.push([dist_tmp, segment_tmp]);\n\n            Distance.sort(dist_and_segment);\n\n            return dist_and_segment[0];\n        }\n    }\n\n    /**\n     * Calculate distance and shortest segment between point and polygon\n     * @param point\n     * @param polygon\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static point2polygon(point, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = (edge.shape instanceof Flatten.Segment) ?\n                Distance.point2segment(point, edge.shape) : Distance.point2arc(point, edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    static shape2polygon(shape, polygon) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge of polygon.edges) {\n            let [dist, shortest_segment] = shape.distanceTo(edge.shape);\n            if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                min_dist_and_segment = [dist, shortest_segment];\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Calculate distance and shortest segment between two polygons\n     * @param polygon1\n     * @param polygon2\n     * @returns {Number | Segment} - distance and shortest segment\n     */\n    static polygon2polygon(polygon1, polygon2) {\n        let min_dist_and_segment = [Number.POSITIVE_INFINITY, new Flatten.Segment()];\n        for (let edge1 of polygon1.edges) {\n            for (let edge2 of polygon2.edges) {\n                let [dist, shortest_segment] = edge1.shape.distanceTo(edge2.shape);\n                if (Flatten.Utils.LT(dist, min_dist_and_segment[0])) {\n                    min_dist_and_segment = [dist, shortest_segment];\n                }\n            }\n        }\n        return min_dist_and_segment;\n    }\n\n    /**\n     * Returns [mindist, maxdist] array of squared minimal and maximal distance between boxes\n     * Minimal distance by x is\n     *    (box2.xmin - box1.xmax), if box1 is left to box2\n     *    (box1.xmin - box2.xmax), if box2 is left to box1\n     *    0,                       if box1 and box2 are intersected by x\n     * Minimal distance by y is defined in the same way\n     *\n     * Maximal distance is estimated as a sum of squared dimensions of the merged box\n     *\n     * @param box1\n     * @param box2\n     * @returns {Number | Number} - minimal and maximal distance\n     */\n    static box2box_minmax(box1, box2) {\n        let mindist_x = Math.max(Math.max(box1.xmin - box2.xmax, 0), Math.max(box2.xmin - box1.xmax, 0));\n        let mindist_y = Math.max(Math.max(box1.ymin - box2.ymax, 0), Math.max(box2.ymin - box1.ymax, 0));\n        let mindist = mindist_x * mindist_x + mindist_y * mindist_y;\n\n        let box = box1.merge(box2);\n        let dx = box.xmax - box.xmin;\n        let dy = box.ymax - box.ymin;\n        let maxdist = dx * dx + dy * dy;\n\n        return [mindist, maxdist];\n    }\n\n    static minmax_tree_process_level(shape, level, min_stop, tree) {\n        // Calculate minmax distance to each shape in current level\n        // Insert result into the interval tree for further processing\n        // update min_stop with maxdist, it will be the new stop distance\n        let mindist, maxdist;\n        for (let node of level) {\n\n            // [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            // if (Flatten.Utils.GT(mindist, min_stop))\n            //     continue;\n\n            // Estimate min-max dist to the shape stored in the node.item, using node.item.key which is shape's box\n            [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.item.key);\n            if (node.item.value instanceof Flatten.Edge) {\n                tree.insert([mindist, maxdist], node.item.value.shape);\n            } else {\n                tree.insert([mindist, maxdist], node.item.value);\n            }\n            if (Flatten.Utils.LT(maxdist, min_stop)) {\n                min_stop = maxdist;                       // this will be the new distance estimation\n            }\n        }\n\n        if (level.length === 0)\n            return min_stop;\n\n        // Calculate new level from left and right children of the current\n        let new_level_left = level.map(node => node.left.isNil() ? undefined : node.left).filter(node => node !== undefined);\n        let new_level_right = level.map(node => node.right.isNil() ? undefined : node.right).filter(node => node !== undefined);\n        // Merge left and right subtrees and leave only relevant subtrees\n        let new_level = [...new_level_left, ...new_level_right].filter(node => {\n            // Node subtree quick reject, node.max is a subtree box\n            let [mindist, maxdist] = Distance.box2box_minmax(shape.box, node.max);\n            return (Flatten.Utils.LE(mindist, min_stop));\n        });\n\n        min_stop = Distance.minmax_tree_process_level(shape, new_level, min_stop, tree);\n        return min_stop;\n    }\n\n    /**\n     * Calculates sorted tree of [mindist, maxdist] intervals between query shape\n     * and shapes of the planar set.\n     * @param shape\n     * @param set\n     */\n    static minmax_tree(shape, set, min_stop) {\n        let tree = new IntervalTree();\n        let level = [set.index.root];\n        let squared_min_stop = min_stop < Number.POSITIVE_INFINITY ? min_stop * min_stop : Number.POSITIVE_INFINITY;\n        squared_min_stop = Distance.minmax_tree_process_level(shape, level, squared_min_stop, tree);\n        return tree;\n    }\n\n    static minmax_tree_calc_distance(shape, node, min_dist_and_segment) {\n        let min_dist_and_segment_new, stop;\n        if (node != null && !node.isNil()) {\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.left, min_dist_and_segment);\n\n            if (stop) {\n                return [min_dist_and_segment_new, stop];\n            }\n\n            if (Flatten.Utils.LT(min_dist_and_segment_new[0], Math.sqrt(node.item.key.low))) {\n                return [min_dist_and_segment_new, true];   // stop condition\n            }\n\n            let [dist, shortest_segment] = Distance.distance(shape, node.item.value);\n            // console.log(dist)\n            if (Flatten.Utils.LT(dist, min_dist_and_segment_new[0])) {\n                min_dist_and_segment_new = [dist, shortest_segment];\n            }\n\n            [min_dist_and_segment_new, stop] = Distance.minmax_tree_calc_distance(shape, node.right, min_dist_and_segment_new);\n\n            return [min_dist_and_segment_new, stop];\n        }\n\n        return [min_dist_and_segment, false];\n    }\n\n    /**\n     * Calculates distance between shape and Planar Set of shapes\n     * @param shape\n     * @param {PlanarSet} set\n     * @param {Number} min_stop\n     * @returns {*}\n     */\n    static shape2planarSet(shape, set, min_stop = Number.POSITIVE_INFINITY) {\n        let min_dist_and_segment = [min_stop, new Flatten.Segment()];\n        let stop = false;\n        if (set instanceof Flatten.PlanarSet) {\n            let tree = Distance.minmax_tree(shape, set, min_stop);\n            [min_dist_and_segment, stop] = Distance.minmax_tree_calc_distance(shape, tree.root, min_dist_and_segment);\n        }\n        return min_dist_and_segment;\n    }\n\n    static sort(dist_and_segment) {\n        dist_and_segment.sort((d1, d2) => {\n            if (Flatten.Utils.LT(d1[0], d2[0])) {\n                return -1;\n            }\n            if (Flatten.Utils.GT(d1[0], d2[0])) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    static distance(shape1, shape2) {\n        return shape1.distanceTo(shape2);\n    }\n}\n\nFlatten.Distance = Distance;\n\n// POINT (30 10)\n// MULTIPOINT (10 40, 40 30, 20 20, 30 10)\n// LINESTRING (30 10, 10 30, 40 40)\n// MULTILINESTRING ((10 10, 20 20, 10 40), (40 40, 30 30, 40 20, 30 10))\n// MULTILINESTRING ((8503.732 4424.547, 8963.747 3964.532), (8963.747 3964.532, 8707.468 3708.253), (8707.468 3708.253, 8247.454 4168.268), (8247.454 4168.268, 8503.732 4424.547))\n// POLYGON ((35 10, 45 45, 15 40, 10 20, 35 10), (20 30, 35 35, 30 20, 20 30))\n// MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)), ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35), (30 20, 20 15, 20 25, 30 20)))\n\nfunction parseSinglePoint(pointStr) {\n    return new Point$1(pointStr.split(' ').map(Number))\n}\n\nfunction parseMultiPoint(multipointStr) {\n    return multipointStr.split(', ').map(parseSinglePoint)\n}\n\nfunction parseLineString(lineStr) {\n    const points = parseMultiPoint(lineStr);\n    let segments = [];\n    for (let i = 0; i < points.length-1;  i++) {\n        segments.push(new Segment(points[i], points[i+1]));\n    }\n    return new Multiline(segments)\n}\n\nfunction parseMultiLineString(multilineStr) {\n    const lineStrings = multilineStr.replace(/\\(\\(/, '').replace(/\\)\\)$/, '').split('), (');\n    return lineStrings.map(parseLineString)\n}\n\nfunction parseSinglePolygon(polygonStr) {\n    const facesStr = polygonStr.replace(/\\(\\(/, '').replace(/\\)\\)$/, '').split('), (');\n    const polygon = new Polygon();\n    let orientation;\n    facesStr.forEach((facesStr, idx) => {\n        let points = facesStr.split(', ').map(coordStr => {\n            return new Point$1(coordStr.split(' ').map(Number))\n        });\n        const face = polygon.addFace(points);\n        if (idx === 0) {\n            orientation = face.orientation();\n        }\n        else {\n            if (face.orientation() === orientation) {\n                face.reverse();\n            }\n        }\n    });\n    return polygon\n}\n\nfunction parseMutliPolygon(multiPolygonString) {\n    const polygonStrings = multiPolygonString.split('?');\n    const polygons = polygonStrings.map(parseSinglePolygon);\n    const polygon = new Polygon();\n    const faces = polygons.reduce((acc, polygon) => [...acc, ...polygon?.faces], []);\n    faces.forEach(face => polygon.addFace([...face?.shapes]));\n    return polygon;\n}\n\nfunction parsePolygon(wkt) {\n    if (wkt.startsWith(\"POLYGON\")) {\n        const polygonStr = wkt.replace(/^POLYGON /, '');\n        return parseSinglePolygon(polygonStr)\n    }\n    else {\n        const multiPolygonString = wkt.replace(/^MULTIPOLYGON \\(/, '').replace(/\\)$/, '').replace(/\\)\\), \\(\\(/,'))?((');\n        return parseMutliPolygon(multiPolygonString)\n    }\n}\n\nfunction parseArrayOfPoints(str) {\n    const arr = str.split('\\n').map(x => x.match(/\\(([^)]+)\\)/)[1]);\n    return arr.map(parseSinglePoint)\n}\n\nfunction parseArrayOfLineStrings(str) {\n    const arr = str.split('\\n').map(x => x.match(/\\(([^)]+)\\)/)[1]);\n    return arr.map(parseLineString).reduce((acc, x) => [...acc, ...x], [])\n}\n\n/**\n * Convert WKT string to array of Flatten shapes.\n * @param str\n * @returns {Point | Point[] | Multiline | Multiline[] | Polygon | Shape[] | null}\n */\nfunction parseWKT(str) {\n    if (str.startsWith(\"POINT\")) {\n        const pointStr = str.replace(/^POINT \\(/, '').replace(/\\)$/, '');\n        return parseSinglePoint(pointStr)\n    }\n    else if (str.startsWith(\"MULTIPOINT\")) {\n        const multiPointStr = str.replace(/^MULTIPOINT \\(/, '').replace(/\\)$/, '');\n        return parseMultiPoint(multiPointStr)\n    }\n    else if (str.startsWith(\"LINESTRING\")) {\n        const lineStr = str.replace(/^LINESTRING \\(/, '').replace(/\\)$/, '');\n        return parseLineString(lineStr)\n    }\n    else if (str.startsWith(\"MULTILINESTRING\")) {\n        const multilineStr = str.replace(/^MULTILINESTRING /, '');\n        return parseMultiLineString(multilineStr)\n    }\n    else if (str.startsWith(\"POLYGON\") || str.startsWith(\"MULTIPOLYGON\")) {\n        return parsePolygon(str)\n    }\n    else if (str.startsWith(\"GEOMETRYCOLLECTION\")) {\n        const regex = /(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION) \\([^\\)]+\\)/g;\n        const wktArray = str.match(regex);\n        if (wktArray[0].startsWith('GEOMETRYCOLLECTION')) {\n            wktArray[0] = wktArray[0].replace('GEOMETRYCOLLECTION (','');\n        }\n        const flArray = wktArray.map(parseWKT).map(x => x instanceof Array ? x : [x]);\n        return flArray.reduce((acc, x) => [...acc, ...x], [])\n    }\n    else if (isArrayOfPoints(str)) {\n        return parseArrayOfPoints(str)\n    }\n    else if (isArrayOfLines(str)) {\n        return parseArrayOfLineStrings(str)\n    }\n    return []\n}\n\nfunction isArrayOfPoints(str) {\n    return str.split('\\n')?.every(str => str.includes('POINT'))\n}\n\nfunction isArrayOfLines(str) {\n    return str.split('\\n')?.every(str => str.includes('LINESTRING'))\n}\n\n/**\n * Return true if given string starts with one of WKT tags and possibly contains WKT string,\n * @param str\n * @returns {boolean}\n */\nfunction isWktString(str) {\n    return (\n        str.startsWith(\"POINT\") || isArrayOfPoints(str) ||\n        str.startsWith(\"LINESTRING\") || isArrayOfLines(str) ||\n        str.startsWith(\"MULTILINESTRING\") ||\n        str.startsWith(\"POLYGON\") ||\n        str.startsWith(\"MULTIPOINT\") ||\n        str.startsWith(\"MULTIPOLYGON\") ||\n        str.startsWith(\"GEOMETRYCOLLECTION\")\n    )\n}\n\nFlatten.isWktString = isWktString;\nFlatten.parseWKT = parseWKT;\n\n/**\n * Created by Alex Bol on 2/18/2017.\n */\n\n\nFlatten.BooleanOperations = BooleanOperations;\nFlatten.Relations = Relations;\n\nexport { Arc, BOUNDARY$1 as BOUNDARY, BooleanOperations, Box, CCW, CW, Circle$1 as Circle, Distance, Edge, Errors, Face, INSIDE$2 as INSIDE, Inversion, Line$1 as Line, Matrix, Multiline, ORIENTATION, OUTSIDE$1 as OUTSIDE, OVERLAP_OPPOSITE$1 as OVERLAP_OPPOSITE, OVERLAP_SAME$1 as OVERLAP_SAME, PlanarSet, Point$1 as Point, Polygon, Ray, Relations, Segment, smart_intersections as SmartIntersections, Utils$1 as Utils, Vector$1 as Vector, arc, box, circle, Flatten as default, inversion, isWktString, line, matrix, multiline, parseWKT, point, polygon, ray, ray_shoot, segment, vector$1 as vector };\n","// /* eslint-disable no-unused-vars */\n// import Flatten from 'https://unpkg.com/@flatten-js/core/dist/main.mjs';\nimport Flatten from '@flatten-js/core';\nconst {point, Polygon} = Flatten;\nconst {unify} = Flatten.BooleanOperations;\n\nexport function union(path0, path1, by_layer = true){\n  let path = [];\n  let points0 = [];\n  let points1 = [];\n  let layers = new Set();\n  for(let i = 3; i <= path0.length; i+=4){\n    points0.push(path0.slice(i-3, i+1))\n  }\n  for(let i = 3; i <= path1.length; i+=4){\n    points1.push(path1.slice(i-3, i+1))\n  }\n  \n  points0.sort((a, b) => a[2] - b[2]);\n  points1.sort((a, b) => a[2] - b[2]);\n  points0.forEach(point => layers.add(point[2]));\n  points1.forEach(point => layers.add(point[2]));\n  let shapes = new Array();\n  let total_num_points = 0;\n\n  for(let layer of layers){\n    let layer_points0 = points0.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n    let layer_points1 = points1.filter(p => p[2] == layer).map(p => point([p[0], p[1]]));\n    let polygon0 = new Polygon(layer_points0);\n    let polygon1 = new Polygon(layer_points1);\n\n    let thicknesses = new Map(); //store thickness in external data structure\n    for(let i = 0; i < points0.length; i++){\n      if (points0[i][2] == layer){\n        thicknesses.set([points0[i][0], points0[i][1]], points0[i][3]);\n      }\n    }\n    for(let i = 0; i < points1.length/4; i +=4){\n      if (points1[i][2] == layer){\n        thicknesses.set([[points1[i][0]], points1[i][1]], points1[i][3]);\n      }\n    }\n\n    console.log([...thicknesses.entries()]);\n\n    //to add: tolerance\n    let combinedPolygon = unify(polygon0, polygon1);\n    let polygonSVG = combinedPolygon.svg(); //convert to svg to rely on flatten-js's even-odd algorithm\n    const shapesString = polygonSVG.match(/(M[^M]+z)/g); //separate svg into just the section containing points\n    let shapeidx = 0;\n\n    for (let shape of shapesString){\n      let pairs = shape.match(/L-?\\d+(\\.\\d+)?,-?\\d+(\\.\\d+)?/g); //get pairs of points (not starting with M)\n      for (let pair of pairs){\n        var thickness = thicknesses.has(pair.match(/-?\\d+(\\.\\d+)?/g)); //todo: fix thickness (right now it's defaulting to \"false\" = 0)\n        \n        if(shapes.length < shapeidx + 1){\n          shapes.push([]);\n        }\n        if(!by_layer){ //push individual vessels to final array\n          shapes[shapeidx].push(...pair.match(/-?\\d+(\\.\\d+)?/g).map(parseFloat)); //push each pair as a float to the shapes arr\n          shapes[shapeidx].push(layer);\n          shapes[shapeidx].push(thickness);\n        } else{\n          shapes[0].push(...pair.match(/-?\\d+(\\.\\d+)?/g).map(parseFloat));\n          shapes[0].push(layer);\n          shapes[0].push(thickness);\n        }\n      }\n      if(by_layer){ //close the shape: push starting point of current shape to end of shape\n        shapes[0].push(shapes[0][(total_num_points)], shapes[0][(total_num_points)+1], layer, thickness);\n        let num_points = (pairs.length+1)*4;\n        total_num_points += num_points;\n      } else{\n        shapeidx += 1;\n      }\n    }\n  }\n  path = shapes.flat();\n  return path;\n}\n\n// export function unionAll(paths, by_layer = True){\n//   let union_path = new Array();\n//   for(let i = 1; i < paths.length; i++){\n//     let new_path = union(paths[0], paths[i], by_layer);\n    \n//   }\n// }\n\n// window.union = union;"],"names":["$4bcca76f36b7da04$var$setParams","paramType","value","nbPoints","mode","Array","fill","isArray","length","$4bcca76f36b7da04$export$c3c5e174940bbb4f","functionType","offset","values0","Error","window","sinusoidal","amplitude","values","i","push","Math","sin","PI","period","pow","base","ampExp","console","log","linear","exponential","square","bumps","$2c7a62d6ab88e4d3$export$7423c88bc54edb74","CCW","CW","NOT_ORIENTABLE","$2c7a62d6ab88e4d3$var$Constants","Object","freeze","__proto__","BOUNDARY","CONTAINS","END_VERTEX","INSIDE","INTERLACE","NOT_VERTEX","ORIENTATION","OUTSIDE","OVERLAP_OPPOSITE","OVERLAP_SAME","PIx2","START_VERTEX","$2c7a62d6ab88e4d3$var$DP_TOL","$2c7a62d6ab88e4d3$var$setTolerance","tolerance","$2c7a62d6ab88e4d3$var$getTolerance","$2c7a62d6ab88e4d3$var$EQ_0","x","$2c7a62d6ab88e4d3$var$EQ","y","$2c7a62d6ab88e4d3$var$GT","$2c7a62d6ab88e4d3$var$LT","$2c7a62d6ab88e4d3$export$2e2bcd8739ae039","Utils","DECIMALS","EQ","EQ_0","GE","GT","LE","LT","getTolerance","setTolerance","Errors","undefined","Matrix","Planar_set","Point","Vector","Line","Circle","Segment","Arc","Box","Edge","Face","Ray","Ray_shooting","Multiline","Polygon","Distance","Inversion","c","defineProperty","get","set","$2c7a62d6ab88e4d3$export$b8e9cd941e8016ac","ILLEGAL_PARAMETERS","ReferenceError","ZERO_DIVISION","UNRESOLVED_BOUNDARY_CONFLICT","INFINITE_LOOP","CANNOT_COMPLETE_BOOLEAN_OPERATION","CANNOT_INVOKE_ABSTRACT_METHOD","OPERATION_IS_NOT_SUPPORTED","$2c7a62d6ab88e4d3$var$LinkedList","constructor","first","last","Symbol","iterator","next","done","size","counter","edge","toArray","start","end","elements","from","to","element","append","isEmpty","prev","insert","newElement","elementBefore","elementAfter","remove","testInfiniteLoop","controlEdge","$2c7a62d6ab88e4d3$var$defaultAttributes","stroke","$2c7a62d6ab88e4d3$var$SVGAttributes","args","property","toAttributesString","keys","reduce","acc","key","toAttrString","SVGKey","convertCamelToKebabCase","toString","str","match","join","toLowerCase","$2c7a62d6ab88e4d3$var$convertToString","attrs","$2c7a62d6ab88e4d3$export$a5433e0f3b1dce29","shapes","shape","every","setArcLength","edges","box","merge","vertices","v","map","clone","toShapes","setOneEdgeArcLength","arc_length","addVertex","pt","split","newEdge","edgeBefore","getChain","edgeFrom","edgeTo","ip","findEdgeByPoint","edgeFound","contains","translate","vec","rotate","angle","center","transform","matrix","toJSON","svgPoints","p","dpath","dPathStr","svg","svgStr","$2c7a62d6ab88e4d3$var$addToIntPoints","int_points","id","len","is_vertex","Infinity","coord","edge_before","edge_after","face","$2c7a62d6ab88e4d3$var$sortIntersections","intersections","int_points1_sorted","$2c7a62d6ab88e4d3$var$getSortedArray","int_points1","int_points2_sorted","int_points2","faceMap","Map","has","faceId","slice","sort","$2c7a62d6ab88e4d3$var$compareFn","ip1","ip2","$2c7a62d6ab88e4d3$var$filterDuplicatedIntersections","int_point_ref1","int_point_ref2","int_point_cur1","int_point_cur2","do_squeeze","j","filter","int_point","forEach","index","$2c7a62d6ab88e4d3$var$initializeInclusionFlags","bvStart","bvEnd","bv","overlap","$2c7a62d6ab88e4d3$var$calculateInclusionFlags","polygon","setInclusion","$2c7a62d6ab88e4d3$var$intPointsPoolCount","cur_int_point_num","cur_face","int_point_current","int_point_next","int_points_pool_num","equalTo","$2c7a62d6ab88e4d3$var$splitByIntersections","$2c7a62d6ab88e4d3$var$insertBetweenIntPoints","int_point1","int_point2","new_edges","multiline","$2c7a62d6ab88e4d3$var$INSIDE$1","$2c7a62d6ab88e4d3$var$OUTSIDE","$2c7a62d6ab88e4d3$var$BOUNDARY","$2c7a62d6ab88e4d3$var$OVERLAP_SAME","$2c7a62d6ab88e4d3$var$OVERLAP_OPPOSITE","$2c7a62d6ab88e4d3$var$NOT_VERTEX","$2c7a62d6ab88e4d3$var$START_VERTEX","$2c7a62d6ab88e4d3$var$END_VERTEX","$2c7a62d6ab88e4d3$var$subtract","polygon1","polygon2","res_poly","wrk_poly","$2c7a62d6ab88e4d3$var$booleanOpBinary","polygon2_tmp","reverse","$2c7a62d6ab88e4d3$var$intersect$1","$2c7a62d6ab88e4d3$var$innerClip","clip_shapes1","faces","clip_shapes2","$2c7a62d6ab88e4d3$var$outerClip","$2c7a62d6ab88e4d3$var$calculateIntersections","$2c7a62d6ab88e4d3$var$getIntersections","op","restore","$2c7a62d6ab88e4d3$var$filterNotRelevantEdges","notIntersectedFacesRes","$2c7a62d6ab88e4d3$var$getNotIntersectedFaces","notIntersectedFacesWrk","$2c7a62d6ab88e4d3$var$calcInclusionForNotIntersectedFaces","$2c7a62d6ab88e4d3$var$fixBoundaryConflicts","poly1","poly2","first_int_point_in_face_id","next_int_point1","num_int_points","iterate_more","next_int_point_id","cur_int_point1","int_points_cur_pool_start","int_points_cur_pool_num","int_points_next_pool_num","next_int_point1_tmp","edge_from1","edge_to1","edge_tmp","new_bv","dist","segment","distanceTo","DP_TOL","ps","newEdge1","edge2","pe","int_point2_edge_after","find","newEdge2","$2c7a62d6ab88e4d3$var$setOverlappingFlags","cur_int_point2","next_int_point2","edge_from2","edge_to2","setOverlap","$2c7a62d6ab88e4d3$var$removeNotRelevantChains","$2c7a62d6ab88e4d3$var$removeNotRelevantNotIntersectedFaces","$2c7a62d6ab88e4d3$var$copyWrkToRes","res_polygon","wrk_polygon","add","addFace","$2c7a62d6ab88e4d3$var$swapLinks","$2c7a62d6ab88e4d3$var$removeOldFaces","$2c7a62d6ab88e4d3$var$restoreFaces","edge1","search","intersect","poly","notIntersected","notIntersectedFaces","is_res_polygon","first_int_point_in_face_num","next_int_point_num","int_points_from_pull_start","int_points_from_pull_num","int_points_to_pull_num","edge_from","edge_to","removeChain","k","int_points_to_pull_start","delete","other_int_points","error","int_point_tmp","rel","deleteFace","$2c7a62d6ab88e4d3$export$7810ed04e2e13fba","BOOLEAN_INTERSECT","BOOLEAN_SUBTRACT","BOOLEAN_UNION","calculateIntersections","innerClip","outerClip","removeNotRelevantChains","removeOldFaces","restoreFaces","subtract","unify","$2c7a62d6ab88e4d3$var$EQUAL","RegExp","$2c7a62d6ab88e4d3$var$INTERSECT","$2c7a62d6ab88e4d3$var$TOUCH","$2c7a62d6ab88e4d3$var$INSIDE","$2c7a62d6ab88e4d3$var$COVERED","$2c7a62d6ab88e4d3$var$DE9IM","m","I2I","geom","I2B","I2E","B2I","B2B","B2E","E2I","E2B","E2E","e","equal","test","touch","inside","covered","$2c7a62d6ab88e4d3$var$intersectLine2Line","line1","line2","A1","B1","C1","standard","A2","B2","C2","det","detX","detY","$2c7a62d6ab88e4d3$var$intersectLine2Circle","line","circle","prj","pc","projectionOn","r","v_trans","delta","sqrt","norm","rotate90CCW","multiply","rotate90CW","$2c7a62d6ab88e4d3$var$intersectLine2Box","ips","seg","toSegments","$2c7a62d6ab88e4d3$var$intersectSegment2Line","$2c7a62d6ab88e4d3$var$ptInIntPoints","$2c7a62d6ab88e4d3$var$intersectLine2Arc","arc","on","isZeroLength","leftTo","$2c7a62d6ab88e4d3$var$intersectSegment2Segment","seg1","seg2","not_intersect","incidentTo","new_ip","$2c7a62d6ab88e4d3$var$isPointInSegmentBox","point","xmax","xmin","ymax","ymin","$2c7a62d6ab88e4d3$var$intersectSegment2Circle","_","$2c7a62d6ab88e4d3$var$intersectSegment2Arc","$2c7a62d6ab88e4d3$var$intersectCircle2Circle","circle1","circle2","r1","r2","abs","a","mid_pt","h","$2c7a62d6ab88e4d3$var$intersectArc2Arc","arc1","arc2","$2c7a62d6ab88e4d3$var$intersectArc2Circle","$2c7a62d6ab88e4d3$var$intersectEdge2Segment","isSegment","$2c7a62d6ab88e4d3$var$intersectEdge2Arc","$2c7a62d6ab88e4d3$var$intersectEdge2Line","$2c7a62d6ab88e4d3$var$intersectSegment2Polygon","$2c7a62d6ab88e4d3$var$intersectArc2Polygon","$2c7a62d6ab88e4d3$var$intersectLine2Polygon","sortPoints","$2c7a62d6ab88e4d3$var$intersectCircle2Polygon","$2c7a62d6ab88e4d3$var$intersectEdge2Edge","isArc","isLine","isRay","ray","$2c7a62d6ab88e4d3$var$intersectRay2Segment","$2c7a62d6ab88e4d3$var$intersectRay2Arc","new_pt","some","$2c7a62d6ab88e4d3$var$createLineFromRay","$2c7a62d6ab88e4d3$var$intersectRay2Circle","$2c7a62d6ab88e4d3$var$intersectRay2Line","$2c7a62d6ab88e4d3$var$intersectRay2Polygon","$2c7a62d6ab88e4d3$export$3adad403c78dc9b2","searchBox","resp_edges","face_index","indexOf","i1","i2","intersection","prev_edge","prev_tangent","tangentInEnd","prev_point","cur_tangent","tangentInStart","cur_point","prev_on_the_left","cur_on_the_left","next_edge","next_tangent","next_point","next_on_the_left","$2c7a62d6ab88e4d3$var$intersect","shape1","shape2","$2c7a62d6ab88e4d3$var$relate","$2c7a62d6ab88e4d3$var$inside","$2c7a62d6ab88e4d3$var$covered","$2c7a62d6ab88e4d3$var$cover","denim","$2c7a62d6ab88e4d3$var$relateLine2Circle","ip_sorted","splitShapes","toArc","cutWithLine","$2c7a62d6ab88e4d3$var$relateLine2Box","$2c7a62d6ab88e4d3$var$relateShape2Polygon","$2c7a62d6ab88e4d3$var$relatePolygon2Polygon","ip_sorted1","ip_sorted2","boolean_intersection","boolean_difference1","boolean_difference2","inner_clip_shapes1","inner_clip_shapes2","outer_clip_shapes1","outer_clip_shapes2","$2c7a62d6ab88e4d3$export$932c2897ef8e4e8e","contain","cover","disjoint","relate","$2c7a62d6ab88e4d3$export$5b12bf1653c0dd85","b","d","tx","ty","vector","other_matrix","isNaN","centerX","centerY","cos","scale","sx","sy","$2c7a62d6ab88e4d3$var$Interval","Interval","low","high","max","less_than","other_interval","equal_to","min","output","comparable_max","interval1","interval2","comparable_less_than","val1","val2","$2c7a62d6ab88e4d3$var$Node","left","right","parent","color","item","Number","isNil","_value_less_than","other_node","_value_equal","copy_data","update_max","not_intersect_left_subtree","search_node","not_intersect_right_subtree","$2c7a62d6ab88e4d3$var$IntervalTree","root","nil_node","count","tree_walk","res","node","items","clear","insert_node","tree_insert","recalc_max","exist","tree_search","delete_node","tree_delete","interval","outputMapperFn","resp_nodes","tree_search_interval","intersect_any","tree_find_any_interval","visitor","callback","tree","node_current","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","tree_successor","delete_fixup","brother_node","found","local_minimum","node_min","local_maximum","node_max","node_successor","action","testRedBlackProperty","testBlackHeightProperty","height","heightLeft","$2c7a62d6ab88e4d3$export$bfc59922c63341df","Set","entry","deleted","hit","resp","PlanarSet","$2c7a62d6ab88e4d3$var$Shape","name","assign","$2c7a62d6ab88e4d3$export$baf26146a414f24a","arr","lessThan","cross","dot","proj_vec","dx","dy","point2line","point2circle","point2segment","point2arc","point2polygon","shape2planarSet","$2c7a62d6ab88e4d3$export$9b781de7bf37bf48","a1","a2","slope","atan2","scalar","normalize","invert","angleTo","norm1","norm2","n","$2c7a62d6ab88e4d3$export$6074e20ba5c64bef","$2c7a62d6ab88e4d3$export$d53aa5c5ab432700","coords","distanceToPoint","$2c7a62d6ab88e4d3$var$intersectSegment2Box","shortest_segment","segment2circle","segment2line","segment2segment","segment2arc","shape2polygon","middle","pointAtLength","factor","rest","definiteIntegral","dy1","pts","$2c7a62d6ab88e4d3$var$vector","$2c7a62d6ab88e4d3$export$17d680238e50603e","points2norm","POSITIVE_INFINITY","NEGATIVE_INFINITY","parallelTo","other_line","distance","circle2line","arc2line","sorted_points","pt1","pt2","unit","$2c7a62d6ab88e4d3$export$c89a927ffc67e6fa","counterclockwise","$2c7a62d6ab88e4d3$var$intersectCircle2Box","circle2circle","arc2circle","startAngle","endAngle","counterClockwise","sweep","p0","func_arcs","breakToFunctional","test_arc","chordHeight","$2c7a62d6ab88e4d3$var$intersectArc2Box","arc2arc","func_arcs_array","angles","test_arcs","new_arc","prev_arc","newStart","newEnd","newCenter","newDirection","arcSE","f_arcs","circularSegmentDefiniteIntegral","onLeftSide","areaTrapez","areaCircularSegment","circularSegmentArea","slope1","slope2","largeArcFlag","sweepFlag","$2c7a62d6ab88e4d3$export$e71c4d32a2263218","width","other_box","box1","box2","toPoints","transformed_points","new_box","vertex","bvMiddle","flag","sign","halfArc1","halfArc2","$2c7a62d6ab88e4d3$var$CircularLinkedList","setCircularLinks","$2c7a62d6ab88e4d3$export$aa6504bc3c7c25a1","_box","_orientation","segments","points2segments","shapes2face","points","flattenShapes","flattenShape","perimeter","merge_with_next_edge","orientation","area","signedArea","sArea","isSimple","getSelfIntersections","exitOnFirst","toPolygon","$2c7a62d6ab88e4d3$export$a186db52eed6d40e","ray1","ray2","$2c7a62d6ab88e4d3$export$7d31b617c820d435","arguments","argsArray","loop","el","loop1","isValid","valid","recreateFaces","unassignedEdgeFound","removeEndVertex","edge_next","cut","int_point1_prev","int_point1_curr","newPoly","newEdges","splitToIslands","polygons","newPolygons","islandPolygon","min_dist_and_segment","min_stop","$2c7a62d6ab88e4d3$var$intersectPolygon2Polygon","$2c7a62d6ab88e4d3$var$intersectEdge2Polygon","resp_edge","newPolygon","fillRule","$2c7a62d6ab88e4d3$var$Circle","$2c7a62d6ab88e4d3$var$Line","$2c7a62d6ab88e4d3$var$Point","$2c7a62d6ab88e4d3$var$Vector","$2c7a62d6ab88e4d3$var$Utils","$2c7a62d6ab88e4d3$export$ff40fcfb940069c","inversion_circle","inversePoint","k2","len2","inverseCircle","s","inverseLine","inverse","inversion","$2c7a62d6ab88e4d3$export$3081247862d57e3d","point2point","closest_point","dist2center","shortest_dist","v_seg","v_ps2pt","v_pe2pt","start_sp","end_sp","v_unit","dist_and_segment","dist_tmp","shortest_segment_tmp","dist_from_start","shortest_segment_from_start","dist_from_end","shortest_segment_from_end","segment_tmp","dist_from_center","shortest_segment_from_center","dist_from_projection","shortest_segment_from_projection","polygon2polygon","box2box_minmax","mindist_x","mindist_y","minmax_tree_process_level","level","mindist","maxdist","new_level","minmax_tree","squared_min_stop","minmax_tree_calc_distance","min_dist_and_segment_new","stop","d1","d2","$2c7a62d6ab88e4d3$var$parseSinglePoint","pointStr","$2c7a62d6ab88e4d3$var$parseMultiPoint","multipointStr","$2c7a62d6ab88e4d3$var$parseLineString","lineStr","$2c7a62d6ab88e4d3$var$parseSinglePolygon","polygonStr","facesStr","replace","idx","coordStr","$2c7a62d6ab88e4d3$var$isArrayOfPoints","includes","$2c7a62d6ab88e4d3$var$isArrayOfLines","isWktString","startsWith","parseWKT","$2c7a62d6ab88e4d3$export$86c11aa368fb2b9f","lineStrings","multilineStr","wkt","$2c7a62d6ab88e4d3$var$parseMutliPolygon","multiPolygonString","polygonStrings","wktArray","flArray","BooleanOperations","Relations","$66bd0219ab6a9102$var$point","$66bd0219ab6a9102$var$Polygon","$66bd0219ab6a9102$var$subtract","$ca82cb4564517254$var$point","$ca82cb4564517254$var$Polygon","$ca82cb4564517254$var$unify"],"version":3,"file":"index.js.map"}